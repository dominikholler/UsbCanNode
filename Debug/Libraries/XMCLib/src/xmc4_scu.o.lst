   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "xmc4_scu.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.XMC_SCU_CLOCK_GetUsbClockSource,"ax",%progbits
  20              	 .align 2
  21              	 .thumb
  22              	 .thumb_func
  24              	XMC_SCU_CLOCK_GetUsbClockSource:
  25              	.LFB129:
  26              	 .file 1 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Libraries\\XMCLib\\inc/xmc4_scu.h"
   1:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
   2:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @file xmc4_scu.h
   3:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @date 2016-01-12
   4:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
   5:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @cond
   6:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   *************************************************************************************************
   7:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMClib v2.1.6 - XMC Peripheral Driver Library 
   8:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
   9:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  10:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * All rights reserved.                        
  11:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                                             
  12:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * following conditions are met:   
  14:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                                                                              
  15:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  16:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * disclaimer.                        
  17:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * 
  18:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  19:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  20:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * 
  21:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  22:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * products derived from this software without specific prior written permission.                  
  23:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                                                                              
  24:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  31:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                                                                              
  32:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  34:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  **************************************************************************************************
  35:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
  36:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Change History
  37:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * --------------
  38:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
  39:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * 2015-06-20:
  40:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *     - Initial version
  41:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *     - Documentation improved
  42:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
  43:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * 2015-11-30:
  44:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *     - Documentation improved <br>
  45:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *      
  46:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @endcond 
  47:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
  48:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
  49:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  50:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #ifndef XMC4_SCU_H
  51:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC4_SCU_H
  52:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  53:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**************************************************************************************************
  54:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * HEADER FILES
  55:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  **************************************************************************************************
  56:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  57:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #include "xmc_common.h"
  58:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  59:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if UC_FAMILY == XMC4
  60:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  61:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
  62:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @addtogroup XMClib XMC Peripheral Library
  63:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @{
  64:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
  65:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  
  66:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
  67:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @addtogroup SCU
  68:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @{
  69:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
  70:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  71:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**************************************************************************************************
  72:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * MACROS
  73:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  **************************************************************************************************
  74:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_PDIV_XTAL_8MHZ (1U)  /* PDIV value for main PLL settings, fPLL = 120MHz with fOSC = 8MH
  75:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_NDIV_XTAL_8MHZ (89U)  /* NDIV value for main PLL settings, fPLL = 120MHz with fOSC = 8M
  76:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_K2DIV_XTAL_8MHZ (2U)  /* K2DIV value for main PLL settings, fPLL = 120MHz with fOSC = 8
  77:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  78:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_PDIV_XTAL_12MHZ (1U)  /* PDIV value for main PLL settings, fPLL = 120MHz with fOSC = 12
  79:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_NDIV_XTAL_12MHZ (79U)  /* NDIV value for main PLL settings, fPLL = 120MHz with fOSC = 1
  80:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_K2DIV_XTAL_12MHZ (3U)  /* K2DIV value for main PLL settings, fPLL = 120MHz with fOSC = 
  81:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  82:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_PDIV_XTAL_16MHZ (1U)  /* PDIV value for main PLL settings, fPLL = 120MHz with fOSC = 16
  83:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_NDIV_XTAL_16MHZ (59U)  /* NDIV value for main PLL settings, fPLL = 120MHz with fOSC = 1
  84:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_K2DIV_XTAL_16MHZ (3U)  /* K2DIV value for main PLL settings, fPLL = 120MHz with fOSC = 
  85:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  86:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_WDT_WARN           SCU_INTERRUPT_SRSTAT_PRWARN_Msk /**< Watchdog pr
  87:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RTC_PERIODIC       SCU_INTERRUPT_SRSTAT_PI_Msk     /**< RTC periodi
  88:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RTC_ALARM          SCU_INTERRUPT_SRSTAT_AI_Msk     /**< RTC alarm e
  89:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_DLR_OVERRUN        SCU_INTERRUPT_SRSTAT_DLROVR_Msk /**< DLR overrun
  90:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_LPACCR_Msk)
  91:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_LPACCR_UPDATED     SCU_INTERRUPT_SRSTAT_LPACCR_Msk /**< LPAC Contro
  92:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
  93:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_LPACTH0_Msk)
  94:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_LPACTH0_UPDATED    SCU_INTERRUPT_SRSTAT_LPACTH0_Msk /**< LPAC Thres
  95:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
  96:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_LPACTH1_Msk)
  97:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_LPACTH1_UPDATED    SCU_INTERRUPT_SRSTAT_LPACTH1_Msk  /**< LPAC Thre
  98:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
  99:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_LPACST_Msk)
 100:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_LPACST_UPDATED     SCU_INTERRUPT_SRSTAT_LPACST_Msk  /**< LPAC Statu
 101:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 102:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_LPACCLR_Msk)
 103:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_LPACCLR_UPDATED    SCU_INTERRUPT_SRSTAT_LPACCLR_Msk /**< LPAC event
 104:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 105:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_LPACSET_Msk)
 106:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_LPACSET_UPDATED    SCU_INTERRUPT_SRSTAT_LPACSET_Msk /**< LPAC event
 107:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 108:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_HINTST_Msk)
 109:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_HINTST_UPDATED     SCU_INTERRUPT_SRSTAT_HINTST_Msk /**< HIB HINTST 
 110:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 111:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_HINTCLR_Msk)
 112:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_HINTCLR_UPDATED    SCU_INTERRUPT_SRSTAT_HINTCLR_Msk /**< HIB HINTCL
 113:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 114:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_HINTSET_Msk)
 115:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_HINTSET_UPDATED    SCU_INTERRUPT_SRSTAT_HINTSET_Msk /**< HIB HINTSE
 116:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 117:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_HDSTAT_UPDATED     SCU_INTERRUPT_SRSTAT_HDSTAT_Msk /**< HIB HDSTAT 
 118:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_HDCLR_UPDATED      SCU_INTERRUPT_SRSTAT_HDCLR_Msk /**< HIB HDCLR re
 119:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_HDSET_UPDATED      SCU_INTERRUPT_SRSTAT_HDSET_Msk /**< HIB HDSET re
 120:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_HDCR_UPDATED       SCU_INTERRUPT_SRSTAT_HDCR_Msk /**< HIB HDCR regi
 121:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_OSCSICTRL_UPDATED  SCU_INTERRUPT_SRSTAT_OSCSICTRL_Msk /**< HIB OSCS
 122:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_OSCULSTAT_UPDATED  SCU_INTERRUPT_SRSTAT_OSCULSTAT_Msk /**< HIB OSCU
 123:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_OSCULCTRL_UPDATED  SCU_INTERRUPT_SRSTAT_OSCULCTRL_Msk /**< HIB OSCU
 124:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RTCCTR_UPDATED     SCU_INTERRUPT_SRSTAT_RTC_CTR_Msk /**< HIB RTCCTR
 125:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RTCATIM0_UPDATED   SCU_INTERRUPT_SRSTAT_RTC_ATIM0_Msk /**< HIB RTCA
 126:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RTCATIM1_UPDATED   SCU_INTERRUPT_SRSTAT_RTC_ATIM1_Msk /**< HIB RTCA
 127:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RTCTIM0_UPDATED    SCU_INTERRUPT_SRSTAT_RTC_TIM0_Msk /**< HIB TIM0 
 128:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RTCTIM1_UPDATED    SCU_INTERRUPT_SRSTAT_RTC_TIM1_Msk /**< HIB TIM1 
 129:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RMX_UPDATED        SCU_INTERRUPT_SRSTAT_RMX_Msk /**< HIB RMX regist
 130:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 131:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**************************************************************************************************
 132:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * ENUMS
 133:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  **************************************************************************************************
 134:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 135:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines Capture/Compare unit timer slice trigger, that enables synchronous start function avail
 136:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  CCUCON register. Use type \a XMC_SCU_CCU_TRIGGER_t for accessing these enum parameters.
 137:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 138:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CCU_TRIGGER
 139:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 140:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU40)
 141:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CCU_TRIGGER_CCU40 = SCU_GENERAL_CCUCON_GSC40_Msk, /**< Trigger mask used for Global Start
 142:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  CCU40 peripheral. */
 143:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 144:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU41)
 145:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CCU_TRIGGER_CCU41 = SCU_GENERAL_CCUCON_GSC41_Msk, /**< Trigger mask used for Global Start
 146:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  CCU41 peripheral. */
 147:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 148:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU42)
 149:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CCU_TRIGGER_CCU42 = SCU_GENERAL_CCUCON_GSC42_Msk, /**< Trigger mask used for Global Start
 150:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  CCU42 peripheral. */
 151:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 152:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU43)
 153:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CCU_TRIGGER_CCU43 = SCU_GENERAL_CCUCON_GSC43_Msk, /**< Trigger mask used for Global Start
 154:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  CCU43 peripheral. */
 155:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 156:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU80)
 157:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CCU_TRIGGER_CCU80 = SCU_GENERAL_CCUCON_GSC80_Msk, /**< Trigger mask used for Global Start
 158:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  CCU80 peripheral. */
 159:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 160:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU81)
 161:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CCU_TRIGGER_CCU81 = SCU_GENERAL_CCUCON_GSC81_Msk /**< Trigger mask used for Global Start 
 162:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  CCU41 peripheral. */
 163:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 164:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CCU_TRIGGER_t;
 165:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 166:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 167:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines enumerations representing the status of trap cause. The cause of the trap gets automati
 168:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  the \a TRAPSTAT register and can be checked by user software to determine the state of the syst
 169:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  purpose. 
 170:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_TRAP_t for accessing these enum parameters.
 171:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 172:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_TRAP 
 173:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 174:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_OSC_WDG      = SCU_TRAP_TRAPSTAT_SOSCWDGT_Msk, /**< OSC_HP Oscillator Watchdog trap.
 175:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_VCO_LOCK     = SCU_TRAP_TRAPSTAT_SVCOLCKT_Msk, /**< PLL loss of lock trap. */
 176:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_USB_VCO_LOCK = SCU_TRAP_TRAPSTAT_UVCOLCKT_Msk, /**< USB PLL loss of lock trap. */ 
 177:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_PARITY_ERROR = SCU_TRAP_TRAPSTAT_PET_Msk,      /**< Memory Parity error trap. */  
 178:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_BROWNOUT     = SCU_TRAP_TRAPSTAT_BRWNT_Msk,    /**< Brownout trap. */ 
 179:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_ULP_WDG      = SCU_TRAP_TRAPSTAT_ULPWDGT_Msk,  /**< Unstable 32KHz clock trap. */ 
 180:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_PER_BRIDGE0  = SCU_TRAP_TRAPSTAT_BWERR0T_Msk,  /**< Bad memory access of peripherals
 181:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_PER_BRIDGE1  = SCU_TRAP_TRAPSTAT_BWERR1T_Msk,  /**< Bad memory access of peripherals
 182:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_TRAP_TRAPSTAT_TEMPHIT_Msk)
 183:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_DIETEMP_HIGH = SCU_TRAP_TRAPSTAT_TEMPHIT_Msk,  /**< Die temperature higher than expe
 184:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 185:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_TRAP_TRAPSTAT_TEMPLOT_Msk)
 186:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_DIETEMP_LOW  = SCU_TRAP_TRAPSTAT_TEMPLOT_Msk,  /**< Die temperature lower than expec
 187:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 188:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ECAT0)
 189:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_ECAT_RESET = SCU_TRAP_TRAPSTAT_ECAT0RST_Msk, /**< EtherCat Reset */ 
 190:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 191:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_TRAP_t;
 192:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 193:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 194:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines enumerations for different parity event generating modules that in turn generate a trap
 195:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Parity can be enabled with \a PETE register in order to get the trap flag reflected in \a TRAPR
 196:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  configure parity error trap generation mechanism bits of \a PETE register.
 197:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  All the enum items are tabulated as per bits present in \a PETE register.
 198:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_PARITY_t for accessing these enum parameters.
 199:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 200:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_PARITY
 201:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 202:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_PSRAM_MEM  = SCU_PARITY_PEEN_PEENPS_Msk,   /**< Program SRAM parity error trap. */
 203:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_DSRAM1_MEM = SCU_PARITY_PEEN_PEENDS1_Msk,  /**< Data SRAM-1 parity error trap. */ 
 204:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(XMC_SCU_PARITY_DSRAM2_MEM)
 205:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_DSRAM2_MEM = SCU_PARITY_PEEN_PEENDS2_Msk,  /**< Data SRAM-2 parity error trap. */ 
 206:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 207:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_USIC0_MEM  = SCU_PARITY_PEEN_PEENU0_Msk,   /**< USIC0 memory parity error trap. */
 208:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(XMC_SCU_PARITY_USIC1_MEM)
 209:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_USIC1_MEM  = SCU_PARITY_PEEN_PEENU1_Msk,   /**< USIC1 memory parity error trap. */
 210:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 211:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(XMC_SCU_PARITY_USIC2_MEM)
 212:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_USIC2_MEM  = SCU_PARITY_PEEN_PEENU2_Msk,   /**< USIC2 memory parity error trap. */
 213:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 214:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_MCAN_MEM   = SCU_PARITY_PEEN_PEENMC_Msk,   /**< CAN memory parity error trap. */
 215:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_PMU_MEM    = SCU_PARITY_PEEN_PEENPPRF_Msk, /**< PMU Prefetch memory parity error t
 216:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_USB_MEM    = SCU_PARITY_PEEN_PEENUSB_Msk,  /**< USB memory parity error trap. */ 
 217:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_PARITY_PEEN_PEENETH0TX_Msk)
 218:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_ETH_TXMEM  = SCU_PARITY_PEEN_PEENETH0TX_Msk, /**< Ethernet transmit memory parity 
 219:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 220:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_PARITY_PEEN_PEENETH0RX_Msk)
 221:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_ETH_RXMEM  = SCU_PARITY_PEEN_PEENETH0RX_Msk, /**< Ethernet receive memory parity e
 222:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 223:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_PARITY_PEEN_PEENSD0_Msk)
 224:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_SDMMC_MEM0 = SCU_PARITY_PEEN_PEENSD0_Msk, /**< SDMMC Memory-0 parity error trap. *
 225:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 226:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_PARITY_PEEN_PEENSD1_Msk)
 227:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_SDMMC_MEM1 = SCU_PARITY_PEEN_PEENSD1_Msk, /**< SDMMC Memory-1 parity error trap. *
 228:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 229:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_PARITY_t;
 230:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 231:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 232:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines the different causes for last reset. The cause of the last reset gets automatically sto
 233:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  the \a SCU_RSTSTAT register and can be checked by user software to determine the state of the s
 234:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  purpose. All the enum items are tabulated as per bits present in \a SCU_RSTSTAT register.
 235:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_RESET_REASON_t for accessing these enum parameters.
 236:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 237:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_RESET_REASON
 238:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 239:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_RESET_REASON_PORST        = (1UL << SCU_RESET_RSTSTAT_RSTSTAT_Pos), /**< Reset due to Pow
 240:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_RESET_REASON_SWD          = (2UL << SCU_RESET_RSTSTAT_RSTSTAT_Pos), /**< Reset due to Ser
 241:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_RESET_REASON_PV           = (4UL << SCU_RESET_RSTSTAT_RSTSTAT_Pos), /**< Reset due to Pow
 242:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_RESET_REASON_SW           = (8UL << SCU_RESET_RSTSTAT_RSTSTAT_Pos), /**< Reset due to Sof
 243:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_RESET_REASON_LOCKUP       = (16UL << SCU_RESET_RSTSTAT_RSTSTAT_Pos), /**< Reset due to re
 244:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_RESET_REASON_WATCHDOG     = (32UL << SCU_RESET_RSTSTAT_RSTSTAT_Pos), /**< Reset due to Wa
 245:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_RESET_REASON_PARITY_ERROR = (128UL << SCU_RESET_RSTSTAT_RSTSTAT_Pos), /**< Reset due to r
 246:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_RESET_REASON_t;
 247:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 248:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 249:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines enumerations for events which can lead to interrupt. These enumeration values represent
 250:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * status of one of the bits in \a SRSTAT register. 
 251:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_INTERRUPT_EVENT_t for accessing these enum parameters.
 252:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 253:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef uint32_t XMC_SCU_INTERRUPT_EVENT_t;
 254:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 255:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  
 256:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 257:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines enumeration for the events that can generate non maskable interrupt(NMI).
 258:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  The NMI generation can be enabled with \a NMIREQEN register. The event will be reflected in \a 
 259:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  mirrored in the TRAPSTAT register. These enums can be used to configure NMI request generation 
 260:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  NMIREQEN register.  Once configured, these events can generate non maskable interrupt.
 261:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  All the enum items are tabulated as per bits present in \a NMIREQEN register.
 262:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_NMIREQ_t for accessing these enum parameters.
 263:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 264:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_NMIREQ
 265:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 266:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_NMIREQ_WDT_WARN = SCU_INTERRUPT_NMIREQEN_PRWARN_Msk, /**< Watchdog timer Pre-Warning even
 267:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_NMIREQ_RTC_PI   = SCU_INTERRUPT_NMIREQEN_PI_Msk,     /**< RTC Periodic event */ 
 268:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_NMIREQ_RTC_AI   = SCU_INTERRUPT_NMIREQEN_AI_Msk,     /**< RTC Alarm event */ 
 269:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_NMIREQ_ERU0_0   = SCU_INTERRUPT_NMIREQEN_ERU00_Msk,  /**< Channel 0 event of ERU0 */  
 270:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_NMIREQ_ERU0_1   = SCU_INTERRUPT_NMIREQEN_ERU01_Msk,  /**< Channel 1 event of ERU0 */ 
 271:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_NMIREQ_ERU0_2   = SCU_INTERRUPT_NMIREQEN_ERU02_Msk,  /**< Channel 2 event of ERU0 */ 
 272:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_NMIREQ_ERU0_3   = SCU_INTERRUPT_NMIREQEN_ERU03_Msk   /**< Channel 3 event of ERU0 */ 
 273:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_NMIREQ_t;
 274:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   
 275:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 276:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 277:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines enumeration representing different peripheral reset bits in the \a PRSTAT registers.
 278:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  All the enum items are tabulated as per bits present in \a PRSTAT0,  \a PRSTAT1,  \a PRSTAT2,
 279:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  \a PRSTAT3 registers. Use type \a XMC_SCU_PERIPHERAL_RESET_t for accessing these enum parameter
 280:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Note: Release of reset should be prevented when the peripheral clock is gated in cases where ke
 281:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  clock and bus interface clocks are shared, in order to avoid system hang-up.
 282:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 283:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_PERIPHERAL_RESET
 284:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 285:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_VADC   = SCU_RESET_PRSTAT0_VADCRS_Msk,   /**< VADC reset. */ 
 286:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(DSD)
 287:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_DSD    = SCU_RESET_PRSTAT0_DSDRS_Msk,    /**< DSD reset. */
 288:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 289:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_CCU40  = SCU_RESET_PRSTAT0_CCU40RS_Msk,  /**< CCU40 reset. */
 290:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU41)
 291:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_CCU41  = SCU_RESET_PRSTAT0_CCU41RS_Msk,  /**< CCU41 reset. */
 292:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 293:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU42)
 294:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_CCU42  = SCU_RESET_PRSTAT0_CCU42RS_Msk,  /**< CCU42 reset. */
 295:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 296:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU80)
 297:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_CCU80  = SCU_RESET_PRSTAT0_CCU80RS_Msk,  /**< CCU80 reset. */
 298:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 299:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU81)
 300:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_CCU81  = SCU_RESET_PRSTAT0_CCU81RS_Msk,  /**< CCU81 reset. */
 301:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 302:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(POSIF0)
 303:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_POSIF0 = SCU_RESET_PRSTAT0_POSIF0RS_Msk, /**< POSIF0 reset. */
 304:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 305:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(POSIF1)
 306:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_POSIF1 = SCU_RESET_PRSTAT0_POSIF1RS_Msk, /**< POSIF1 reset.*/
 307:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 308:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_USIC0  = SCU_RESET_PRSTAT0_USIC0RS_Msk,  /**< USIC0 reset. */
 309:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_ERU1   = SCU_RESET_PRSTAT0_ERU1RS_Msk,   /**< ERU1 reset. */
 310:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(HRPWM0)
 311:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_HRPWM0 = SCU_RESET_PRSTAT0_HRPWM0RS_Msk,  /**< HRPWM0 reset. */
 312:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 313:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU43)
 314:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_CCU43  = (SCU_RESET_PRSTAT1_CCU43RS_Msk | 0x10000000UL),   /**< CCU43 re
 315:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 316:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(LEDTS0)
 317:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_LEDTS0 = (SCU_RESET_PRSTAT1_LEDTSCU0RS_Msk | 0x10000000UL), /**< LEDTS0 
 318:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 319:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CAN)
 320:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_MCAN   = (SCU_RESET_PRSTAT1_MCAN0RS_Msk | 0x10000000UL), /**< MCAN reset
 321:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 322:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(DAC)  
 323:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_DAC    = (SCU_RESET_PRSTAT1_DACRS_Msk | 0x10000000UL),    /**< DAC reset
 324:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 325:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SDMMC)
 326:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_SDMMC  = (SCU_RESET_PRSTAT1_MMCIRS_Msk | 0x10000000UL),     /**< SDMMC r
 327:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 328:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USIC1)
 329:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_USIC1  = (SCU_RESET_PRSTAT1_USIC1RS_Msk | 0x10000000UL),    /**< USIC1 r
 330:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 331:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USIC2)
 332:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_USIC2  = (SCU_RESET_PRSTAT1_USIC2RS_Msk | 0x10000000UL),    /**< USIC2 r
 333:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 334:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_PORTS  = (SCU_RESET_PRSTAT1_PPORTSRS_Msk | 0x10000000UL),   /**< PORTS r
 335:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_WDT    = (SCU_RESET_PRSTAT2_WDTRS_Msk | 0x20000000UL),      /**< WDT res
 336:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ETH0)
 337:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_ETH0   = (SCU_RESET_PRSTAT2_ETH0RS_Msk | 0x20000000UL),     /**< ETH0 re
 338:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 339:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_GPDMA0 = (SCU_RESET_PRSTAT2_DMA0RS_Msk | 0x20000000UL),     /**< DMA0 re
 340:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(GPDMA1)
 341:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_GPDMA1 = (SCU_RESET_PRSTAT2_DMA1RS_Msk | 0x20000000UL),     /**< DMA1 re
 342:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 343:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(FCE)
 344:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_FCE    = (SCU_RESET_PRSTAT2_FCERS_Msk | 0x20000000UL),      /**< FCE res
 345:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 346:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USB0)  
 347:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_USB0   = (SCU_RESET_PRSTAT2_USBRS_Msk | 0x20000000UL),      /**< USB0 re
 348:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 349:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ECAT0)  
 350:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_ECAT0  = (SCU_RESET_PRSTAT2_ECAT0RS_Msk | 0x20000000UL),      /**< ECAT0
 351:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 352:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(EBU)
 353:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_EBU    = (SCU_RESET_PRSTAT3_EBURS_Msk | 0x30000000UL)       /**< EBU res
 354:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 355:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_PERIPHERAL_RESET_t;
 356:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 357:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 358:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines enumerations for disabling the clocks sources of peripherals. Disabling of the peripher
 359:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  clock is configured via the \a CLKCLR registers.
 360:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_PERIPHERAL_CLOCK_t for accessing these enum parameters.
 361:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 362:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK
 363:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 364:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_USB = SCU_CLK_CLKCLR_USBCDI_Msk, /**< USB module clock. */
 365:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SDMMC)
 366:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_MMC = SCU_CLK_CLKCLR_MMCCDI_Msk, /**< MMC module clock. */
 367:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 368:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ETH0)
 369:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_ETH = SCU_CLK_CLKCLR_ETH0CDI_Msk, /**< Ethernet module clock. */
 370:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 371:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(EBU)
 372:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_EBU = SCU_CLK_CLKCLR_EBUCDI_Msk, /**< EBU module clock. */
 373:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 374:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_CCU = SCU_CLK_CLKCLR_CCUCDI_Msk, /**< CCU module clock. */
 375:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_WDT = SCU_CLK_CLKCLR_WDTCDI_Msk  /**< WDT module clock. */
 376:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_t;
 377:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 378:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if(UC_SERIES != XMC45)
 379:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 380:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Defines enumeration for peripherals that support clock gating. 
 381:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The enumerations can be used for gating or ungating the peripheral clocks.
 382:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * All the enum items are tabulated as per bits present in \a CGATSTAT0 register.
 383:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Use type \a XMC_SCU_PERIPHERAL_CLOCK_t for accessing these enum parameters.
 384:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 385:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_PERIPHERAL_CLOCK
 386:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 387:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_VADC   = SCU_CLK_CGATSTAT0_VADC_Msk,  /**< VADC peripheral gating. */
 388:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(DSD)
 389:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_DSD    = SCU_CLK_CGATSTAT0_DSD_Msk,   /**< DSD peripheral gating. */
 390:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 391:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_CCU40  = SCU_CLK_CGATSTAT0_CCU40_Msk,  /**< CCU40 peripheral gating. */
 392:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU41)
 393:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_CCU41  = SCU_CLK_CGATSTAT0_CCU41_Msk,  /**< CCU41 peripheral gating. */
 394:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 395:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU42)
 396:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_CCU42  = SCU_CLK_CGATSTAT0_CCU42_Msk,  /**< CCU42 peripheral gating. */
 397:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 398:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU80)
 399:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_CCU80  = SCU_CLK_CGATSTAT0_CCU80_Msk,  /**< CCU80 peripheral gating. */
 400:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 401:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU81)
 402:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_CCU81  = SCU_CLK_CGATSTAT0_CCU81_Msk,  /**< CCU81 peripheral gating. */
 403:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 404:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(POSIF0)
 405:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_POSIF0 = SCU_CLK_CGATSTAT0_POSIF0_Msk,  /**< POSIF0 peripheral gating. *
 406:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 407:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(POSIF1)
 408:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_POSIF1 = SCU_CLK_CGATSTAT0_POSIF1_Msk,   /**< POSIF1 peripheral gating. 
 409:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 410:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_USIC0  = SCU_CLK_CGATSTAT0_USIC0_Msk,   /**< USIC0 peripheral gating. */
 411:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_ERU1   = SCU_CLK_CGATSTAT0_ERU1_Msk,    /**< ERU1 peripheral gating. */
 412:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(HRPWM0)
 413:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_HRPWM0 = SCU_CLK_CGATSTAT0_HRPWM0_Msk,  /**< HRPWM0 peripheral gating. *
 414:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 415:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU43)
 416:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_CCU43  = (SCU_CLK_CGATSTAT1_CCU43_Msk | 0x10000000UL),   /**< CCU43 peri
 417:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 418:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(LEDTS0)
 419:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_LEDTS0 = (SCU_CLK_CGATSTAT1_LEDTSCU0_Msk | 0x10000000UL), /**< LEDTS0 pe
 420:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 421:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CAN)
 422:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_MCAN   = (SCU_CLK_CGATSTAT1_MCAN0_Msk | 0x10000000UL),   /**< MCAN perip
 423:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 424:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(DAC)  
 425:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_DAC    = (SCU_CLK_CGATSTAT1_DAC_Msk | 0x10000000UL),     /**< DAC periph
 426:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 427:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SDMMC)
 428:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_SDMMC  = (SCU_CLK_CGATSTAT1_MMCI_Msk | 0x10000000UL),    /**< SDMMC peri
 429:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 430:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USIC1)
 431:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_USIC1  = (SCU_CLK_CGATSTAT1_USIC1_Msk | 0x10000000UL),   /**< USIC1 peri
 432:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 433:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USIC2)
 434:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_USIC2  = (SCU_CLK_CGATSTAT1_USIC2_Msk | 0x10000000UL),    /**< USIC2 per
 435:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 436:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_PORTS  = (SCU_CLK_CGATSTAT1_PPORTS_Msk | 0x10000000UL),   /**< PORTS per
 437:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_WDT    = (SCU_CLK_CGATSTAT2_WDT_Msk | 0x20000000UL),      /**< WDT perip
 438:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ETH0)
 439:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_ETH0   = (SCU_CLK_CGATSTAT2_ETH0_Msk | 0x20000000UL),     /**< ETH0 peri
 440:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 441:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_GPDMA0 = (SCU_CLK_CGATSTAT2_DMA0_Msk | 0x20000000UL),     /**< DMA0 peri
 442:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(GPDMA1)
 443:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_GPDMA1 = (SCU_CLK_CGATSTAT2_DMA1_Msk | 0x20000000UL),     /**< DMA1 peri
 444:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 445:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(FCE)
 446:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_FCE    = (SCU_CLK_CGATSTAT2_FCE_Msk | 0x20000000UL),      /**< FCE perip
 447:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 448:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USB0)
 449:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_USB0   = (SCU_CLK_CGATSTAT2_USB_Msk | 0x20000000UL),      /**< USB0 peri
 450:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 451:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ECAT0)
 452:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_ECAT0   = (SCU_CLK_CGATSTAT2_ECAT0_Msk | 0x20000000UL),      /**< ECAT0 
 453:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 454:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(EBU)
 455:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_EBU    = (SCU_CLK_CGATSTAT3_EBU_Msk | 0x30000000UL)       /**< EBU perip
 456:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 457:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_PERIPHERAL_CLOCK_t;
 458:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 459:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 460:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 461:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for system clock (fSYS) source. These enums are used to configure \a SYSSEL bit
 462:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Clock Control Register. 
 463:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_CLOCK_SYSCLKSRC_t for accessing these enum parameters.
 464:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */ 
 465:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_SYSCLKSRC
 466:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 467:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSCLKSRC_OFI = (0UL << SCU_CLK_SYSCLKCR_SYSSEL_Pos), /**< Internal Fast Clock (fOF
 468:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for system clock 
 469:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSCLKSRC_PLL = (1UL << SCU_CLK_SYSCLKCR_SYSSEL_Pos)  /**< PLL output (fPLL) as a
 470:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for system clock 
 471:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_SYSCLKSRC_t;
 472:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 473:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 474:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for selecting the P-Divider input frequency. These enums are used to configure 
 475:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  register. 
 476:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_CLOCK_OSCCLKSRC_t for accessing these enum parameters.
 477:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */ 
 478:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_SYSPLLCLKSRC
 479:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 480:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP = 0UL,  /**< External crystal oscillator
 481:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                 (fOHP) as the source for P-Divider. */
 482:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLLCLKSRC_OFI = SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk /**< Ba
 483:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                              as the source for P-Di
 484:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_SYSPLLCLKSRC_t;
 485:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 486:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 487:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Defines options for selecting the USB clock source(fUSB/fSDMMC).
 488:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * These enums are used to configure \a USBSEL bits of \a USBCLKCR
 489:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * register. User can choose either fPLL or fUSBPLL clock as a source for USB clock. 
 490:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Use type \a XMC_SCU_CLOCK_USBCLKSRC_t for accessing these enum parameters.
 491:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */ 
 492:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_USBCLKSRC
 493:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 494:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_USBCLKSRC_USBPLL = (0UL << SCU_CLK_USBCLKCR_USBSEL_Pos), /**< USB PLL(fUSB PLL) as 
 495:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for USB clock (fU
 496:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_USBCLKSRC_SYSPLL = (1UL << SCU_CLK_USBCLKCR_USBSEL_Pos)  /**< Main PLL output (fPLL
 497:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for USB clock (fU
 498:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_USBCLKSRC_t;
 499:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 500:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ECAT0) 
 501:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 502:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Defines options for selecting the ECAT clock source.
 503:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */ 
 504:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_ECATCLKSRC
 505:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 506:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_ECATCLKSRC_USBPLL = (0UL << SCU_CLK_ECATCLKCR_ECATSEL_Pos), /**< USB PLL (fUSBPLL) 
 507:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_ECATCLKSRC_SYSPLL = (1UL << SCU_CLK_ECATCLKCR_ECATSEL_Pos)  /**< Main PLL output (f
 508:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_ECATCLKSRC_t;
 509:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 510:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 511:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 512:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for selecting the source of WDT clock(fWDT). These enums are used to configure 
 513:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  register. User can choose either fOFI or fPLL or fSTDBY clock as a source for WDT clock. 
 514:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_CLOCK_USBCLKSRC_t for accessing these enum parameters.
 515:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */ 
 516:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_WDTCLKSRC
 517:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 518:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_WDTCLKSRC_OFI = (0UL << SCU_CLK_WDTCLKCR_WDTSEL_Pos),  /**< Internal Fast Clock 
 519:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            (fOFI) as the source for
 520:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_WDTCLKSRC_STDBY = (1UL << SCU_CLK_WDTCLKCR_WDTSEL_Pos), /**< Standby clock 
 521:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            (fSTDBY) as the source f
 522:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_WDTCLKSRC_PLL = (2UL << SCU_CLK_WDTCLKCR_WDTSEL_Pos)   /**< PLL output (fPLL) as th
 523:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for WDT clock (fW
 524:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_WDTCLKSRC_t;
 525:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 526:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 527:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for selecting the source of external clock out (fEXT). These enums are used to 
 528:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  register. User can choose either fSYS or fPLL or fUSBPLL clock as a source for external clock o
 529:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_CLOCK_EXTOUTCLKSRC_t for accessing these enum parameters.
 530:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */ 
 531:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_EXTOUTCLKSRC
 532:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 533:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_EXTOUTCLKSRC_SYS = (0UL << SCU_CLK_EXTCLKCR_ECKSEL_Pos),  /**< System clock (fSYS) 
 534:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                             the source for external
 535:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_EXTOUTCLKSRC_USB = (2UL << SCU_CLK_EXTCLKCR_ECKSEL_Pos), /**< USB PLL output(fUSB P
 536:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for external cloc
 537:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_EXTOUTCLKSRC_PLL = (3UL << SCU_CLK_EXTCLKCR_ECKSEL_Pos), /**< Main PLL output(fPLL)
 538:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for external cloc
 539:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if ((UC_SERIES == XMC42) || (UC_SERIES == XMC41))
 540:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_EXTOUTCLKSRC_STDBY = (4UL << SCU_CLK_EXTCLKCR_ECKSEL_Pos), /**< Standby clock(fSTDB
 541:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for external cloc
 542:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 543:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_EXTOUTCLKSRC_t;
 544:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 545:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 546:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for selecting the source of RTC Clock (fRTC). These enums are used to configure
 547:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  User can choose either fOSI or fULP clock as a source for RTC Clock (fRTC).
 548:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_HIB_RTCCLKSRC_t for accessing these enum parameters.
 549:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 550:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_HIB_RTCCLKSRC
 551:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 552:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_HIB_RTCCLKSRC_OSI = (0UL << SCU_HIBERNATE_HDCR_RCS_Pos), /**< Internal Slow Clock
 553:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                          (fOSI) as the source for R
 554:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_HIB_RTCCLKSRC_ULP = (1UL << SCU_HIBERNATE_HDCR_RCS_Pos) /**< Ultra Low Power Clock (fULP)
 555:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                         as the source for RTC Clock
 556:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_HIB_RTCCLKSRC_t;
 557:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 558:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 559:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for selecting the source of Standby Clock (fSTDBY). These enums are used to con
 560:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  register. User can choose either fOSI or fULP clock as a source for Standby Clock (fSTDBY).
 561:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_HIB_STDBYCLKSRC_t for accessing these enum parameters.
 562:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 563:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_HIB_STDBYCLKSRC
 564:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 565:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_HIB_STDBYCLKSRC_OSI = (0UL << SCU_HIBERNATE_HDCR_STDBYSEL_Pos), /**< Internal Slow Clock 
 566:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                           (fOSI) as the source for 
 567:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                           (fSTDBY). */
 568:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_HIB_STDBYCLKSRC_OSCULP = (1UL << SCU_HIBERNATE_HDCR_STDBYSEL_Pos) /**< Ultra Low Power Cl
 569:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                           (fULP) as the source for 
 570:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                           (fSTDBY). */
 571:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_HIB_STDBYCLKSRC_t;
 572:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 573:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 574:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for backup clock trimming. These enums are used to configure \a AOTREN  \a FOTR
 575:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  PLLCON0 register. Use type \a XMC_SCU_CLOCK_BACKUP_TRIM_t for accessing these enum parameters.
 576:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 577:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE
 578:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 579:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_FACTORY   = 0UL,  /**< Factory Oscillator Calibration: 
 580:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                         Force adjustment of the internal oscillator
 581:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC = 1UL   /**<  Automatic Oscillator Calibration adju
 582:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t;
 583:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 584:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 585:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 586:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for selecting device boot mode. These enums are used to configure \a SWCON bits
 587:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  User can choose among various boot modes by configuring SWCON bits.
 588:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_BOOTMODE_t for accessing these enum parameters.
 589:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 590:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_BOOTMODE 
 591:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 592:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_NORMAL     = (0UL << SCU_GENERAL_STCON_SWCON_Pos), /**< Boot from start of flash
 593:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_ASC_BSL    = (1UL << SCU_GENERAL_STCON_SWCON_Pos), /**< UART bootstrap. */
 594:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_BMI        = (2UL << SCU_GENERAL_STCON_SWCON_Pos), /**< Boot Mode Index - Custom
 595:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            sequence. */
 596:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_CAN_BSL    = (3UL << SCU_GENERAL_STCON_SWCON_Pos), /**< CAN bootstrap. */
 597:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_PSRAM_BOOT = (4UL << SCU_GENERAL_STCON_SWCON_Pos), /**< Boot from PSRAM. */
 598:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_ABM0       = (8UL << SCU_GENERAL_STCON_SWCON_Pos), /**< Boot from flash - fixed 
 599:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            address 0. */
 600:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_ABM1       = (12UL << SCU_GENERAL_STCON_SWCON_Pos), /**< Boot from flash - fixed
 601:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                             address 1. */
 602:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_FABM       = (14UL << SCU_GENERAL_STCON_SWCON_Pos), /**< fallback Alternate Boot
 603:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                             Try ABM-0 then try ABM-
 604:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_BOOTMODE_t;
 605:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 606:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 607:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 608:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines various PLL modes of operation. These enums are used to configure \a VCOBYP bit of \a P
 609:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  User can choose either normal or prescalar mode by configuring VCOBYP bit.
 610:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_PLL_MODE_t for accessing these enum parameters.
 611:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 612:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_SYSPLL_MODE
 613:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 614:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLL_MODE_DISABLED, /**< fPLL derived from fOSC and PLL operating in prescalar mo
 615:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL,  /**< fPLL derived from fVCO and PLL operating in normal mode. 
 616:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLL_MODE_PRESCALAR /**< fPLL derived from fOSC and PLL operating in prescalar mo
 617:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_SYSPLL_MODE_t;
 618:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 619:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 620:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 621:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 622:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_SLEEP_MODE_CONFIG
 623:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 624:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_SYSCLK_FOFI = 0,  //!< XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_SYSCLK_FOF
 625:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_SYSCLK_FPLL = SCU_CLK_SLEEPCR_SYSSEL_Msk,  //!< XMC_SCU_CLOCK_SLE
 626:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USB0)
 627:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_USB = SCU_CLK_SLEEPCR_USBCR_Msk,  //!< XMC_SCU_CLOCK_SLEE
 628:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 629:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SDMMC)
 630:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_SDMMC = SCU_CLK_SLEEPCR_MMCCR_Msk,//!< XMC_SCU_CLOCK_SLEE
 631:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 632:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ETH0)
 633:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_ETH = SCU_CLK_SLEEPCR_ETH0CR_Msk,  //!< XMC_SCU_CLOCK_SLE
 634:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 635:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(EBU)
 636:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_EBU = SCU_CLK_SLEEPCR_EBUCR_Msk,  //!< XMC_SCU_CLOCK_SLEE
 637:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 638:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_CCU = SCU_CLK_SLEEPCR_CCUCR_Msk,  //!< XMC_SCU_CLOCK_SLEE
 639:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_WDT = SCU_CLK_SLEEPCR_WDTCR_Msk,  //!< XMC_SCU_CLOCK_SLEE
 640:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_t;
 641:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 642:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 643:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 644:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 645:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG
 646:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 647:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_SYSCLK_FOFI = 0,  //!< XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_SY
 648:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_SYSCLK_FPLL = SCU_CLK_SLEEPCR_SYSSEL_Msk,  //!< XMC_SCU_CLOCK
 649:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_FLASH_POWERDOWN = SCU_CLK_DSLEEPCR_FPDN_Msk,//!< XMC_SCU_CLOC
 650:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_PLL_POWERDOWN = SCU_CLK_DSLEEPCR_PLLPDN_Msk,  //!< XMC_SCU_CL
 651:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_VCO_POWERDOWN = SCU_CLK_DSLEEPCR_VCOPDN_Msk,  //!< XMC_SCU_CL
 652:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USB0)
 653:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_USB = SCU_CLK_SLEEPCR_USBCR_Msk,  //!< XMC_SCU_CLOCK_
 654:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 655:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SDMMC)
 656:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_SDMMC = SCU_CLK_SLEEPCR_MMCCR_Msk,//!< XMC_SCU_CLOCK_
 657:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 658:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ETH0)
 659:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_ETH = SCU_CLK_SLEEPCR_ETH0CR_Msk,  //!< XMC_SCU_CLOCK
 660:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 661:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(EBU)
 662:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_EBU = SCU_CLK_SLEEPCR_EBUCR_Msk,  //!< XMC_SCU_CLOCK_
 663:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 664:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_CCU = SCU_CLK_SLEEPCR_CCUCR_Msk,  //!< XMC_SCU_CLOCK_
 665:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_WDT = SCU_CLK_SLEEPCR_WDTCR_Msk,  //!< XMC_SCU_CLOCK_
 666:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_t;
 667:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 668:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 669:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**************************************************************************************************
 670:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * DATA STRUCTURES
 671:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  **************************************************************************************************
 672:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 673:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 674:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines a data structure for initializing the PLL functional block.
 675:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Structure holds divider values for N-DIV, P-DIV, K1-DIV, K2-DIV in order to generate desired 
 676:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  frequency using VCO. It holds the PLL mode of operation either normal or prescaler (VCO bypasse
 677:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_CLOCK_PLL_CONFIG_t for accessing these structure parameters.
 678:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 679:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef struct XMC_SCU_CLOCK_SYSPLL_CONFIG
 680:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 681:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   uint8_t n_div;                       /**<  PLL N-Divider value. */
 682:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   uint8_t p_div;                       /**<  PLL P-Divider value. */
 683:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   uint8_t k_div;                       /**<  K1-Divider(Prescalar mode) or K2-Divider (Normal mode)
 684:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLL_MODE_t mode;    /**<  PLL mode of operation. */
 685:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLLCLKSRC_t clksrc; /**<  PLL divider input frequency. */
 686:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_SYSPLL_CONFIG_t;
 687:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 688:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 689:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines a data structure used for initializing the clock functional block.
 690:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Clock functional block configures clock source needed for various peripheral and its divider va
 691:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_CLOCK_CONFIG_t for accessing these structure parameters.
 692:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 693:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef struct XMC_SCU_CLOCK_CONFIG
 694:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 695:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLL_CONFIG_t         syspll_config;      /**< PLL configuration */
 696:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   bool                                  enable_oschp;       /**< Enable external high precision osc
 697:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  Should be enabled when fOHP has to
 698:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   bool                                  enable_osculp;      /**< Enable external ultra low power os
 699:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  Should be enabled when fULP has to
 700:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t calibration_mode;   /**< Backup clock trimming mode. */
 701:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_HIB_STDBYCLKSRC_t             fstdby_clksrc;      /**< Standby clock source. */
 702:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSCLKSRC_t             fsys_clksrc;        /**< Choice of system clock. */
 703:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   uint8_t                               fsys_clkdiv;        /**< Ratio of fPLL to fSYS. */
 704:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   uint8_t                               fcpu_clkdiv;        /**< Ratio of fSys to fCPU. */
 705:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   uint8_t                               fccu_clkdiv;        /**< Ratio of fSys to fCCU. */
 706:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   uint8_t                               fperipheral_clkdiv; /**< Ratio of fSYS to fPERI. */
 707:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } const XMC_SCU_CLOCK_CONFIG_t;
 708:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 709:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 710:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**************************************************************************************************
 711:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * API PROTOTYPES
 712:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  **************************************************************************************************
 713:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 714:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #ifdef __cplusplus
 715:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** extern "C" {
 716:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 717:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 718:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 719:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * 
 720:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param group   ADC Group to which the channel being monitored belongs to.\n
 721:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                 \b Range: 0 or 1.
 722:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param channel  The channel whose voltage range has to be monitored.\n
 723:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                 \b Range: 6 or 7. Value identifies the channel in the selected ADC group.
 724:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 725:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
 726:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 727:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 728:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables out of range comparator for the selected ADC group and channel. \n\n
 729:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The ADC channel input is compared by Out of Range Comparator (ORC) for overvoltage monitoring
 730:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * or for detection of out of range analog inputs. ORC must be turned on explicitly
 731:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * to leverage the auditing feature. ORC is enabled by setting the enable bit in the GORCEN registe
 732:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 733:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_DisableOutOfRangeComparator()\n\n\n
 734:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 735:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_EnableOutOfRangeComparator(const uint32_t group, const uint32_t channel);
 736:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 737:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 738:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * 
 739:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param group   ADC Group to which the channel being monitored belongs to.\n
 740:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                 \b Range: 0 or 1.
 741:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param channel  The channel whose voltage range has to be monitored.\n
 742:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                 \b Range: 6 or 7. Value identifies the channel in the selected ADC group.
 743:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 744:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
 745:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 746:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 747:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables the out of range comparator for the selected ADC group and the channel. \n\n
 748:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Out of range comparator is disabled by clearing the enable bit in the GORCEN register.
 749:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 750:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_EnableOutOfRangeComparator()\n\n\n
 751:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 752:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_DisableOutOfRangeComparator(const uint32_t group, const uint32_t channel);
 753:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 754:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 755:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
 756:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 757:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 758:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables die temperature measurement by powering the DTS module.\n\n
 759:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Die temperature sensor is enabled by setting the PWD bit of DTSCON register.
 760:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 761:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_DisableTemperatureSensor(), XMC_SCU_IsTemperatureSensorEnabled(), XMC_SCU_CalibrateTempe
 762:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_StartTemperatureMeasurement(), XMC_SCU_GetTemperatureMeasurement() \n\n\n
 763:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 764:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_EnableTemperatureSensor(void);
 765:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 766:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 767:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
 768:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 769:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 770:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables die temperature measurement by powering the DTS module off.\n\n
 771:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Die temperature sensor is disabled by clearing the PWD bit of DTSCON register.
 772:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 773:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_EnableTemperatureSensor(), XMC_SCU_IsTemperatureSensorEnabled(), XMC_SCU_CalibrateTemper
 774:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_StartTemperatureMeasurement(), XMC_SCU_GetTemperatureMeasurement() \n\n\n
 775:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 776:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_DisableTemperatureSensor(void);
 777:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 778:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 779:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return Status of die temperature sensor. \n
 780:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: true - if temperature sensor is enabled.\n
 781:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    false - if temperature sensor is disabled.
 782:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 783:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 784:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the die temperature sensor power status.\n\n
 785:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The status is obtained by reading the PWD bit of DTSCON register.
 786:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 787:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_EnableTemperatureSensor(), XMC_SCU_CalibrateTemperatureSensor(),
 788:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_StartTemperatureMeasurement(), XMC_SCU_GetTemperatureMeasurement() \n\n\n
 789:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 790:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** bool XMC_SCU_IsTemperatureSensorEnabled(void);
 791:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 792:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 793:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 794:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param offset  Offset value for calibrating the DTS result.\n
 795:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                \b Range: 0 to 127.
 796:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param gain    Gain value for calibrating the DTS conversion result.\n
 797:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                \b Range: 0 to 63.
 798:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 799:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
 800:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 801:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 802:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Calibrates the measurement of temperature by configuring the values of offset and gain of \a DTS
 803:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Allows to improve the accuracy of the temperature measurement with the adjustment of \a OFFSET a
 804:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * in the \a DTSCON register.
 805:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Offset adjustment is defined as a shift of the conversion result. The range of the offset adjust
 806:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * resolution that corresponds to +/- 12.5C. The offset value gets added to the measure result. 
 807:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Offset is considered as a signed value.
 808:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Gain adjustment helps in minimizing gain error. When the \a gain value is 0, result is generated
 809:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * When the \a gain value is 63, result is generated with least gain, i.e, \a RESULT - 63 at the hi
 810:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps:\n
 811:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_StopTempMeasurement to stop temperature measurement if it was started previous
 812:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_CalibrateTempMonitor with desired offset and gain calibration values to the DT
 813:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_SetRawTempLimits with desired lower and upper temperature threshold limit valu
 814:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_StartTempMeasurement to start temperature measurement.\n
 815:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Check whether Die Temperature Sensor (DTS) is busy in conversion by calling \a XMC_SCU_IsTempe
 816:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * conversion complete.\n
 817:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Read the die temperature value using \a XMC_SCU_GetTemperatureMeasurement API.
 818:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 819:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_EnableTemperatureSensor(),
 820:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_StartTemperatureMeasurement(), XMC_SCU_GetTemperatureMeasurement() \n\n\n
 821:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 822:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CalibrateTemperatureSensor(uint32_t offset, uint32_t gain);
 823:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 824:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 825:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_STATUS_t  Result of starting the temperature measurement.\n
 826:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                           \b Range: \n 
 827:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                              XMC_SCU_STATUS_OK if the measurement is started successfully.\n
 828:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                              XMC_SCU_STATUS_ERROR if temperature sensor is not enabled.\n
 829:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                              XMC_SCU_STATUS_BUSY if temperature sensor is busy measuring the tem
 830:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 831:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 832:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 833:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Starts die temperature measurement using internal temperature sensor.\n\n
 834:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API checks if the temperature sensor is enabled and is not busy in measurement.\n
 835:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps:\n
 836:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_StopTempMeasurement to stop temperature measurement if it was started previous
 837:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_SetRawTempLimits with desired lower and upper temperature threshold limit valu
 838:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_StartTempMeasurement to start temperature measurement.\n
 839:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Check whether Die Temperature Sensor (DTS) is busy in conversion by calling \a XMC_SCU_IsTempe
 840:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * conversion complete.\n
 841:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Read the die temperature value using \a XMC_SCU_GetTemperatureMeasurement API.
 842:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 843:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_EnableTemperatureSensor(), XMC_SCU_CalibrateTemperatureSensor(),
 844:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_GetTemperatureMeasurement() \n\n\n
 845:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 846:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** XMC_SCU_STATUS_t XMC_SCU_StartTemperatureMeasurement(void);
 847:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 848:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 849:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 850:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 851:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Measured temperature value.\n
 852:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: Valid temperature range is 0 to 1023. \n
 853:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              If sensor is not enabled, 0x7FFFFFFFH is returned.
 854:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 855:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 856:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Reads the measured value of die temperature.\n\n
 857:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Temperature measurement result is read from \a RESULT bit field of \a DTSSTAT register.
 858:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The temperature measured in C is given by (RESULT - 605) / 2.05 [C]
 859:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 860:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_IsTemperatureSensorBusy() \n\n\n
 861:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 862:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_GetTemperatureMeasurement(void);
 863:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 864:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 865:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return bool  Indicates if the die temperature sensor is busy.\n
 866:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    \b Range: \a true if sensor is busy in temperature measurement.
 867:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    \a false if sensor is free and can accept a new request for measurement.
 868:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 869:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 870:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Checks whether Die Temperature Sensor (DTS) is busy in temperature measurement.\n\n
 871:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The status is read from the \a BUSY bit field of the \a DTSSTAT register.
 872:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 873:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_GetTemperatureMeasurement() \n\n\n
 874:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 875:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** bool XMC_SCU_IsTemperatureSensorBusy(void);
 876:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 877:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 878:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return bool Status of die temperature sensor whether it is ready to start measurement. \n
 879:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: \n \a true if temperature sensor is ready to start measurement. \n
 880:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \a false if temperature sensor is not ready to start measurement.
 881:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 882:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 883:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Checks if the die temperature sensor is ready to start a measurement\n\n
 884:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The status is obtained by reading \a RDY bit of \a DTSSTAT register. It is recommended
 885:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * to check the ready status of die temperature sensor before starting it.
 886:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 887:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_StartTemperatureMeasurement(), XMC_SCU_IsTemperatureSensorBusy() \n\n\n
 888:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 889:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** bool XMC_SCU_IsTemperatureSensorReady(void);
 890:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 891:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if (UC_SERIES != XMC45)
 892:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 893:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return bool  Indicates if the measured die temperature value has exceeded the configured upper 
 894:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: \a true if the temperature value has exceeded the configured upper limit.
 895:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              if the temperature value is less than the configured upper limit.
 896:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 897:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 898:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Checks if the measured temperature has exceeded the configured upper limit of temperature.\n\n
 899:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API checks \a OVERFL bit (Upper Limit Overflow Status bit) of \a DTEMPALARM register.
 900:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The \a OVERFL bit will be set if the measured temperature has exceeded the limit configured in 
 901:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the bitfield \a UPPER in the \a DTEMPLIM register.
 902:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 903:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_SetRawTempLimits(),XMC_SCU_LowTemperature() \n\n\n
 904:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 905:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** bool XMC_SCU_HighTemperature(void);
 906:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 907:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 908:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 909:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param lower_temp  Lower threshold of die temperature. If measured temperature falls below this 
 910:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    alarm bit will be set in \a UNDERFL bit field of \a DTEMPALARM register.
 911:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param upper_temp  Upper threshold of die temperature. If measured temperature exceeds this valu
 912:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    alarm bit will be set in \a OVERFL bit field of \a DTEMPALARM register.
 913:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 914:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
 915:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 916:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 917:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the lower and upper threshold of die temperature.\n\n
 918:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * API configures \a DTEMPLIM register for upper and lower die temperature threshold limits.
 919:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * When the measured temperature is outside the range defined by the limits, alarm bits \a UNDERFL 
 920:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * will be set in the register \a DTEMPALARM.\n
 921:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps:\n
 922:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_StopTempMeasurement to stop temperature measurement if it was started previous
 923:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_SetRawTempLimits with desired lower and upper temperature threshold limit valu
 924:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_StartTempMeasurement to start temperature measurement.\n
 925:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Use \a XMC_SCU_HighTemperature() and XMC_SCU_LowTemperature() to monitor the temperature.\n
 926:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 927:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_HighTemperature(), XMC_SCU_LowTemperature() \n\n\n
 928:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 929:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_SetRawTempLimits(const uint32_t lower_temp, const uint32_t upper_temp);
 930:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 931:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 932:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return bool  Indicates if the measured die temperature value has dropped below the configured l
 933:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: \a true if the temperature value has dropped below the configured lower l
 934:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              if the temperature value is higher than the configured lower limit.
 935:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 936:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 937:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Checks if the measured temperature has dropped below the configured lower limit of temperature.\
 938:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API checks \a UNDERFL bit (Lower LimitUnderflow Status bit) of \a DTEMPALARM register.
 939:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The \a UNDERFL bit will be set if the measured temperature has dropped below the limit configure
 940:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the bitfield \a LOWER in the \a DTEMPLIM register.
 941:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 942:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_SetRawTempLimits(),XMC_SCU_HighTemperature() \n\n\n
 943:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 944:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** bool XMC_SCU_LowTemperature(void);
 945:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 946:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 947:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 948:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t Configured boot mode for the device.\n
 949:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_BOOTMODE_t for enumeration of different boot modes.
 950:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 951:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 952:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the boot mode configured for the device.\n\n
 953:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The boot mode is read from the \a STCON register bit field \a SWCON.
 954:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 955:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 956:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_SetBootMode() \n\n\n
 957:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 958:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_GetBootMode(void);
 959:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 960:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 961:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 962:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param mode Boot mode to be configured for the device.\n
 963:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_BOOTMODE_t for selecting the boot mode.
 964:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 965:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
 966:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 967:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 968:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the desired boot mode for the device.\n\n
 969:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The XMC4 series devices support multiple boot modes. A running application can set a desired boo
 970:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * launch it by means of software reset. Switching of boot modes should be handled carefully. User 
 971:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the initial boot sequence is executed. A stable execution environment should be maintained when 
 972:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * eventually handed over to the application program.\n
 973:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps to launch requested bootmode:\n
 974:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_SetBootMode() with desired boot mode value.\n
 975:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Trigger a software reset using system reset request by enabling a bit \a SYSRESETREQ of AIRCR 
 976:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *   (PPB->AIRCR |= PPB_AIRCR_SYSRESETREQ_Msk).\n
 977:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 978:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_GetBootMode() \n\n\n
 979:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 980:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_SetBootMode(const XMC_SCU_BOOTMODE_t mode);
 981:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 982:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 983:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 984:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param index  The SCU general purpose register to be read.\n
 985:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: 0 and 1 corresponding to GPR0 and GPR1.
 986:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 987:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Data read from the selected general purpose register.
 988:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 989:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 990:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides stored data from general purpose SCU register.\n\n
 991:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * SCU consists of 2 general purpose registers. These registers can be used for storing
 992:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * data. The API reads from either GPR0 or GPR1 based on the \a index value.
 993:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 994:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_WriteGPR()\n\n\n
 995:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 996:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_ReadGPR(const uint32_t index);
 997:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  
 998:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 999:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1000:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param index  The SCU general purpose register to be written.\n
1001:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: 0 and 1 corresponding to GPR0 and GPR1.
1002:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param data  Data to be written to the selected general purpose register.
1003:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1004:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1005:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1006:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1007:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Stores data in the selected general purpose SCU register.\n\n
1008:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * SCU consists of 2 general purpose registers. These registers can be used for storing
1009:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * data. The API writes data to either GPR0 or GPR1 based on the \a index value.
1010:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1011:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_ReadGPR()\n\n\n
1012:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1013:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_WriteGPR(const uint32_t index, const uint32_t data);
1014:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1015:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1016:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1017:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param address  Location in the retention memory to be written.\n
1018:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: 4 bit address space is provided for selecting 16 words of 32 bits.
1019:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  equivalent to 64 bytes of data. \a address value should be from
1020:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  0 to 15.
1021:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param data    32 bit data to be written into retention memory. The API writes
1022:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                one word(4 bytes) of data to the address specified.\n
1023:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                \b Range: 32 bit data.
1024:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1025:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1026:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1027:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1028:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Writes input data to the selected address of Retention memory in hibernate domain.\n\n
1029:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The retention memory is located in hibernate domain. 
1030:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is used for the purpose of store/restore of context information.
1031:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Access to the retention memory space is served over shared serial interface. 
1032:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Retention memory content is retained even in hibernate mode.
1033:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1034:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_ReadFromRetentionMemory() \n\n\n
1035:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1036:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_WriteToRetentionMemory(uint32_t address, uint32_t data);
1037:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1038:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1039:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1040:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param address  Location in the retention memory to be read.\n
1041:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: 4 bit address space is provided for selecting 16 words of 32 bits.
1042:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  equivalent to 64 bytes of data. \a address value should be from
1043:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  0 to 15.
1044:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1045:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  32 bit data read from retention memory. The API reads
1046:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                one word(4 bytes) of data from the address specified.\n
1047:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                \b Range: 32 bit data.
1048:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1049:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1050:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Reads data from selected address of retention memory in hibernate domain.\n\n
1051:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The retention memory is located in hibernate domain. 
1052:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is used for the purpose of store/restore of context information.
1053:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Access to the retention memory space is served over shared serial interface. 
1054:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Retention memory content is retained even in hibernate mode.
1055:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1056:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_WriteToRetentionMemory() \n\n\n
1057:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1058:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_ReadFromRetentionMemory(uint32_t address);
1059:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1060:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1061:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1062:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param request  Non-maskable interrupt (NMI) request source to be enabled.\n
1063:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: Use type @ref XMC_SCU_NMIREQ_t for selecting the source of NMI. Multiple 
1064:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              sources can be combined using \a OR operation.
1065:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1066:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1067:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1068:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1069:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selectively enables interrupt sources to generate non maskable interrupt(NMI).\n\n
1070:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * NMI assertion can be individually enabled by setting corresponding bit of an interrupt in the 
1071:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \a NMIREQEN register.
1072:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1073:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_INTERRUPT_DisableNmiRequest() \n\n\n
1074:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1075:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_INTERRUPT_EnableNmiRequest(const uint32_t request);
1076:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1077:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1078:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1079:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param request  Non-maskable interrupt (NMI) request source to be disabled.\n
1080:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: Use type @ref XMC_SCU_NMIREQ_t for selecting the source of NMI. Multiple 
1081:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              sources can be combined using \a OR operation.
1082:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1083:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1084:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1085:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1086:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selectively disables interrupt sources from generating non maskable interrupt(NMI).\n\n
1087:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * NMI assertion can be individually disabled by clearing corresponding bits in the \a NMIREQEN reg
1088:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1089:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_INTERRUPT_EnableNmiRequest() \n\n\n
1090:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1091:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_INTERRUPT_DisableNmiRequest(const uint32_t request);
1092:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1093:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1094:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1095:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param trap  The event for which, trap generation has to be enabled.\n
1096:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_TRAP_t to identify the event.
1097:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1098:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1099:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1100:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1101:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables assertion of trap for the selected trap event.\n\n
1102:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Trap assertion can be individually enabled by clearing respective bit of the 
1103:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * event in \a TRAPDIS register in order to get an exception.
1104:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1105:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_TRAP_Disable(), XMC_SCU_TRAP_ClearStatus(), XMC_SCU_TRAP_GetStatus() \n\n\n
1106:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1107:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_TRAP_Enable(const uint32_t trap);
1108:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1109:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1110:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1111:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param trap  The event for which, trap generation has to be disabled.\n
1112:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_TRAP_t to identify the event.
1113:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1114:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1115:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1116:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1117:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables assertion of trap for the selected trap event.\n\n
1118:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Trap assertion can be individually disabled by setting the respective event bit 
1119:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * in the \a TRAPDIS register in order to suppress trap generation.
1120:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1121:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_TRAP_Enable(), XMC_SCU_TRAP_ClearStatus(), XMC_SCU_TRAP_GetStatus() \n\n\n
1122:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1123:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_TRAP_Disable(const uint32_t trap);
1124:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1125:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1126:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1127:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param trap  The event for which, trap status bit has to be cleared.\n
1128:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_TRAP_t to identify the event.
1129:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1130:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1131:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1132:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1133:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Clears the trap status of input event.\n\n
1134:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Once a trap event is detected, it will have to be acknowledged and later serviced. 
1135:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The trap status bit should be cleared to detect the occurence of trap next time. 
1136:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * This is useful while polling for TRAPSTAT without enabling the NMI for trap.
1137:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Trap status can be cleared by setting the event bit in the \a TRAPCLR register.
1138:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1139:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_INTERRUPT_EnableNmiRequest(), XMC_SCU_TRAP_GetStatus() \n\n\n
1140:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1141:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_TRAP_ClearStatus(const uint32_t trap);
1142:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1143:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1144:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Status of trap generating events.\n
1145:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_TRAP_t to identify the event. The returned
1146:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * value indicates the status of multiple events at their respective bit positions.
1147:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * User should mask the bits of the events of interest using the type specified.
1148:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1149:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1150:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the status of trap generating events. \n\n
1151:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The status is read from \a TRAPRAW register. Status of the specific events can be checked
1152:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * using their respective bits in the \a TRAPRAW register. The bit masks can be obtained from
1153:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the enumeration type @ref XMC_SCU_TRAP_t. Multiple events can be combined using \a OR operation.
1154:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * A trap event is considered to be asserted if the respective bit of the event is set to 1.
1155:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1156:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_INTERRUPT_EnableNmiRequest(), XMC_SCU_TRAP_ClearStatus() \n\n\n
1157:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1158:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_TRAP_GetStatus(void);  
1159:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1160:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1161:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1162:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param trap  The event for which, trap has to be triggered.\n
1163:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_TRAP_t to identify the event.
1164:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1165:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1166:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1167:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1168:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Triggers trap generation for the event specified. \n\n
1169:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The trap source has to be enabled before invocation of this API. 
1170:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Trap event can be triggered by setting its respective bit in the \a TRAPSET register.
1171:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Trap event can be configured to generate a non maskable interrupt by using the API XMC_SCU_INTER
1172:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps to manually assert a trap event:\n
1173:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_TRAP_EnableEvent with desired trap request source ID.\n
1174:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_TRAP_SetEvent with same trap request source ID to manually assert a trap event
1175:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1176:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_INTERRUPT_EnableNmiRequest(), XMC_SCU_TRAP_GetStatus() \n\n\n
1177:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1178:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_TRAP_Trigger(const uint32_t trap);
1179:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1180:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1181:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1182:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param peripheral  The peripheral to be reset.\n
1183:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Type @ref XMC_SCU_PERIPHERAL_RESET_t enumerates all the peripherals that can be
1184:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1185:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1186:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1187:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1188:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Puts the specified peripheral in to reset state. \n\n
1189:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API achieves reset of peripherals by setting the respective bit in the \a PRSET0,  \a PRSET1
1190:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * register. Status of reset assertion automatically stored in the \a PRSTATn register and can be c
1191:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * user software to determine the state of the system and for debug purpose.\n
1192:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps to assert a peripheral reset:\n
1193:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_RESET_AssertPeripheralReset() with desired peripheral identifier.\n
1194:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_RESET_IsPeripheralResetAsserted with same peripheral identifier to verify whet
1195:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * is in reset state.\n
1196:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1197:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_RESET_IsPeripheralResetAsserted() \n\n\n
1198:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1199:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_RESET_AssertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral);
1200:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1201:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1202:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1203:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param peripheral  The peripheral to be moved out of reset state.\n
1204:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Type @ref XMC_SCU_PERIPHERAL_RESET_t enumerates all the peripherals that can be
1205:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1206:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1207:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1208:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1209:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables the specified peripheral by moving it out of reset state.  \n\n
1210:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Any peripheral should be moved out of reset state for executing its functionality.
1211:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API enables the peripheral by setting its respective bit in the \a PRCLR0,  \a PRCLR1 or  \a
1212:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * register. Status of reset deassertion is automatically stored in the \a PRSTATn register and can
1213:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the user software to determine the state of the system and for debug purpose.\n
1214:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps to deassert a peripheral reset:\n
1215:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_RESET_DeassertPeripheralReset() with desired peripheral identifier.\n
1216:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_RESET_IsPeripheralResetAsserted() with desired peripheral identifier to verify
1217:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * has been enabled.\n
1218:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1219:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_RESET_AssertPeripheralReset() \n\n\n
1220:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1221:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral);
1222:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1223:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1224:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1225:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param peripheral  The peripheral, whose reset status has to be checked.\n
1226:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Type @ref XMC_SCU_PERIPHERAL_RESET_t enumerates all the peripherals.
1227:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1228:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return bool  Status of peripheral reset. \n
1229:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *               \b Range: \a true if peripheral is in reset state. \a false if peripheral is enabl
1230:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1231:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1232:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Checks the reset status of the selected peripheral.\n\n
1233:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API reads the reset status from \a PRSTATn register. Returns true if the peripheral is in
1234:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * reset state. On power up of the device, all the peripherals will be in reset state. 
1235:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If the peripheral is enabled, \a false will be returned as the status.
1236:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1237:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_RESET_AssertPeripheralReset(), XMC_SCU_RESET_DeassertPeripheralReset() \n\n\n 
1238:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1239:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** bool XMC_SCU_RESET_IsPeripheralResetAsserted(const XMC_SCU_PERIPHERAL_RESET_t peripheral);
1240:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  
1241:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1242:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1243:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param memory  The on-chip RAM type, for which the parity error status has to be cleared.\n
1244:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_PARITY_t to identify the on-chip RAM type. Multiple 
1245:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          memory status bits can be cleared by using the \a OR operation.
1246:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1247:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1248:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1249:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1250:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Clears the parity error status bit. \n\n
1251:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * When a memory parity error is detected using the status bits in \a PEFLAG register. It has to 
1252:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * be cleared by software to detect the parity error from the same memory next time.
1253:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API clears the parity error status bit of the selected peripheral by setting the 
1254:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * respective bit in the \a PEFLAG register. Status of multiple memory parity errors 
1255:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * can be cleared by combining the enum values using \a OR operation.
1256:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1257:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_PARITY_GetStatus(), XMC_SCU_PARITY_Enable(), XMC_SCU_PARITY_EnableTrapGeneration() \n\n\
1258:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1259:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_PARITY_ClearStatus(const uint32_t memory);
1260:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1261:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1262:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1263:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param memory  The on-chip RAM type, for which the parity error checking has to be enabled.\n
1264:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_PARITY_t to identify the on-chip RAM type. Multiple 
1265:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          memory types can be combined using the \a OR operation.
1266:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1267:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1268:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1269:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1270:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables parity error checking for the selected on-chip RAM type.\n\n
1271:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Parity error checking can be enabled by setting respective bits in the \a PEEN register.
1272:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Additionally parity error can be configured to generate trap when the error is detected,
1273:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * using the API XMC_SCU_PARITY_EnableTrapGeneration(). Such a trap can be further configured
1274:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * to generate non maskable interrupt(NMI) using the API XMC_SCU_INTERRUPT_EnableNmiRequest().
1275:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1276:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_PARITY_EnableTrapGeneration(), XMC_SCU_INTERRUPT_EnableNmiRequest() \n\n\n
1277:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1278:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_PARITY_Enable(const uint32_t memory);
1279:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1280:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1281:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1282:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param memory   The on-chip RAM type, for which the parity error checking has to be disabled.\n
1283:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_PARITY_t to identify the on-chip RAM type. Multiple 
1284:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          memory types can be combined using the \a OR operation.
1285:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1286:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1287:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1288:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1289:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables parity error checking for the selected on-chip RAM type.\n\n
1290:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Parity error detection can be disabled by clearing the respective bit in the \a PEEN register.
1291:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1292:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_PARITY_Enable(), XMC_SCU_PARITY_DisableTrapGeneration() \n\n\n
1293:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1294:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_PARITY_Disable(const uint32_t memory);
1295:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1296:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1297:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1298:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param memory  The on-chip RAM type, for which the parity error trap generation has to be enable
1299:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_PARITY_t to identify the on-chip RAM type. Multiple 
1300:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          memory types can be combined using the \a OR operation.
1301:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1302:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1303:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1304:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1305:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables trap assertion for the parity error source.\n\n
1306:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Parity error detection for different types of on-chip RAM can generate trap.
1307:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Trap assertion for parity error can be individually enabled by setting the respective bits
1308:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * in the \a PETE register. The generated trap can be additionally configured to generate
1309:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * non maskable interrupt(NMI) using the API XMC_SCU_INTERRUPT_EnableNmiRequest().
1310:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1311:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_INTERRUPT_EnableNmiRequest(), XMC_SCU_PARITY_DisableTrapGeneration() \n\n\n
1312:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1313:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_PARITY_EnableTrapGeneration(const uint32_t memory);
1314:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1315:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1316:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1317:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param memory  The on-chip RAM type, for which the parity error trap generation has to be disabl
1318:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_PARITY_t to identify the on-chip RAM type. Multiple 
1319:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          memory types can be combined using the \a OR operation.
1320:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1321:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1322:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1323:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1324:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables the assertion of trap for the parity error source.\n\n
1325:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Trap assertion can be disabled by clearing the respective bit of the RAM type in the \a PETE reg
1326:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1327:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1328:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_PARITY_EnableTrapGeneration() \n\n\n
1329:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1330:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_PARITY_DisableTrapGeneration(const uint32_t memory);
1331:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1332:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1333:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1334:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Status of parity error detection for the on-chip RAM modules.\n
1335:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_PARITY_t to get the bit mask of each RAM module type.
1336:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1337:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1338:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the status of parity error detection for the on-chip RAM modules.\n\n
1339:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Parity error status information is obtained from the \a PEFLAG register.
1340:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If a particular RAM module has parity error, its respective bit field will be set to 1 in the 
1341:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * returned value. A check for the status of a particular RAM module can be done by
1342:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * masking the returned value with the RAM module identifier from the type @ref XMC_SCU_PARITY_t.
1343:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1344:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_PARITY_ClearStatus() \n\n\n
1345:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1346:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_PARITY_GetStatus(void);  
1347:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1348:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1349:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1350:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param clock  Peripheral for which the clock has to be enabled. \n
1351:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_t to select the peripheral.
1352:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1353:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1354:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1355:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1356:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables the source clock for selected peripheral.\n\n
1357:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The various outputs of Clock Generation Unit (CGU) can be individually enabled by setting the pe
1358:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * specific bit in the \a CLKSET register.\n
1359:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps to verify whether a source clock of peripheral is enabl
1360:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_CLOCK_EnableClock() with desired peripheral identifier.\n
1361:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_CLOCK_IsClockEnabled() with same peripheral identifier to verify whether the c
1362:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1363:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_DisableClock(), XMC_SCU_RESET_DeassertPeripheralReset() \n\n\n
1364:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1365:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_EnableClock(const XMC_SCU_CLOCK_t clock);
1366:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1367:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1368:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1369:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param clock  Peripheral for which the clock has to be disabled. \n
1370:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_t to select the peripheral.
1371:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1372:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1373:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1374:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1375:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables source clock for the peripheral selected.\n\n
1376:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The various outputs of Clock Generation Unit (CGU) can be individually disabled  by setting the 
1377:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * specific bits in the \a CLKCLR register.\n
1378:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps to verify whether clock source of the peripheral is ena
1379:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_CLOCK_DisableClock with desired peripheral identifier.\n
1380:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_CLOCK_IsClockEnabled with same peripheral identifier to verify whether periphe
1381:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1382:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_EnableClock(), XMC_SCU_RESET_AssertPeripheralReset() \n\n\n
1383:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1384:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_DisableClock(const XMC_SCU_CLOCK_t clock);
1385:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1386:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1387:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1388:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param clock   Peripheral for which the clock status has to be checked. \n
1389:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_t to select the peripheral.
1390:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1391:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return bool  Status of peripheral clock.\n
1392:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: \a true if peripheral clock is enabled. \a false if peripheral clock is disable
1393:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1394:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1395:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Checks the status of peripheral source clock.\n\n
1396:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The status of peripheral source clock is read from the \a CLKSTATn register. 
1397:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Returns \a true if clock is enabled and returns \a false otherwise.
1398:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1399:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_EnableClock(), XMC_SCU_CLOCK_DisableClock() \n\n\n
1400:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1401:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** bool XMC_SCU_CLOCK_IsClockEnabled(const XMC_SCU_CLOCK_t clock);
1402:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1403:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1404:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1405:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param source  Source of clock for fSYS.\n
1406:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_SYSCLKSRC_t to select the source of clock.\n
1407:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_SYSCLKSRC_OFI for selecting internal fast clock as fSYS.\n
1408:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_SYSCLKSRC_PLL for selecting the output of PLL fPLL as fSYS.
1409:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1410:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1411:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1412:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1413:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source for system clock (fSYS).\n\n
1414:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * System clock is selected by setting \a SYSSEL bits in the \a SYSCLKCR register.
1415:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If \a XMC_SCU_CLOCK_SYSCLKSRC_PLL is selected, then the dividers of the PLL have to be
1416:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * additionally configured to achieve the required system clock frequency. 
1417:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   * \par<b>Related APIs:</b><BR>
1418:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_StartSystemPll(), XMC_SCU_CLOCK_EnableHighPerformanceOscillator() \n\n\n
1419:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1420:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source);
1421:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1422:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1423:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_CLOCK_SYSCLKSRC_t   Source of clock for fSYS.\n
1424:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_SYSCLKSRC_t to select the source of clock.\n
1425:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_SYSCLKSRC_OFI - internal fast clock selected as fSYS.\n
1426:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_SYSCLKSRC_PLL - output of PLL fPLL selected as fSYS.
1427:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1428:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1429:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the selected source of system clock (fSYS). \n\n
1430:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selected source of fSYS is obtained by reading \a SYSSEL bits of \a SYSCLKCR register.
1431:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1432:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetSystemClockSource(), XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency() \n\n\n
1433:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1434:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_CLOCK_SYSCLKSRC_t XMC_SCU_CLOCK_GetSystemClockSource(void)
1435:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1436:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_CLOCK_SYSCLKSRC_t)(SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk);
1437:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1438:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1439:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1440:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1441:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param source   Source of clock for USB and SDMMC(fUSB/SDMMC).\n
1442:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_USBCLKSRC_t to select the source of clock.\n
1443:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_USBCLKSRC_USBPLL - output of USB PLL as source of USB clock(fUSB/
1444:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_USBCLKSRC_SYSPLL - output of PLL fPLL as source of USB clock(fUSB
1445:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1446:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1447:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1448:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1449:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source of USB/SDMMC clock (fUSB/SDMMC).\n\n
1450:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * USB and SDMMC use a common clock source. They can either use fUSB PLL or fPLL as the source of c
1451:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The selection is done by configuring the \a USBSEL bits of \a USBCLKCR register.
1452:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1453:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetUsbClockDivider(), XMC_SCU_CLOCK_GetUsbPllClockFrequency() \n\n\n
1454:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1455:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetUsbClockSource(const XMC_SCU_CLOCK_USBCLKSRC_t source);
1456:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1457:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1458:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_CLOCK_USBCLKSRC_t   Source of clock for USB and SDMMC(fUSB/SDMMC).\n
1459:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_USBCLKSRC_t to identify the source of clock.\n
1460:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_USBCLKSRC_USBPLL - output of USB PLL is selected as source of USB
1461:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_USBCLKSRC_SYSPLL - output of PLL fPLL is selected as source of US
1462:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1463:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1464:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the selected source of USB and SDMMC clock frequency.\n\n
1465:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The clock source is read from from the \a USBSEL bits of \a USBCLKCR register.
1466:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1467:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetUsbClockDivider(), XMC_SCU_CLOCK_GetUsbPllClockFrequency() \n\n\n
1468:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1469:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_CLOCK_USBCLKSRC_t XMC_SCU_CLOCK_GetUsbClockSource(void)
1470:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
  27              	 .loc 1 1470 0
  28              	 .cfi_startproc
  29              	 
  30              	 
  31              	 
  32 0000 80B4     	 push {r7}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 4
  35              	 .cfi_offset 7,-4
  36 0002 00AF     	 add r7,sp,#0
  37              	.LCFI1:
  38              	 .cfi_def_cfa_register 7
1471:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_CLOCK_USBCLKSRC_t)(SCU_CLK->USBCLKCR & SCU_CLK_USBCLKCR_USBSEL_Msk);
  39              	 .loc 1 1471 0
  40 0004 044B     	 ldr r3,.L3
  41 0006 9B69     	 ldr r3,[r3,#24]
  42 0008 03F48033 	 and r3,r3,#65536
1472:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
  43              	 .loc 1 1472 0
  44 000c 1846     	 mov r0,r3
  45 000e BD46     	 mov sp,r7
  46              	.LCFI2:
  47              	 .cfi_def_cfa_register 13
  48              	 
  49 0010 5DF8047B 	 ldr r7,[sp],#4
  50              	.LCFI3:
  51              	 .cfi_restore 7
  52              	 .cfi_def_cfa_offset 0
  53 0014 7047     	 bx lr
  54              	.L4:
  55 0016 00BF     	 .align 2
  56              	.L3:
  57 0018 00460050 	 .word 1342195200
  58              	 .cfi_endproc
  59              	.LFE129:
  61              	 .section .text.XMC_SCU_CLOCK_GetWdtClockSource,"ax",%progbits
  62              	 .align 2
  63              	 .thumb
  64              	 .thumb_func
  66              	XMC_SCU_CLOCK_GetWdtClockSource:
  67              	.LFB130:
1473:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1474:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1475:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1476:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param source  Clock source for watchdog timer.\n
1477:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type XMC_SCU_CLOCK_WDTCLKSRC_t to identify the clock source.\n
1478:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_WDTCLKSRC_OFI - internal fast oscillator (fOFI)\n
1479:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_WDTCLKSRC_STDBY - backup standby clock (fSTDBY)\n
1480:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_WDTCLKSRC_PLL - PLL output clock (fPLL)
1481:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1482:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1483:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1484:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1485:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source of WDT clock (fWDT).\n\n
1486:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The selected value is configured to the \a WDTSEL bits of \a WDTCLKCR register.
1487:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The watchdog timer counts at the frequency selected using this API. So the time for
1488:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * timeout or pre-warning of watchdog has to be calculated based on this selection.
1489:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1490:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1491:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetWdtClockDivider(), XMC_SCU_CLOCK_GetWdtClockFrequency() \n\n\n
1492:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1493:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetWdtClockSource(const XMC_SCU_CLOCK_WDTCLKSRC_t source);
1494:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1495:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1496:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_CLOCK_WDTCLKSRC_t   Clock source configured for watchdog timer.\n
1497:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type XMC_SCU_CLOCK_WDTCLKSRC_t to identify the clock source.\n
1498:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_WDTCLKSRC_OFI - internal fast oscillator (fOFI)\n
1499:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_WDTCLKSRC_STDBY - backup standby clock (fSTDBY)\n
1500:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_WDTCLKSRC_PLL - PLL output clock (fPLL)
1501:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1502:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1503:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the source of clock used for watchdog timer.\n\n
1504:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a WDTSEL bits of \a WDTCLKCR register.
1505:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The time for timeout or pre-warning of watchdog has to be calculated based on 
1506:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the clock source selected.
1507:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1508:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetWdtClockDivider(), XMC_SCU_CLOCK_SetWdtClockSource() \n\n\n
1509:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1510:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_CLOCK_WDTCLKSRC_t XMC_SCU_CLOCK_GetWdtClockSource(void)
1511:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
  68              	 .loc 1 1511 0
  69              	 .cfi_startproc
  70              	 
  71              	 
  72              	 
  73 0000 80B4     	 push {r7}
  74              	.LCFI4:
  75              	 .cfi_def_cfa_offset 4
  76              	 .cfi_offset 7,-4
  77 0002 00AF     	 add r7,sp,#0
  78              	.LCFI5:
  79              	 .cfi_def_cfa_register 7
1512:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_CLOCK_WDTCLKSRC_t)(SCU_CLK->WDTCLKCR & SCU_CLK_WDTCLKCR_WDTSEL_Msk);
  80              	 .loc 1 1512 0
  81 0004 044B     	 ldr r3,.L7
  82 0006 5B6A     	 ldr r3,[r3,#36]
  83 0008 03F44033 	 and r3,r3,#196608
1513:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
  84              	 .loc 1 1513 0
  85 000c 1846     	 mov r0,r3
  86 000e BD46     	 mov sp,r7
  87              	.LCFI6:
  88              	 .cfi_def_cfa_register 13
  89              	 
  90 0010 5DF8047B 	 ldr r7,[sp],#4
  91              	.LCFI7:
  92              	 .cfi_restore 7
  93              	 .cfi_def_cfa_offset 0
  94 0014 7047     	 bx lr
  95              	.L8:
  96 0016 00BF     	 .align 2
  97              	.L7:
  98 0018 00460050 	 .word 1342195200
  99              	 .cfi_endproc
 100              	.LFE130:
 102              	 .section .text.XMC_SCU_CLOCK_GetExternalOutputClockSource,"ax",%progbits
 103              	 .align 2
 104              	 .thumb
 105              	 .thumb_func
 107              	XMC_SCU_CLOCK_GetExternalOutputClockSource:
 108              	.LFB133:
1514:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1515:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1516:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1517:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param source   Source for standby clock.\n
1518:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_HIB_STDBYCLKSRC_t to identify the clock source.\n
1519:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    XMC_SCU_HIB_STDBYCLKSRC_OSI - internal slow oscillator (fOSI) \n
1520:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    XMC_SCU_HIB_STDBYCLKSRC_OSCULP - ultra low power osciallator (fULP) \n
1521:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1522:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1523:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1524:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1525:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source of Standby clock (fSTDBY).\n\n
1526:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Clock source is configured by setting the \a STDBYSEL bits of \a HDCR register.
1527:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Hibernate domain should be enabled explicitly before using the API.
1528:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1529:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_HIB_GetStdbyClockSource(), XMC_SCU_HIB_EnableHibernateDomain() \n\n\n
1530:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1531:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_HIB_SetStandbyClockSource(const XMC_SCU_HIB_STDBYCLKSRC_t source);
1532:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1533:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1534:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_HIB_RTCCLKSRC_t   Source clock of standby clock(fSTDBY).\n
1535:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_HIB_STDBYCLKSRC_t to identify the clock source.\n
1536:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    XMC_SCU_HIB_STDBYCLKSRC_OSI - internal slow oscillator (fOSI) \n
1537:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    XMC_SCU_HIB_STDBYCLKSRC_OSCULP - ultra low power osciallator (fULP) \n
1538:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1539:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1540:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the source of standby clock (fSTDBY).\n\n
1541:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a STDBYSEL bits of \a HDCR register.\n
1542:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1543:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_HIB_SetStandbyClockSource(), XMC_SCU_HIB_EnableHibernateDomain() \n\n\n
1544:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1545:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_HIB_RTCCLKSRC_t XMC_SCU_HIB_GetStdbyClockSource(void)
1546:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1547:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_HIB_RTCCLKSRC_t)(SCU_HIBERNATE->HDCR & SCU_HIBERNATE_HDCR_STDBYSEL_Msk);
1548:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1549:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1550:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1551:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1552:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param source  Source of RTC clock.\n
1553:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            \b Range: Use type @ref XMC_SCU_HIB_RTCCLKSRC_t to identify the clock source.\n
1554:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_HIB_RTCCLKSRC_OSI - internal slow oscillator(fOSI). \n
1555:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_HIB_RTCCLKSRC_ULP - ultra low power oscillator(fULP). \n
1556:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1557:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1558:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1559:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1560:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source of RTC clock (fRTC).\n\n
1561:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is configured to \a RCS bit of \a HDCR register.
1562:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * fULP needs external input powered by VBAT or VDDP. fOSI is internal clock.
1563:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The frequency of the clock will be 32.768 kHz.
1564:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1565:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_HIB_GetRtcClockSource() \n\n\n
1566:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1567:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_HIB_SetRtcClockSource(const XMC_SCU_HIB_RTCCLKSRC_t source);
1568:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1569:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1570:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_HIB_RTCCLKSRC_t   Source of RTC clock.\n
1571:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            \b Range: Use type @ref XMC_SCU_HIB_RTCCLKSRC_t to identify the clock source.\n
1572:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_HIB_RTCCLKSRC_OSI - internal slow oscillator(fOSI). \n
1573:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_HIB_RTCCLKSRC_ULP - ultra low power oscillator(fULP). \n
1574:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1575:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1576:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the source of RTC clock (fRTC).
1577:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a RCS bit of \a HDCR register.
1578:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The frequency of the clock will be 32.768 kHz.
1579:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1580:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_HIB_SetRtcClockSource() \n\n\n
1581:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1582:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_HIB_RTCCLKSRC_t XMC_SCU_HIB_GetRtcClockSource(void)
1583:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1584:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_HIB_RTCCLKSRC_t)(SCU_HIBERNATE->HDCR & SCU_HIBERNATE_HDCR_RCS_Msk);
1585:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1586:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1587:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1588:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1589:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param clock  Source of external clock output(fEXT).\n
1590:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *           \b Range: Use type @ref XMC_SCU_CLOCK_EXTOUTCLKSRC_t to identify the clock.\n
1591:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_SYS - system clock fSYS. \n
1592:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_USB - USB clock fUSB. \n
1593:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_PLL - PLL output fPLL. \n
1594:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \if XMC42
1595:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_STDBY - Standby clock fSTDBY. \n
1596:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1597:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \endif
1598:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \if XMC41
1599:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_STDBY - Standby clock fSTDBY. \n
1600:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \endif
1601:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1602:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1603:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1604:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1605:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source of external clock out (fEXT).\n\n
1606:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value will be configured to \a ECKSEL bits of \a EXTCLKCR register.
1607:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1608:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetExternalOutputClockSource(), XMC_SCU_CLOCK_SetExternalOutputClockDivider() \n\n
1609:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1610:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetExternalOutputClockSource(const XMC_SCU_CLOCK_EXTOUTCLKSRC_t clock);
1611:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1612:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1613:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_CLOCK_EXTOUTCLKSRC_t   Source of external clock output(fEXT).\n
1614:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *           \b Range: Use type @ref XMC_SCU_CLOCK_EXTOUTCLKSRC_t to identify the clock.\n
1615:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_SYS - system clock fSYS. \n
1616:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_USB - USB clock fUSB. \n
1617:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_PLL - PLL output fPLL. \n
1618:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \if XMC42
1619:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_STDBY - Standby clock fSTDBY. \n
1620:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \endif
1621:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \if XMC41
1622:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_STDBY - Standby clock fSTDBY. \n
1623:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \endif
1624:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1625:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1626:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the source of external clock output(fEXT).\n\n
1627:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a ECKSEL bits of \a EXTCLKCR register.
1628:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1629:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetExternalOutputClockSource(), XMC_SCU_CLOCK_SetExternalOutputClockDivider() \n\n
1630:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1631:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_CLOCK_EXTOUTCLKSRC_t XMC_SCU_CLOCK_GetExternalOutputClockSource(void)
1632:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 109              	 .loc 1 1632 0
 110              	 .cfi_startproc
 111              	 
 112              	 
 113              	 
 114 0000 80B4     	 push {r7}
 115              	.LCFI8:
 116              	 .cfi_def_cfa_offset 4
 117              	 .cfi_offset 7,-4
 118 0002 00AF     	 add r7,sp,#0
 119              	.LCFI9:
 120              	 .cfi_def_cfa_register 7
1633:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_CLOCK_EXTOUTCLKSRC_t)(SCU_CLK->EXTCLKCR & SCU_CLK_EXTCLKCR_ECKSEL_Msk);
 121              	 .loc 1 1633 0
 122 0004 054B     	 ldr r3,.L11
 123 0006 9B6A     	 ldr r3,[r3,#40]
 124 0008 DBB2     	 uxtb r3,r3
 125 000a 03F00303 	 and r3,r3,#3
 126 000e DBB2     	 uxtb r3,r3
1634:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
 127              	 .loc 1 1634 0
 128 0010 1846     	 mov r0,r3
 129 0012 BD46     	 mov sp,r7
 130              	.LCFI10:
 131              	 .cfi_def_cfa_register 13
 132              	 
 133 0014 5DF8047B 	 ldr r7,[sp],#4
 134              	.LCFI11:
 135              	 .cfi_restore 7
 136              	 .cfi_def_cfa_offset 0
 137 0018 7047     	 bx lr
 138              	.L12:
 139 001a 00BF     	 .align 2
 140              	.L11:
 141 001c 00460050 	 .word 1342195200
 142              	 .cfi_endproc
 143              	.LFE133:
 145              	 .section .text.XMC_SCU_CLOCK_GetSystemClockFrequency,"ax",%progbits
 146              	 .align 2
 147              	 .thumb
 148              	 .thumb_func
 150              	XMC_SCU_CLOCK_GetSystemClockFrequency:
 151              	.LFB143:
1635:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1636:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1637:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1638:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param source  Source of clock for system PLL.\n
1639:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_SYSPLLCLKSRC_t for identifying the clock source.\n
1640:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                            XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP - External High performance oscillat
1641:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                            XMC_SCU_CLOCK_SYSPLLCLKSRC_OFI - Internal fast clock (fOFI).
1642:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1643:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1644:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1645:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1646:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source of system PLL.\n\n
1647:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is configured to \a VCOBYP bit of \a PLLCON0 register.
1648:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If \a XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP is selected, ensure that the high performance oscillator 
1649:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * enabled by using the API XMC_SCU_CLOCK_EnableHighPerformanceOscillator().
1650:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1651:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_EnableHighPerformanceOscillator()\n\n\n
1652:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1653:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source);
1654:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1655:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1656:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_CLOCK_OSCCLKSRC_t   Source of clock for system PLL.\n
1657:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_SYSPLLCLKSRC_t for identifying the clock source.\n
1658:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                            XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP - External High performance oscillat
1659:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                            XMC_SCU_CLOCK_SYSPLLCLKSRC_OFI - Internal fast clock (fOFI).
1660:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1661:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1662:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the source of system PLL clock (fPLL). \n\n
1663:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a VCOBYP bit of \a PLLCON0 register.
1664:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1665:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_EnableHighPerformanceOscillator(), XMC_SCU_CLOCK_SetSystemPllClockSource()\n\n\n
1666:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1667:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_CLOCK_SYSPLLCLKSRC_t XMC_SCU_CLOCK_GetSystemPllClockSource(void)
1668:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1669:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_CLOCK_SYSPLLCLKSRC_t)(SCU_PLL->PLLCON0 & SCU_PLL_PLLCON0_VCOBYP_Msk);
1670:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1671:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1672:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ECAT0) 
1673:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1674:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1675:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param source  Source of ECAT clock.\n
1676:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            \b Range: Use type @ref XMC_SCU_CLOCK_ECATCLKSRC_t to identify the clock source.\n
1677:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_CLOCK_ECATCLKSRC_USBPLL - USB PLL (fUSBPLL) as a source for ECAT c
1678:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_CLOCK_ECATCLKSRC_SYSPLL - Main PLL output (fPLL) as a source for E
1679:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1680:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1681:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1682:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1683:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source of ECAT clock (fECAT).\n\n
1684:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is configured to \a ECATSEL bit of \a ECATCLKCR register.
1685:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1686:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetECATClockSource() \n\n\n
1687:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1688:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE void XMC_SCU_CLOCK_SetECATClockSource(const XMC_SCU_CLOCK_ECATCLKSRC_t source)
1689:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1690:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   SCU_CLK->ECATCLKCR = (SCU_CLK->ECATCLKCR & ((uint32_t)~SCU_CLK_ECATCLKCR_ECATSEL_Msk)) |
1691:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                       ((uint32_t)source);
1692:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1693:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1694:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1695:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_CLOCK_ECATCLKSRC_t   Source of ECAT clock.\n
1696:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            \b Range: Use type @ref XMC_SCU_CLOCK_ECATCLKSRC_t to identify the clock source.\n
1697:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_CLOCK_ECATCLKSRC_USBPLL - USB PLL (fUSBPLL) as a source for ECAT c
1698:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_CLOCK_ECATCLKSRC_SYSPLL - Main PLL output (fPLL) as a source for E
1699:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1700:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1701:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the source of ECAT clock (fECAT).
1702:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a ECATSEL bit of \a ECATCLKCR register.
1703:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1704:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_HIB_SetRtcClockSource() \n\n\n
1705:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1706:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_CLOCK_ECATCLKSRC_t XMC_SCU_CLOCK_GetECATClockSource(void)
1707:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1708:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_CLOCK_ECATCLKSRC_t)((SCU_CLK->ECATCLKCR & SCU_CLK_ECATCLKCR_ECATSEL_Msk) >> SCU_C
1709:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1710:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
1711:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1712:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1713:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1714:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param divider   Ratio of fSYS clock source to the value of fSYS.
1715:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: 1 to 256.
1716:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1717:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1718:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1719:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1720:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the ratio of system clock source to the value of system clock frequency.\n\n
1721:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is configured as \a SYSDIV bits of \a SYSCLKCR register. The divider value is 
1722:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * decremented by 1 before configuring.
1723:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1724:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetSystemClockDivider(),  XMC_SCU_CLOCK_SetSystemClockSource() \n\n\n
1725:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1726:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider);
1727:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1728:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1729:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t   Ratio of fSYS clock source to the value of fSYS.
1730:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: 0 to 255.
1731:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1732:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1733:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the value of ratio between the source of system clock to the the value of system clock 
1734:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a SYSDIV bits of \a SYSCLKCR register.
1735:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1736:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetSystemClockDivider(),  XMC_SCU_CLOCK_SetSystemClockSource() \n\n\n
1737:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1738:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetSystemClockDivider(void)
1739:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1740:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) >> SCU_CLK_SYSCLKCR_SYSDIV_Po
1741:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1742:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1743:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1744:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1745:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio  Ratio of fCCU clock source to the value of fCCU.
1746:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: 1 or 2.\n
1747:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  1-> fCCU= fSYS \n
1748:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  2-> fCCU= fSYS/2.
1749:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1750:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1751:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1752:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1753:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the divider for CCU clock source. \n\n
1754:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Capture compare unit(CCU) can take either fSYS or fSYS/2 as the source of clock.
1755:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The configuration is set to \a CCUDIV bit of \a CCUCLKCR register. The CCUDIV bit is 1 bit wide.
1756:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1757:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1758:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetCcuClockDivider() \n\n\n
1759:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1760:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t ratio);
1761:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1762:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1763:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Ratio of fCCU clock source to the value of fCCU.
1764:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: 0 or 1.\n
1765:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  0-> fCCU= fSYS \n
1766:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  1-> fCCU= fSYS/2.
1767:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1768:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1769:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the ratio of CCU clock(fCCU) to system clock(fSYS).\n\n
1770:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a CCUDIV bit of \a CCUCLKCR register.
1771:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1772:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1773:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetCcuClockDivider() \n\n\n
1774:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1775:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetCcuClockDivider(void)
1776:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1777:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->CCUCLKCR & SCU_CLK_CCUCLKCR_CCUDIV_Msk) >> SCU_CLK_CCUCLKCR_CCUDIV_Po
1778:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1779:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1780:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1781:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1782:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio  Ratio between system clock(fSYS) and CPU clock(fCPU).
1783:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 1 or 2.\n
1784:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            1-> fCPU= fSYS. \n
1785:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            2-> fCPU= fSYS/2.
1786:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1787:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1788:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1789:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1790:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the CPU clock by setting the divider value for the system clock. \n\n
1791:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is set to the \a CPUDIV bit of \a CPUCLKCR register.
1792:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1793:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetCpuClockDivider() \n\n\n
1794:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1795:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t ratio);
1796:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1797:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1798:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t   Ratio between system clock(fSYS) and CPU clock(fCPU).
1799:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 0 or 1.\n
1800:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            0-> fCPU= fSYS. \n
1801:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            1-> fCPU= fSYS/2.
1802:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1803:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1804:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the ratio between system clock(fSYS) and CPU clock(fCPU). \n\n
1805:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a CPUDIV bit of \a CPUCLKCR register.
1806:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1807:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetCpuClockDivider() \n\n\n
1808:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1809:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetCpuClockDivider(void)
1810:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1811:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) >> SCU_CLK_CPUCLKCR_CPUDIV_Po
1812:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1813:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1814:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1815:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1816:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio  Ratio of peripheral clock source to the value of peripheral clock.\n
1817:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 1 or 2.\n
1818:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                1-> fPERIPH= fCPU.\n
1819:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                2-> fPERIPH= fCPU/2.
1820:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1821:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1822:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1823:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1824:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the peripheral clock by setting the divider for CPU clock(fCPU).\n\n
1825:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The peripheral clock can be equal to either fCPU or fCPU/2. The value is configured to \a PBDIV 
1826:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1827:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1828:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetPeripheralClockDivider() \n\n\n
1829:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1830:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t ratio);
1831:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1832:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1833:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Ratio of peripheral clock source to the value of peripheral clock.\n
1834:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 0 or 1.\n
1835:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                0-> fPERIPH= fCPU.\n
1836:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                1-> fPERIPH= fCPU/2.
1837:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1838:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1839:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the ratio of CPU clock(fCPU) to peripheral clock(fPERIPH).\n\n
1840:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a PBDIV bit of \a PBCLKCR register.
1841:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1842:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetPeripheralClockDivider() \n\n\n
1843:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1844:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetPeripheralClockDivider(void)
1845:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1846:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->PBCLKCR & SCU_CLK_PBCLKCR_PBDIV_Msk) >> SCU_CLK_PBCLKCR_PBDIV_Pos);
1847:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1848:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1849:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1850:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1851:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio   Ratio of PLL output clock(fPLL) to USB clock(fUSB).
1852:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 1 to 8.
1853:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1854:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1855:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1856:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1857:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the USB clock(fUSB) by setting the USB clock divider. \n\n
1858:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is decremented by 1 before setting it to \a USBDIV bits of \a USBCLKCR register.
1859:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1860:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1861:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetUsbClockDivider(), XMC_SCU_CLOCK_SetUsbClockSource() \n\n\n
1862:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1863:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t ratio);
1864:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1865:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1866:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1867:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Ratio of PLL output clock(fPLL) to USB clock(fUSB).
1868:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 0 to 7.
1869:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1870:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1871:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the ratio between PLL output frequency(fPLL) and USB clock(fUSB).\n\n
1872:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a USBDIV bit of \a USBCLKCR register.
1873:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1874:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetUsbClockDivider(), XMC_SCU_CLOCK_GetUsbClockSource() \n\n\n
1875:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1876:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetUsbClockDivider(void)
1877:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1878:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->USBCLKCR & SCU_CLK_USBCLKCR_USBDIV_Msk) >> SCU_CLK_USBCLKCR_USBDIV_Po
1879:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1880:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1881:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1882:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1883:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(EBU)
1884:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1885:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1886:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio Ratio of PLL clock(fPLL) to EBU clock(fEBU).\n
1887:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 1 to 64.
1888:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1889:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1890:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1891:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1892:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the EBU clock(fEBU) by setting the divider value.\n\n
1893:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The clock divider is configured to the \a EBUDIV bits of \a EBUCLKCR register.
1894:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1895:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetEbuClockDivider() \n\n\n
1896:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1897:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetEbuClockDivider(const uint32_t ratio);
1898:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1899:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1900:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1901:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Ratio of PLL clock(fPLL) to EBU clock(fEBU).\n
1902:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 0 to 63.
1903:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1904:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1905:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the ratio between PLL clock(fPLL) and EBU clock(fEBU).\n\n
1906:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a EBUDIV bits of \a EBUCLKCR register.
1907:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1908:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetEbuClockDivider() \n\n\n
1909:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1910:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetEbuClockDivider(void)
1911:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1912:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->EBUCLKCR & SCU_CLK_EBUCLKCR_EBUDIV_Msk) >> SCU_CLK_EBUCLKCR_EBUDIV_Po
1913:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1914:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
1915:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1916:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1917:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1918:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio  Ratio between the source of WDT clock and the WDT clock.\n
1919:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 1 to 256.
1920:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1921:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1922:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1923:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1924:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the WDT clock by setting the clock divider for the WDT clock source.\n\n
1925:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is configured to \a WDTDIV bits of \a WDTCLKCR register. The value of divider
1926:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * is decremented by 1 before configuring. Check the selected clock source for the WDT clock
1927:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * before configuring the divider using the API XMC_SCU_CLOCK_SetWdtClockSource().
1928:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1929:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetWdtClockSource(), XMC_SCU_CLOCK_GetWdtClockDivider() \n\n\n
1930:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1931:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t ratio);
1932:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1933:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1934:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1935:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Ratio between the source of WDT clock and the WDT clock.\n
1936:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 0 to 255.
1937:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1938:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1939:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the ratio between the WDT parent clock and the WDT clock. \n\n
1940:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a WDTDIV bits of \a WDTCLKCR register.
1941:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Ensure that the WDT parent clock is considered before using the value of
1942:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the divider value.
1943:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1944:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetWdtClockSource(), XMC_SCU_CLOCK_SetWdtClockDivider() \n\n\n
1945:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1946:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetWdtClockDivider(void)
1947:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1948:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->WDTCLKCR & SCU_CLK_WDTCLKCR_WDTDIV_Msk) >> SCU_CLK_WDTCLKCR_WDTDIV_Po
1949:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1950:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1951:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1952:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1953:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio   Ratio between the external output parent clock selected and the output clock.\n
1954:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 1 to 512.
1955:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1956:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1957:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1958:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1959:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the external output clock by setting the divider value for the parent clock. \n\n
1960:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value will be configured to \a ECKDIV bits of \a EXTCLKCR register.
1961:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The divider value is decremented by 1 before storing it to the bit fields.
1962:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Ensure that the source of external output clock is configured appropriately using the API
1963:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetExternalOutputClockSource().
1964:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1965:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetExternalOutputClockSource(), XMC_SCU_CLOCK_GetExternalOutputClockDivider() \n\n
1966:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1967:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetExternalOutputClockDivider(const uint32_t ratio);
1968:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1969:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1970:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1971:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Ratio between the external output parent clock selected and the output clock.\
1972:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 0 to 511.
1973:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1974:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1975:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the divider value applied on parent clock before the generation of external output cloc
1976:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a EXTDIV bit of \a EXTCLKCR register.
1977:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1978:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetExternalOutputClockSource(), XMC_SCU_CLOCK_SetExternalOutputClockDivider() \n\n
1979:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1980:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetExternalOutputClockDivider(void)
1981:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1982:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->EXTCLKCR & SCU_CLK_EXTCLKCR_ECKDIV_Msk) >> SCU_CLK_EXTCLKCR_ECKDIV_Po
1983:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1984:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1985:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ECAT0)
1986:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1987:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1988:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio   Ratio between the source of ECAT clock and the ECAT clock.\n
1989:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 1 to 4.
1990:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1991:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1992:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1993:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1994:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the ECAT clock by setting the clock divider for the ECAT clock source.\n\n
1995:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is configured to \a ECADIV bits of \a ECATCLKCR register. The value of divider
1996:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * is decremented by 1 before configuring.
1997:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1998:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetECATClockSource(), XMC_SCU_CLOCK_GetECATClockDivider() \n\n\n
1999:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2000:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetECATClockDivider(const uint32_t divider);
2001:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2002:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2003:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2004:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Ratio between the source of ECAT clock and the ECAT clock.\n
2005:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 0 to 3.
2006:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2007:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2008:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the ratio between the ECAT parent clock and the ECAT clock. \n\n
2009:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a ECADIV bits of \a ECATCLKCR register.
2010:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2011:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetECATClockSource(), XMC_SCU_CLOCK_SetECATClockDivider() \n\n\n
2012:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2013:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetECATClockDivider(void)
2014:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
2015:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->ECATCLKCR & SCU_CLK_ECATCLKCR_ECADIV_Msk) >> SCU_CLK_ECATCLKCR_ECADIV
2016:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
2017:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
2018:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2019:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2020:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2021:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
2022:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2023:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2024:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables the high precision oscillator by configuring external crystal mode.\n\n
2025:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API configures \a MODE bits of \a OSCHPCTRL register to 0, there by configuring the 
2026:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * external clock input. 
2027:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2028:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_DisableHighPerformanceOscillator() \n\n\n
2029:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2030:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void);
2031:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2032:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2033:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
2034:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2035:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2036:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables the high precision oscillator by disabling the external oscillator.\n\n
2037:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API configures \a MODE bits of \a OSCHPCTRL register to 1, there by disabling the 
2038:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * external oscillator. 
2039:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2040:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_EnableHighPerformanceOscillator() \n\n\n
2041:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2042:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_DisableHighPerformanceOscillator(void);
2043:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2044:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2045:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2046:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
2047:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2048:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2049:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables ultra low power oscillator(ULP). \n\n
2050:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It enables the hibernate domain, configures the ultra low power oscillator
2051:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * uisng the \a MODE bits of the \a OSCULCTRL register. The \a Mode bits will be
2052:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * reset to 0 to enable the low power oscillator. Mirror register update delays 
2053:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * are handled internally.
2054:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2055:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_DisableLowPowerOscillator() \n\n\n
2056:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2057:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_EnableLowPowerOscillator(void);
2058:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2059:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2060:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2061:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
2062:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2063:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2064:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables ultra low power oscillator.\n\n
2065:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is disabled by setting the \a MODE bits of \a OSCULCTRL register to value 2.
2066:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * By default on power up, the ultra low power osciallator is disabled.
2067:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2068:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_EnableLowPowerOscillator() \n\n\n
2069:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2070:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_DisableLowPowerOscillator(void);
2071:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2072:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2073:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2074:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t   System frequency in Hertz.\n
2075:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            \b Range: clock frequency in Hertz. Range of the value depends on the source clock fr
2076:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            and the configured values of dividers.
2077:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2078:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2079:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the value of system PLL output clock frequency(fPLL).\n\n
2080:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API uses \a N-DIV,  \a P-DIV,  \a K1-DIV,  \a K2-DIV bits information from \a PLLCON1 regist
2081:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * VCOBYP bit information from \a PLLCON0 register. It calculates frequency of system pll clock usi
2082:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If normal Mode : fPLL = (fOSC * N)/(P * K2).
2083:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If prescaler mode: fPLL = fOSC/ K1.
2084:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2085:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetSystemClockSource() \n\n\n
2086:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2087:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_CLOCK_GetSystemPllClockFrequency(void);
2088:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2089:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2090:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2091:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Source clock used for deriving system clock.\n
2092:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: fOHP frequency if external high precision frequency is used. \n
2093:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    fOFI fast internal clock frequency.
2094:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2095:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2096:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the value of the input clock frequency for deriving the system clock.
2097:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API retrieves frequency of system PLL input clock (fPLLin).
2098:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Based on \a PINSEL bits information from \a PLLCON2 register, the parent clock source is obtaine
2099:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * This bit field specifies if fOHP or fOFI is used for deriving system clock.
2100:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * System clock frequency is obtained by dividing the source clock frequency with different divider
2101:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2102:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetSystemPllClockFrequency() \n\n\n
2103:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2104:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency(void);
2105:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2106:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2107:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2108:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t   USB PLL output clock frequency.
2109:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2110:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2111:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the frequency of USB PLL output clock (fUSBPLL).\n\n
2112:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It obtains the \a VCOBYP bits information from \a USBPLLCON register and decides if USB PLL mode
2113:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If USB PLL mode is used, the USB clock frequency is obtained by dividing the source clock by USB
2114:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The frequency is obtained using following formula:\n
2115:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If Normal Mode : fUSBPLL = (fOSC * N)/(P * 2).\n
2116:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If Prescaler mode: fPLL = fOSC.
2117:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2118:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency() \n\n\n
2119:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2120:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_CLOCK_GetUsbPllClockFrequency(void);
2121:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2122:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2123:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2124:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t   System clock frequency in Hertz.
2125:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2126:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2127:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the frequency of system clock (fSYS).\n\n
2128:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value obtained by dividing \a CPUDIV bits information of \a CPUCLKCR register with SystemCor
2129:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Based on these values, fSYS clock frequency is derived using the following formula:\n
2130:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * fSYS = fCPU << CPUDIV.
2131:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2132:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetUsbPllClockFrequency() \n\n\n
2133:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2134:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetSystemClockFrequency(void)
2135:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 152              	 .loc 1 2135 0
 153              	 .cfi_startproc
 154              	 
 155              	 
 156              	 
 157 0000 80B4     	 push {r7}
 158              	.LCFI12:
 159              	 .cfi_def_cfa_offset 4
 160              	 .cfi_offset 7,-4
 161 0002 00AF     	 add r7,sp,#0
 162              	.LCFI13:
 163              	 .cfi_def_cfa_register 7
2136:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return SystemCoreClock << ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) >> SCU_CLK_CPUCLKCR_
 164              	 .loc 1 2136 0
 165 0004 064B     	 ldr r3,.L15
 166 0006 1A68     	 ldr r2,[r3]
 167 0008 064B     	 ldr r3,.L15+4
 168 000a 1B69     	 ldr r3,[r3,#16]
 169 000c 03F00103 	 and r3,r3,#1
 170 0010 02FA03F3 	 lsl r3,r2,r3
2137:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
 171              	 .loc 1 2137 0
 172 0014 1846     	 mov r0,r3
 173 0016 BD46     	 mov sp,r7
 174              	.LCFI14:
 175              	 .cfi_def_cfa_register 13
 176              	 
 177 0018 5DF8047B 	 ldr r7,[sp],#4
 178              	.LCFI15:
 179              	 .cfi_restore 7
 180              	 .cfi_def_cfa_offset 0
 181 001c 7047     	 bx lr
 182              	.L16:
 183 001e 00BF     	 .align 2
 184              	.L15:
 185 0020 00000000 	 .word SystemCoreClock
 186 0024 00460050 	 .word 1342195200
 187              	 .cfi_endproc
 188              	.LFE143:
 190              	 .section .text.XMC_SCU_CLOCK_GetCpuClockFrequency,"ax",%progbits
 191              	 .align 2
 192              	 .thumb
 193              	 .thumb_func
 195              	XMC_SCU_CLOCK_GetCpuClockFrequency:
 196              	.LFB151:
 197              	 .file 2 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Libraries\\XMCLib\\inc/xmc_scu.h"
   1:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
   2:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @file xmc_scu.h
   3:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @date 2016-01-12
   4:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
   5:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @cond
   6:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  **************************************************************************************************
   7:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * XMClib v2.1.6 - XMC Peripheral Driver Library 
   8:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
   9:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  10:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * All rights reserved.                        
  11:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                                             
  12:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * following conditions are met:   
  14:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                                                                              
  15:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  16:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * disclaimer.                        
  17:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * 
  18:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  19:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  20:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * 
  21:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  22:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * products derived from this software without specific prior written permission.                  
  23:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                                                                              
  24:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  31:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                                                                              
  32:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  34:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  **************************************************************************************************
  35:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
  36:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Change History
  37:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * --------------
  38:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
  39:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * 2015-02-20:
  40:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *     - Initial <br>
  41:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
  42:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * 2015-05-20:
  43:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *     - Documentation improved <br>
  44:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *     - XMC_ASSERT() hanging issues have fixed for XMC4 devices. <br>
  45:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
  46:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * 2015-06-20:
  47:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  48:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *     - Removed STATIC_INLINE property for the below APIs and declared as void
  49:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *       XMC_SCU_INTERRUPT_EnableEvent, XMC_SCU_INTERRUPT_DisableEvent,
  50:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *       XMC_SCU_INTERRUPT_TriggerEvent, XMC_SCU_INTERUPT_GetEventStatus,
  51:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *       XMC_SCU_INTERUPT_ClearEventStatus
  52:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
  53:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * 2015-11-30:
  54:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *     - Documentation improved <br>
  55:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *      
  56:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @endcond 
  57:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
  58:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
  59:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** #ifndef XMC_SCU_H
  60:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** #define XMC_SCU_H
  61:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  
  62:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**************************************************************************************************
  63:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * HEADER FILES
  64:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  **************************************************************************************************
  65:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** #include <xmc_common.h>
  66:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
  67:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
  68:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @addtogroup XMClib XMC Peripheral Library
  69:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @{
  70:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
  71:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  
  72:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
  73:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @addtogroup SCU
  74:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @brief System Control Unit(SCU) driver for XMC microcontroller family.
  75:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
  76:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * System control unit is the SoC power, reset and a clock manager with additional responsibility o
  77:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * providing system stability protection and other auxiliary functions.<br>
  78:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * SCU provides the following features,
  79:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Power control
  80:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \if XMC4 
  81:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Hibernate control 
  82:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \endif
  83:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Reset control
  84:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Clock control
  85:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Miscellaneous control(boot mode, system interrupts etc.)<br><br>
  86:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
  87:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The SCU driver is divided in to clock control logic, reset control logic, system interrupt contr
  88:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \if XMC4
  89:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * , hibernate control logic, trap control logic, parity control logic 
  90:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \endif
  91:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * and miscellaneous control logic.<br>
  92:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
  93:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Clock driver features:
  94:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows clock configuration using the structure XMC_SCU_CLOCK_CONFIG_t and API XMC_SCU_CLOCK_I
  95:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \if XMC4
  96:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Provides structure XMC_SCU_CLOCK_SYSPLL_CONFIG_t for configuring the system PLL
  97:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows selection of clock source for system PLL, XMC_SCU_CLOCK_GetSystemPllClockSource()
  98:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Provides APIs for configuring different module clock frequencies XMC_SCU_CLOCK_SetWdtClockDiv
  99:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows selection of clock source for external output, XMC_SCU_CLOCK_SetExternalOutputClockSou
 100:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Provides APIs for enabling external high power oscillator and ultra low power oscillator, XMC
 101:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Provides APIs for getting various clock frequencies XMC_SCU_CLOCK_GetPeripheralClockFrequency
 102:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  XMC_SCU_CLOCK_GetCpuClockFrequency(), XMC_SCU_CLOCK_GetSystemClockFrequency()<br>
 103:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \endif
 104:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \if XMC1
 105:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows selection of peripheral clock frequency, XMC_SCU_CLOCK_SetFastPeripheralClockSource()
 106:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Provides API to get the peripheral clock frequency, XMC_SCU_CLOCK_GetFastPeripheralClockFrequ
 107:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \endif
 108:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 109:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Reset driver features:
 110:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \if XMC4
 111:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows to handle peripheral reset XMC_SCU_RESET_AssertPeripheralReset(), XMC_SCU_RESET_Deasse
 112:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows configuration of NMI generation for selected events, XMC_SCU_INTERRUPT_EnableNmiReques
 113:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \endif
 114:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \if XMC1
 115:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows to trigger device reset XMC_SCU_RESET_AssertMasterReset()
 116:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows to configure multiple sources for reset, XMC_SCU_RESET_EnableResetRequest()
 117:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \endif <br>
 118:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 119:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Interrupt driver features:
 120:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Provides APIs for enabling/ disabling interrupt event generation XMC_SCU_INTERRUPT_EnableEven
 121:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  XMC_SCU_INTERRUPT_DisableEvent()
 122:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Provides API for registering callback function for events XMC_SCU_INTERRUPT_SetEventHandler()
 123:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 124:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \if XMC4
 125:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Hibernate driver features:
 126:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows configuration of hibernate domain XMC_SCU_HIB_EnableHibernateDomain(), XMC_SCU_HIB_Dis
 127:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows selection of standby clock source, XMC_SCU_HIB_SetStandbyClockSource()
 128:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows selection of RTC clock source, XMC_SCU_HIB_SetRtcClockSource()
 129:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Provides API for enabling slow internal clock used for backup clock, XMC_SCU_HIB_EnableIntern
 130:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 131:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Trap driver features:
 132:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows handling of trap XMC_SCU_TRAP_Enable(), XMC_SCU_TRAP_GetStatus(), XMC_SCU_TRAP_Trigger
 133:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 134:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Parity driver features:
 135:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Parity error generated by on-chip RAM can be monitored, XMC_SCU_PARITY_Enable(), XMC_SCU_PARI
 136:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows configuration of trap generation on detection of parity error, XMC_SCU_PARITY_EnableTr
 137:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 138:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Power driver features:
 139:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows to power the USB module XMC_SCU_POWER_EnableUsb(), XMC_SCU_POWER_DisableUsb()
 140:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \endif
 141:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 142:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Miscellaneous features:
 143:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows to trigger multiple capture compare unit(CCU) channels to be started together XMC_SCU_
 144:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \if XMC4
 145:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Enables configuration of out of range comparator (ORC) XMC_SCU_EnableOutOfRangeComparator()
 146:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Enables configuration of die temperature sensor XMC_SCU_EnableTemperatureSensor(), XMC_SCU_Ca
 147:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Enables configuration of device boot mode XMC_SCU_SetBootMode()<br>
 148:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \endif
 149:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \if XMC1
 150:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Enables configuration of die temperature sensor XMC_SCU_StartTempMeasurement(), XMC_SCU_SetRa
 151:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows configuring supply monitor unit using the structure XMC_SCU_SUPPLYMONITOR_t and API XM
 152:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * -# Allows handling of protected bits XMC_SCU_LockProtectedBits(), XMC_SCU_UnlockProtectedBits()<
 153:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  \endif
 154:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @{
 155:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
 156:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  
 157:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**************************************************************************************************
 158:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * MACROS
 159:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  **************************************************************************************************
 160:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 161:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**************************************************************************************************
 162:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * ENUMS
 163:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  **************************************************************************************************
 164:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
 165:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *  Defines the status of SCU API execution, used to verify the SCU related API calls.
 166:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
 167:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** typedef enum XMC_SCU_STATUS 
 168:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** {
 169:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****   XMC_SCU_STATUS_OK   = 0UL, /**< SCU related operation successfully completed.*/
 170:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****   XMC_SCU_STATUS_ERROR,      /**< SCU related operation failed. When API cannot fulfill request, th
 171:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****   XMC_SCU_STATUS_BUSY,       /**< Cannot execute the SCU related operation request because
 172:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****                                   another operation is in progress. \a XMC_SCU_STATUS_BUSY is retur
 173:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****                                   processing another request. */
 174:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** } XMC_SCU_STATUS_t;
 175:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 176:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 177:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**************************************************************************************************
 178:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * DATA TYPES
 179:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  **************************************************************************************************
 180:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 181:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
 182:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Function pointer type used for registering callback functions on SCU event occurrence.
 183:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
 184:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** typedef void (*XMC_SCU_INTERRUPT_EVENT_HANDLER_t)(void);
 185:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 186:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**************************************************************************************************
 187:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * DEVICE EXTENSIONS
 188:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  **************************************************************************************************
 189:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 190:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** #if (UC_FAMILY == XMC1)
 191:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** #include <xmc1_scu.h>
 192:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** #elif (UC_FAMILY == XMC4)
 193:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** #include <xmc4_scu.h>
 194:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** #else
 195:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** #error "Unspecified chipset"
 196:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** #endif
 197:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 198:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**************************************************************************************************
 199:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * API Prototypes
 200:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  **************************************************************************************************
 201:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 202:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** #ifdef __cplusplus
 203:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** extern "C" {
 204:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** #endif
 205:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 206:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 207:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
 208:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 209:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @param trigger    CCU slices to be triggered synchronously via software. The value is a bitmask 
 210:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                    in the register CCUCON. <br>
 211:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                    \b Range: Use type @ref XMC_SCU_CCU_TRIGGER_t for bitmask of individual CCU s
 212:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                    combined using \a OR operation.
 213:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 214:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @return None
 215:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 216:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Description</b><br>
 217:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Generates active edge(low to high) trigger for multiple CCU units at the same time.\n\n
 218:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Before executing this API, all the required CCU timers should configure external start.
 219:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The edge of the start signal should be selected as active edge.
 220:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The input signal for the CCU slice should be selected as SCU input.
 221:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The above mentioned configurations can be made using the CCU LLD API XMC_CCU4_SLICE_StartConfig(
 222:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * CCU timer slice should be started using XMC_CCU4_SLICE_StartTimer() before triggering 
 223:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * the timer using this API.<BR>
 224:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Related APIs:</b><BR>
 225:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * XMC_CCU4_SLICE_StartConfig(), XMC_CCU4_SLICE_SetInput(), XMC_SCU_SetCcuTriggerLow()\n\n\n
 226:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
 227:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** __STATIC_INLINE void XMC_SCU_SetCcuTriggerHigh(const uint32_t trigger)
 228:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** {
 229:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****   SCU_GENERAL->CCUCON |= (uint32_t)trigger;
 230:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** }
 231:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 232:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
 233:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 234:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @param trigger  CCU slices to be triggered synchronously via software. The value is a bitmask of
 235:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                    in the register CCUCON. <br>
 236:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                    \b Range: Use type @ref XMC_SCU_CCU_TRIGGER_t for bitmask of individual CCU s
 237:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                    combined using \a OR operation.
 238:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 239:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @return None
 240:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 241:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Description</b><br>
 242:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Generates passive edge(high to low) trigger for multiple CCU units at the same time.\n\n
 243:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Before executing this API, all the required CCU timers should configure external start.
 244:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The edge of the start signal should be selected as passive edge.
 245:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The input signal for the CCU slice should be selected as SCU input.
 246:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The above mentioned configurations can be made using the CCU LLD API XMC_CCU4_SLICE_StartConfig(
 247:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * CCU timer slice should be started using XMC_CCU4_SLICE_StartTimer() before triggering 
 248:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * the timer using this API.<BR>
 249:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Related APIs:</b><BR>
 250:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * XMC_CCU4_SLICE_StartConfig(), XMC_CCU4_SLICE_SetInput(), XMC_SCU_SetCcuTriggerHigh()\n\n\n
 251:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
 252:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** __STATIC_INLINE void XMC_SCU_SetCcuTriggerLow(const uint32_t trigger)
 253:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** {
 254:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****   SCU_GENERAL->CCUCON &= (uint32_t)~trigger;
 255:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** }
 256:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 257:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
 258:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 259:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @param config Pointer to structure holding the clock prescaler values and divider values for 
 260:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                configuring clock generators and clock tree.\n
 261:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                \b Range: Configure the members of structure @ref XMC_SCU_CLOCK_CONFIG_t for vari
 262:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                parameters of clock setup.
 263:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 264:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @return None
 265:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 266:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Description</b><br>
 267:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Initializes clock generators and clock tree.\n\n
 268:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \if XMC1
 269:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Peripheral clock and system clock are configured based on the input configuration \a config.
 270:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The system clock frequency is tuned by configuring the FDIV and IDIV values of CLKCR register.
 271:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The values of FDIV and IDIV can be provided as part of input configuration.
 272:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The PCLK divider determines the ratio of peripheral clock to the system clock. 
 273:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The source of RTC clock is set based on the input configuration. 
 274:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \a SystemCoreClock variable will be updated with the value of
 275:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * system clock frequency. Access to protected bit fields are handled internally.
 276:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \endif
 277:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \if XMC4
 278:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Enables the high precision oscillator(fOHP) input and configures the system and peripheral clock
 279:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Based on the system clock source selected in \a config, either fPLL or fOFI will be chosen as sy
 280:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Based on PLL mode(normal or prescaler mode) used, PLL ramps up in steps to achieve target freque
 281:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The clock dividers for CPU, CCU and peripheral clocks will be set based on the input configurati
 282:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The \a SystemCoreClock variable is set with the value of system clock frequency.
 283:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \endif
 284:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Related APIs:</b><BR>
 285:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * XMC_SCU_CLOCK_GetPeripheralClockFrequency(), XMC_SCU_CLOCK_GetCpuClockFrequency() \n\n\n
 286:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
 287:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config);
 288:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 289:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
 290:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 291:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @param event  Bit mask of the event to enable. \b Range: Use type @ref XMC_SCU_INTERRUPT_EVENT_t
 292:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                for providing the input value. Multiple events can be combined using the \a OR op
 293:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 294:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @return None
 295:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 296:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Description</b><br>
 297:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Enables the generation of interrupt for the input events.\n\n
 298:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The events are enabled by setting the respective bit fields in the SRMSK register. \n
 299:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Note: User should separately enable the NVIC node responsible for handling the SCU interrupt.
 300:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The interrupt will be generated when the respective event occurs.
 301:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Related APIs:</b><BR>
 302:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * NVIC_EnableIRQ(), XMC_SCU_INTERRUPT_DisableEvent()\n\n\n
 303:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
 304:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** void XMC_SCU_INTERRUPT_EnableEvent(const XMC_SCU_INTERRUPT_EVENT_t event);
 305:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 306:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 307:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
 308:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 309:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @param event  Bit mask of the event to disable. \b Range: Use type @ref XMC_SCU_INTERRUPT_EVENT_
 310:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                for providing the input value. Multiple events can be combined using the \a OR op
 311:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 312:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @return None
 313:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 314:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Description</b><br>
 315:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Disables generation of interrupt on occurrence of the input event.\n\n
 316:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The events are disabled by resetting the respective bit fields in the SRMSK register. \n
 317:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Related APIs:</b><BR>
 318:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * NVIC_DisableIRQ(), XMC_SCU_INTERRUPT_EnableEvent()\n\n\n
 319:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
 320:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** void XMC_SCU_INTERRUPT_DisableEvent(const XMC_SCU_INTERRUPT_EVENT_t event);
 321:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 322:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
 323:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 324:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @param event Bit mask of the event to be triggered. \b Range: Use type @ref XMC_SCU_INTERRUPT_EV
 325:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                for providing the input value. Multiple events can be combined using the \a OR op
 326:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 327:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @return None
 328:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 329:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Description</b><br>
 330:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Triggers the event as if the hardware raised it.\n\n
 331:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Event will be triggered by setting the respective bitfield in the SRSET register.\n
 332:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Note: User should enable the NVIC node that handles the respective event for interrupt generatio
 333:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Related APIs:</b><BR>
 334:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * NVIC_EnableIRQ(), XMC_SCU_INTERUPT_GetEventStatus(), XMC_SCU_INTERRUPT_ClearEventStatus() \n\n\n
 335:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
 336:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** void XMC_SCU_INTERRUPT_TriggerEvent(const XMC_SCU_INTERRUPT_EVENT_t  event);
 337:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 338:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
 339:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @return uint32_t  Status of the SCU events.
 340:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 341:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Description</b><br>
 342:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Provides the status of all SCU events.\n\n
 343:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The status is read from the SRRAW register. To check the status of a particular 
 344:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * event, the returned value should be masked with the bit mask of the event. The bitmask
 345:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * of events can be obtained using the type @ref XMC_SCU_INTERRUPT_EVENT_t. Multiple events'
 346:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * status can be checked by combining the bit masks using \a OR operation. 
 347:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * After detecting the event, the event status should be cleared using software to detect the event
 348:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Related APIs:</b><BR>
 349:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * XMC_SCU_INTERRUPT_ClearEventStatus(), XMC_SCU_INTERRUPT_TriggerEvent(), XMC_SCU_INTERRUPT_SetEve
 350:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
 351:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** XMC_SCU_INTERRUPT_EVENT_t XMC_SCU_INTERUPT_GetEventStatus(void);
 352:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 353:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
 354:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 355:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @param event  Bit mask of the events to clear. \b Range: Use type @ref XMC_SCU_INTERRUPT_EVENT_t
 356:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *                for providing the input value. Multiple events can be combined using the \a OR op
 357:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 358:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @return None
 359:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 360:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Description</b><br>
 361:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Clears the event status bit in SRRAW register.\n\n
 362:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The events are cleared by writing value 1 to their bit positions in the SRCLR register.
 363:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The API can be used when polling method is used. After detecting the event, the event status
 364:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * should be cleared using software to detect the event again.
 365:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 366:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Related APIs:</b><BR>
 367:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * XMC_SCU_INTERUPT_GetEventStatus(), XMC_SCU_INTERRUPT_TriggerEvent() \n\n\n
 368:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
 369:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** void XMC_SCU_INTERRUPT_ClearEventStatus(const XMC_SCU_INTERRUPT_EVENT_t event);
 370:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** 
 371:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
 372:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 373:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @return uint32_t  Status representing the reason for device reset.
 374:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 375:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Description</b><br>
 376:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Provides the value representing the reason for device reset.\n\n
 377:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The return value is an encoded word, which can indicate multiple reasons for the last reset. Eac
 378:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * returned word is representative of a last reset cause. The returned value should be appropriatel
 379:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * the cause of reset. 
 380:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The cause of the last reset gets automatically stored in 
 381:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * the \a SCU_RSTSTAT register. The reset status shall be reset after each
 382:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * startup in order to ensure consistent source indication after the next reset.
 383:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \b Range: The type @ref XMC_SCU_RESET_REASON_t can be used to get the bit masks of the reset cau
 384:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 385:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Related APIs:</b><BR>
 386:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * XMC_SCU_RESET_ClearDeviceResetReason() \n\n\n
 387:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
 388:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_RESET_GetDeviceResetReason(void)
 389:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** {
 390:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****   return ((SCU_RESET->RSTSTAT) & SCU_RESET_RSTSTAT_RSTSTAT_Msk);
 391:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** }
 392:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
 393:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @return None 
 394:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 395:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Description</b><br>
 396:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Clears the reset reason bits in the reset status register. \n\n
 397:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Clearing of the reset status information in the \a SCU_RSTSTAT register via register bit \a RSTC
 398:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * recommended to ensure a clear indication of the cause of next reset.
 399:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 400:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Related APIs:</b><BR>
 401:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * XMC_SCU_RESET_GetDeviceResetReason() \n\n\n
 402:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
 403:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** __STATIC_INLINE void XMC_SCU_RESET_ClearDeviceResetReason(void)
 404:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** {
 405:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****   /* Clear RSTSTAT.RSTSTAT bitfield */
 406:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****   SCU_RESET->RSTCLR |= (uint32_t)SCU_RESET_RSTCLR_RSCLR_Msk;
 407:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** }
 408:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  
 409:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** /**
 410:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * @return uint32_t  Value of CPU clock frequency.
 411:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 412:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Description</b><br>
 413:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * Provides the vlaue of CPU clock frequency.\n\n
 414:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The value is stored in a global variable \a \b SystemCoreClock.
 415:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * It is updated when the clock configuration is done using the SCU LLD APIs.
 416:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * The value represents the frequency of clock used for CPU operation.
 417:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \b Range: Value is of type uint32_t, and gives the value of frequency in Hertz.
 418:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  *
 419:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * \par<b>Related APIs:</b><BR>
 420:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  * XMC_SCU_CLOCK_GetPeripheralClockFrequency(), XMC_SCU_CLOCK_GatePeripheralClock() \n\n\n
 421:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****  */
 422:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetCpuClockFrequency(void)
 423:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** {
 198              	 .loc 2 423 0
 199              	 .cfi_startproc
 200              	 
 201              	 
 202              	 
 203 0000 80B4     	 push {r7}
 204              	.LCFI16:
 205              	 .cfi_def_cfa_offset 4
 206              	 .cfi_offset 7,-4
 207 0002 00AF     	 add r7,sp,#0
 208              	.LCFI17:
 209              	 .cfi_def_cfa_register 7
 424:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h ****   return SystemCoreClock;
 210              	 .loc 2 424 0
 211 0004 034B     	 ldr r3,.L19
 212 0006 1B68     	 ldr r3,[r3]
 425:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_scu.h **** }
 213              	 .loc 2 425 0
 214 0008 1846     	 mov r0,r3
 215 000a BD46     	 mov sp,r7
 216              	.LCFI18:
 217              	 .cfi_def_cfa_register 13
 218              	 
 219 000c 5DF8047B 	 ldr r7,[sp],#4
 220              	.LCFI19:
 221              	 .cfi_restore 7
 222              	 .cfi_def_cfa_offset 0
 223 0010 7047     	 bx lr
 224              	.L20:
 225 0012 00BF     	 .align 2
 226              	.L19:
 227 0014 00000000 	 .word SystemCoreClock
 228              	 .cfi_endproc
 229              	.LFE151:
 231              	 .comm event_handler_list,128,4
 232              	 .section .text.XMC_SCU_lDelay,"ax",%progbits
 233              	 .align 2
 234              	 .thumb
 235              	 .thumb_func
 237              	XMC_SCU_lDelay:
 238              	.LFB153:
 239              	 .file 3 "../Libraries/XMCLib/src/xmc4_scu.c"
   1:../Libraries/XMCLib/src/xmc4_scu.c **** /**
   2:../Libraries/XMCLib/src/xmc4_scu.c ****  * @file xmc4_scu.c
   3:../Libraries/XMCLib/src/xmc4_scu.c ****  * @date 2016-01-12
   4:../Libraries/XMCLib/src/xmc4_scu.c ****  *
   5:../Libraries/XMCLib/src/xmc4_scu.c ****  * @cond
   6:../Libraries/XMCLib/src/xmc4_scu.c ****  **************************************************************************************************
   7:../Libraries/XMCLib/src/xmc4_scu.c ****  * XMClib v2.1.6 - XMC Peripheral Driver Library 
   8:../Libraries/XMCLib/src/xmc4_scu.c ****  *
   9:../Libraries/XMCLib/src/xmc4_scu.c ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  10:../Libraries/XMCLib/src/xmc4_scu.c ****  * All rights reserved.                        
  11:../Libraries/XMCLib/src/xmc4_scu.c ****  *                                             
  12:../Libraries/XMCLib/src/xmc4_scu.c ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:../Libraries/XMCLib/src/xmc4_scu.c ****  * following conditions are met:   
  14:../Libraries/XMCLib/src/xmc4_scu.c ****  *                                                                              
  15:../Libraries/XMCLib/src/xmc4_scu.c ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  16:../Libraries/XMCLib/src/xmc4_scu.c ****  * disclaimer.                        
  17:../Libraries/XMCLib/src/xmc4_scu.c ****  * 
  18:../Libraries/XMCLib/src/xmc4_scu.c ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  19:../Libraries/XMCLib/src/xmc4_scu.c ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  20:../Libraries/XMCLib/src/xmc4_scu.c ****  * 
  21:../Libraries/XMCLib/src/xmc4_scu.c ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  22:../Libraries/XMCLib/src/xmc4_scu.c ****  * products derived from this software without specific prior written permission.                  
  23:../Libraries/XMCLib/src/xmc4_scu.c ****  *                                                                              
  24:../Libraries/XMCLib/src/xmc4_scu.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:../Libraries/XMCLib/src/xmc4_scu.c ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:../Libraries/XMCLib/src/xmc4_scu.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:../Libraries/XMCLib/src/xmc4_scu.c ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:../Libraries/XMCLib/src/xmc4_scu.c ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:../Libraries/XMCLib/src/xmc4_scu.c ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:../Libraries/XMCLib/src/xmc4_scu.c ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  31:../Libraries/XMCLib/src/xmc4_scu.c ****  *                                                                              
  32:../Libraries/XMCLib/src/xmc4_scu.c ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:../Libraries/XMCLib/src/xmc4_scu.c ****  * Infineon Technologies AG dave@infineon.com).                                                    
  34:../Libraries/XMCLib/src/xmc4_scu.c ****  **************************************************************************************************
  35:../Libraries/XMCLib/src/xmc4_scu.c ****  *
  36:../Libraries/XMCLib/src/xmc4_scu.c ****  * Change History
  37:../Libraries/XMCLib/src/xmc4_scu.c ****  * --------------
  38:../Libraries/XMCLib/src/xmc4_scu.c ****  *
  39:../Libraries/XMCLib/src/xmc4_scu.c ****  * 2015-02-20:
  40:../Libraries/XMCLib/src/xmc4_scu.c ****  *     - Initial <br>
  41:../Libraries/XMCLib/src/xmc4_scu.c ****  *      
  42:../Libraries/XMCLib/src/xmc4_scu.c ****  * 2015-05-20:
  43:../Libraries/XMCLib/src/xmc4_scu.c ****  *     - XMC_ASSERT() hanging issues have fixed.  <br>
  44:../Libraries/XMCLib/src/xmc4_scu.c ****  *     - Line indentation aligned with 120 characters. <br>
  45:../Libraries/XMCLib/src/xmc4_scu.c ****  *     
  46:../Libraries/XMCLib/src/xmc4_scu.c ****  * 2015-06-20:
  47:../Libraries/XMCLib/src/xmc4_scu.c ****  *     - XMC_SCU_INTERRUPT_EnableEvent,XMC_SCU_INTERRUPT_DisableEvent,
  48:../Libraries/XMCLib/src/xmc4_scu.c ****  *     - XMC_SCU_INTERRUPT_TriggerEvent,XMC_SCU_INTERUPT_GetEventStatus,
  49:../Libraries/XMCLib/src/xmc4_scu.c ****  *     - XMC_SCU_INTERRUPT_ClearEventStatus are added
  50:../Libraries/XMCLib/src/xmc4_scu.c ****  *     - Added Weak implementation for OSCHP_GetFrequency()
  51:../Libraries/XMCLib/src/xmc4_scu.c ****  *
  52:../Libraries/XMCLib/src/xmc4_scu.c ****  * 2015-11-30:
  53:../Libraries/XMCLib/src/xmc4_scu.c ****  *     - Documentation improved <br>
  54:../Libraries/XMCLib/src/xmc4_scu.c ****  *     - Following API functionalities are improved
  55:../Libraries/XMCLib/src/xmc4_scu.c ****  *       XMC_SCU_CLOCK_GatePeripheralClock, XMC_SCU_CLOCK_UngatePeripheralClock, XMC_SCU_CLOCK_IsPe
  56:../Libraries/XMCLib/src/xmc4_scu.c ****  *       XMC_SCU_RESET_AssertPeripheralReset, XMC_SCU_RESET_DeassertPeripheralReset, XMC_SCU_RESET_
  57:../Libraries/XMCLib/src/xmc4_scu.c ****  * 2015-12-08:
  58:../Libraries/XMCLib/src/xmc4_scu.c ****  *     - XMC_SCU_GetTemperature renamed to XMC_SCU_GetTemperatureMeasurement
  59:../Libraries/XMCLib/src/xmc4_scu.c ****  <br>
  60:../Libraries/XMCLib/src/xmc4_scu.c ****  *
  61:../Libraries/XMCLib/src/xmc4_scu.c ****  * @endcond 
  62:../Libraries/XMCLib/src/xmc4_scu.c ****  *
  63:../Libraries/XMCLib/src/xmc4_scu.c ****  */
  64:../Libraries/XMCLib/src/xmc4_scu.c **** 
  65:../Libraries/XMCLib/src/xmc4_scu.c **** /**
  66:../Libraries/XMCLib/src/xmc4_scu.c ****  *
  67:../Libraries/XMCLib/src/xmc4_scu.c ****  * @brief SCU low level driver API prototype definition for XMC4 family of microcontrollers. 
  68:../Libraries/XMCLib/src/xmc4_scu.c ****  *
  69:../Libraries/XMCLib/src/xmc4_scu.c ****  * <b>Detailed description of file:</b> <br>
  70:../Libraries/XMCLib/src/xmc4_scu.c ****  * APIs provided in this file cover the following functional blocks of SCU: <br>
  71:../Libraries/XMCLib/src/xmc4_scu.c ****  * -- GCU (APIs prefixed with XMC_SCU_GEN_) <br>
  72:../Libraries/XMCLib/src/xmc4_scu.c ****  * ------ Temperature Monitoring, Bootmode selection, CCU Start, Comparator configuration etc  <br>
  73:../Libraries/XMCLib/src/xmc4_scu.c ****  * -- CCU (APIs prefixed with XMC_SCU_CLOCK_) <br>
  74:../Libraries/XMCLib/src/xmc4_scu.c ****  * ------ Clock sources init, Clock tree init, Clock gating, Sleep Management etc <br>
  75:../Libraries/XMCLib/src/xmc4_scu.c ****  * -- RCU (APIs prefixed with XMC_SCU_RESET_) <br>
  76:../Libraries/XMCLib/src/xmc4_scu.c ****  * ------ Reset Init, Cause, Manual Reset Assert/Deassert <br>
  77:../Libraries/XMCLib/src/xmc4_scu.c ****  * -- INTERRUPT (APIs prefixed with XMC_SCU_INTERRUPT_) <br>
  78:../Libraries/XMCLib/src/xmc4_scu.c ****  * ------ Init, Manual Assert/Deassert, Acknowledge etc <br>
  79:../Libraries/XMCLib/src/xmc4_scu.c ****  * -- PARITY (APIs prefixed with XMC_SCU_PARITY_) <br>
  80:../Libraries/XMCLib/src/xmc4_scu.c ****  * ------ Init, Acknowledge etc <br>
  81:../Libraries/XMCLib/src/xmc4_scu.c ****  * -- HIBERNATION (APIs prefixed with XMC_SCU_HIB_) <br>
  82:../Libraries/XMCLib/src/xmc4_scu.c ****  * ------ Hibernation entry/exit config, entry/wakeup sequences, LPAC configuration etc <br>
  83:../Libraries/XMCLib/src/xmc4_scu.c ****  * -- TRAP (APIs prefixed with XMC_SCU_TRAP_) <br>
  84:../Libraries/XMCLib/src/xmc4_scu.c ****  * ------ Init, Enable/Disable, Acknowledge etc <br>
  85:../Libraries/XMCLib/src/xmc4_scu.c ****  *
  86:../Libraries/XMCLib/src/xmc4_scu.c ****  */
  87:../Libraries/XMCLib/src/xmc4_scu.c **** 
  88:../Libraries/XMCLib/src/xmc4_scu.c **** /**************************************************************************************************
  89:../Libraries/XMCLib/src/xmc4_scu.c ****  * HEADER FILES
  90:../Libraries/XMCLib/src/xmc4_scu.c ****  **************************************************************************************************
  91:../Libraries/XMCLib/src/xmc4_scu.c **** #include <xmc_scu.h>
  92:../Libraries/XMCLib/src/xmc4_scu.c **** 
  93:../Libraries/XMCLib/src/xmc4_scu.c **** #if UC_FAMILY == XMC4
  94:../Libraries/XMCLib/src/xmc4_scu.c **** 
  95:../Libraries/XMCLib/src/xmc4_scu.c **** /**************************************************************************************************
  96:../Libraries/XMCLib/src/xmc4_scu.c ****  * MACROS
  97:../Libraries/XMCLib/src/xmc4_scu.c ****  **************************************************************************************************
  98:../Libraries/XMCLib/src/xmc4_scu.c **** #define FOSCREF   (2500000UL)    /**< Oscillator reference frequency (fOSCREF) monitored by Oscilla
  99:../Libraries/XMCLib/src/xmc4_scu.c **** #define FREQ_1MHZ (1000000UL)    /**< Used during calculation. */
 100:../Libraries/XMCLib/src/xmc4_scu.c **** 
 101:../Libraries/XMCLib/src/xmc4_scu.c **** #ifndef OFI_FREQUENCY
 102:../Libraries/XMCLib/src/xmc4_scu.c **** #define OFI_FREQUENCY (24000000UL)    /**< Fast internal backup clock source. */
 103:../Libraries/XMCLib/src/xmc4_scu.c **** #endif
 104:../Libraries/XMCLib/src/xmc4_scu.c **** 
 105:../Libraries/XMCLib/src/xmc4_scu.c **** #ifndef OSI_FREQUENCY
 106:../Libraries/XMCLib/src/xmc4_scu.c **** #define OSI_FREQUENCY (32768UL)    /**< Internal slow clock source. */
 107:../Libraries/XMCLib/src/xmc4_scu.c **** #endif
 108:../Libraries/XMCLib/src/xmc4_scu.c **** 
 109:../Libraries/XMCLib/src/xmc4_scu.c **** #ifndef OSCHP_FREQUENCY
 110:../Libraries/XMCLib/src/xmc4_scu.c **** #define OSCHP_FREQUENCY (12000000U)    /**< External crystal High Precision Oscillator. */
 111:../Libraries/XMCLib/src/xmc4_scu.c **** #endif
 112:../Libraries/XMCLib/src/xmc4_scu.c **** 
 113:../Libraries/XMCLib/src/xmc4_scu.c **** #define XMC_SCU_PLL_PLLSTAT_OSC_USABLE  (SCU_PLL_PLLSTAT_PLLHV_Msk | \
 114:../Libraries/XMCLib/src/xmc4_scu.c ****                                          SCU_PLL_PLLSTAT_PLLLV_Msk | \
 115:../Libraries/XMCLib/src/xmc4_scu.c ****                                          SCU_PLL_PLLSTAT_PLLSP_Msk)  /**< Used to verify the OSC fr
 116:../Libraries/XMCLib/src/xmc4_scu.c ****                                                                           usable or not.*/
 117:../Libraries/XMCLib/src/xmc4_scu.c **** 
 118:../Libraries/XMCLib/src/xmc4_scu.c **** #define XMC_SCU_ORC_ADC_START_GROUP    (0UL)    /**< The ADC group whose channel input is compared 
 119:../Libraries/XMCLib/src/xmc4_scu.c ****                                                      Comparator (ORC) to serves the purpose of over
 120:../Libraries/XMCLib/src/xmc4_scu.c ****                                                      for analog input pins of the chip and ORC star
 121:../Libraries/XMCLib/src/xmc4_scu.c ****                                                      this group number. */
 122:../Libraries/XMCLib/src/xmc4_scu.c **** #define XMC_SCU_ORC_ADC_END_GROUP      (1UL)    /**< The ADC group whose channel input is compared 
 123:../Libraries/XMCLib/src/xmc4_scu.c ****                                                      Comparator (ORC) to serves the purpose of over
 124:../Libraries/XMCLib/src/xmc4_scu.c ****                                                      for analog input pins of the chip and ORC end 
 125:../Libraries/XMCLib/src/xmc4_scu.c ****                                                      this group number. */
 126:../Libraries/XMCLib/src/xmc4_scu.c **** #define XMC_SCU_ORC_START_ADC_CHANNEL  (6UL)    /**< The ADC channel whose channel input is compare
 127:../Libraries/XMCLib/src/xmc4_scu.c ****                                                      Comparator (ORC) to serves the purpose of over
 128:../Libraries/XMCLib/src/xmc4_scu.c ****                                                      for analog input pins of the chip and ORC star
 129:../Libraries/XMCLib/src/xmc4_scu.c ****                                                      this channel number. */
 130:../Libraries/XMCLib/src/xmc4_scu.c **** #define XMC_SCU_ORC_END_ADC_CHANNEL    (7UL)    /**< The ADC channel whose channel input is compare
 131:../Libraries/XMCLib/src/xmc4_scu.c ****                                                      Comparator (ORC) to serves the purpose of over
 132:../Libraries/XMCLib/src/xmc4_scu.c ****                                                      for analog input pins of the chip and ORC ends
 133:../Libraries/XMCLib/src/xmc4_scu.c ****                                                      this channel number. */
 134:../Libraries/XMCLib/src/xmc4_scu.c **** 
 135:../Libraries/XMCLib/src/xmc4_scu.c **** #define XMC_SCU_CHECK_GRPNUM(GROUP_NUM)   (((GROUP_NUM) == XMC_SCU_ORC_ADC_START_GROUP) || \
 136:../Libraries/XMCLib/src/xmc4_scu.c ****                                         ((GROUP_NUM) == XMC_SCU_ORC_ADC_END_GROUP) ) /**< Used to v
 137:../Libraries/XMCLib/src/xmc4_scu.c ****                                                                                       provided ADC 
 138:../Libraries/XMCLib/src/xmc4_scu.c ****                                                                                       within specif
 139:../Libraries/XMCLib/src/xmc4_scu.c ****                                                                                       end group num
 140:../Libraries/XMCLib/src/xmc4_scu.c ****                                         
 141:../Libraries/XMCLib/src/xmc4_scu.c **** #define XMC_SCU_CHECK_CHNUM(CH_NUM)       (((CH_NUM) == XMC_SCU_ORC_START_ADC_CHANNEL) || \
 142:../Libraries/XMCLib/src/xmc4_scu.c ****                                         ((CH_NUM) == XMC_SCU_ORC_END_ADC_CHANNEL) )  /**< Used to v
 143:../Libraries/XMCLib/src/xmc4_scu.c ****                                                                                       provided ADC 
 144:../Libraries/XMCLib/src/xmc4_scu.c ****                                                                                       within specif
 145:../Libraries/XMCLib/src/xmc4_scu.c ****                                                                                       end channel n
 146:../Libraries/XMCLib/src/xmc4_scu.c **** 
 147:../Libraries/XMCLib/src/xmc4_scu.c **** #define XMC_SCU_INTERRUPT_EVENT_MAX            (32U)      /**< Maximum supported SCU events. */
 148:../Libraries/XMCLib/src/xmc4_scu.c **** 
 149:../Libraries/XMCLib/src/xmc4_scu.c **** /**************************************************************************************************
 150:../Libraries/XMCLib/src/xmc4_scu.c ****  * LOCAL DATA
 151:../Libraries/XMCLib/src/xmc4_scu.c ****  **************************************************************************************************
 152:../Libraries/XMCLib/src/xmc4_scu.c **** XMC_SCU_INTERRUPT_EVENT_HANDLER_t event_handler_list[XMC_SCU_INTERRUPT_EVENT_MAX]; /**< For registe
 153:../Libraries/XMCLib/src/xmc4_scu.c ****                                                                                         functions o
 154:../Libraries/XMCLib/src/xmc4_scu.c ****                                                                                         occurrence.
 155:../Libraries/XMCLib/src/xmc4_scu.c **** 
 156:../Libraries/XMCLib/src/xmc4_scu.c **** /**************************************************************************************************
 157:../Libraries/XMCLib/src/xmc4_scu.c ****  * LOCAL ROUTINES
 158:../Libraries/XMCLib/src/xmc4_scu.c ****  **************************************************************************************************
 159:../Libraries/XMCLib/src/xmc4_scu.c ****  #if defined(UC_ID)
 160:../Libraries/XMCLib/src/xmc4_scu.c **** /* This is a non-weak function, which retrieves high precision external oscillator frequency. */
 161:../Libraries/XMCLib/src/xmc4_scu.c **** __WEAK uint32_t OSCHP_GetFrequency(void)
 162:../Libraries/XMCLib/src/xmc4_scu.c **** {
 163:../Libraries/XMCLib/src/xmc4_scu.c ****   return (OSCHP_FREQUENCY);
 164:../Libraries/XMCLib/src/xmc4_scu.c **** }
 165:../Libraries/XMCLib/src/xmc4_scu.c **** #endif
 166:../Libraries/XMCLib/src/xmc4_scu.c **** 
 167:../Libraries/XMCLib/src/xmc4_scu.c **** /* This is a local function used to generate the delay until register get updated with new configur
 168:../Libraries/XMCLib/src/xmc4_scu.c **** static void XMC_SCU_lDelay(uint32_t cycles);
 169:../Libraries/XMCLib/src/xmc4_scu.c **** 
 170:../Libraries/XMCLib/src/xmc4_scu.c **** /**************************************************************************************************
 171:../Libraries/XMCLib/src/xmc4_scu.c ****  * API IMPLEMENTATION
 172:../Libraries/XMCLib/src/xmc4_scu.c ****  **************************************************************************************************
 173:../Libraries/XMCLib/src/xmc4_scu.c **** /* This is a local function used to generate the delay until register get updated with new configur
 174:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_lDelay(uint32_t delay)
 175:../Libraries/XMCLib/src/xmc4_scu.c **** {
 240              	 .loc 3 175 0
 241              	 .cfi_startproc
 242              	 
 243              	 
 244 0000 80B5     	 push {r7,lr}
 245              	.LCFI20:
 246              	 .cfi_def_cfa_offset 8
 247              	 .cfi_offset 7,-8
 248              	 .cfi_offset 14,-4
 249 0002 84B0     	 sub sp,sp,#16
 250              	.LCFI21:
 251              	 .cfi_def_cfa_offset 24
 252 0004 00AF     	 add r7,sp,#0
 253              	.LCFI22:
 254              	 .cfi_def_cfa_register 7
 255 0006 7860     	 str r0,[r7,#4]
 176:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t i;
 177:../Libraries/XMCLib/src/xmc4_scu.c **** 
 178:../Libraries/XMCLib/src/xmc4_scu.c ****   SystemCoreClockUpdate();
 256              	 .loc 3 178 0
 257 0008 FFF7FEFF 	 bl SystemCoreClockUpdate
 179:../Libraries/XMCLib/src/xmc4_scu.c ****   delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 258              	 .loc 3 179 0
 259 000c 0B4B     	 ldr r3,.L24
 260 000e 1B68     	 ldr r3,[r3]
 261 0010 0B4A     	 ldr r2,.L24+4
 262 0012 A2FB0323 	 umull r2,r3,r2,r3
 263 0016 9A0C     	 lsrs r2,r3,#18
 264 0018 7B68     	 ldr r3,[r7,#4]
 265 001a 02FB03F3 	 mul r3,r2,r3
 266 001e 7B60     	 str r3,[r7,#4]
 180:../Libraries/XMCLib/src/xmc4_scu.c **** 
 181:../Libraries/XMCLib/src/xmc4_scu.c ****   for (i = 0U; i < delay; ++i)
 267              	 .loc 3 181 0
 268 0020 0023     	 movs r3,#0
 269 0022 FB60     	 str r3,[r7,#12]
 270 0024 03E0     	 b .L22
 271              	.L23:
 272              	.LBB4:
 273              	.LBB5:
 274              	 .file 4 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode/Libraries/CMSIS/Include/cmsis_gcc.h"
   1:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**************************************************************************//**
   2:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @brief    CMSIS Cortex-M Core Function/Instruction Header File
   4:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @version  V4.30
   5:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @date     20. October 2015
   6:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  ******************************************************************************/
   7:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
   9:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    All rights reserved.
  10:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    Redistribution and use in source and binary forms, with or without
  11:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    modification, are permitted provided that the following conditions are met:
  12:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    - Redistributions of source code must retain the above copyright
  13:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer.
  14:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    - Redistributions in binary form must reproduce the above copyright
  15:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer in the
  16:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****      documentation and/or other materials provided with the distribution.
  17:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****      to endorse or promote products derived from this software without
  19:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****      specific prior written permission.
  20:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    *
  21:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    ---------------------------------------------------------------------------*/
  33:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  34:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  35:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  36:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_H
  37:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  38:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /* ignore some GCC warnings */
  39:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #if defined ( __GNUC__ )
  40:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #pragma GCC diagnostic push
  41:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  42:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  43:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  44:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  45:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  46:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  47:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
  48:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  49:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  50:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   @{
  51:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
  52:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  53:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
  54:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
  55:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
  56:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****            Can only be executed in Privileged modes.
  57:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
  58:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
  59:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
  60:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
  61:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
  62:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  63:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  64:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
  65:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
  66:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  67:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   Can only be executed in Privileged modes.
  68:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
  69:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
  70:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
  71:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
  72:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
  73:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  74:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  75:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
  76:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Control Register
  77:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the content of the Control Register.
  78:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Control Register value
  79:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
  80:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
  81:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
  82:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
  83:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  84:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
  85:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
  86:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
  87:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  88:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  89:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
  90:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Control Register
  91:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Writes the given value to the Control Register.
  92:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    control  Control Register value to set
  93:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
  94:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
  95:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
  96:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
  97:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
  98:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  99:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 100:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 101:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get IPSR Register
 102:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 103:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               IPSR Register value
 104:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 105:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
 106:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 107:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 108:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 109:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 110:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 111:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 112:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 113:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 114:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 115:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get APSR Register
 116:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 117:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               APSR Register value
 118:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 119:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
 120:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 121:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 122:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 123:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 124:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 125:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 126:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 127:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 128:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 129:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get xPSR Register
 130:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 131:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 132:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****     \return               xPSR Register value
 133:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 134:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
 135:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 136:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 137:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 138:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 139:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 140:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 141:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 142:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 143:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 144:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 145:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 146:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               PSP Register value
 147:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 148:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
 149:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 150:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   register uint32_t result;
 151:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 152:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 153:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 154:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 155:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 156:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 157:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 158:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 159:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 160:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 161:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 162:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 163:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 164:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 165:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 166:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 167:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 168:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 169:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 170:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 171:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               MSP Register value
 172:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 173:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
 174:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 175:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   register uint32_t result;
 176:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 177:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 178:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 179:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 180:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 181:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 182:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 183:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 184:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 185:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 186:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 187:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 188:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 189:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 190:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 191:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 192:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 193:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 194:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 195:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Priority Mask
 196:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 197:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Priority Mask value
 198:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 199:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 200:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 201:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 202:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 203:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 204:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 205:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 206:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 207:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 208:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 209:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Priority Mask
 210:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 211:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 212:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 213:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 214:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 215:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 216:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 217:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 218:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 219:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #if       (__CORTEX_M >= 0x03U)
 220:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 221:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 222:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Enable FIQ
 223:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 224:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****            Can only be executed in Privileged modes.
 225:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 226:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
 227:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 228:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 229:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 230:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 231:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 232:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 233:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Disable FIQ
 234:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 235:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****            Can only be executed in Privileged modes.
 236:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 237:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
 238:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 239:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 240:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 241:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 242:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 243:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 244:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Base Priority
 245:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 246:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Base Priority register value
 247:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 248:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 249:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 250:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 251:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 252:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 253:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 254:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 255:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 256:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 257:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 258:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Base Priority
 259:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 260:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 261:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 262:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
 263:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 264:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 265:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 266:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 267:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 268:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 269:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Base Priority with condition
 270:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 271:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 272:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 273:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 274:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
 275:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 276:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
 277:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 278:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 279:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 280:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 281:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Fault Mask
 282:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 283:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Fault Mask register value
 284:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 285:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 286:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 287:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 288:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 289:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 290:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 291:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 292:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 293:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 294:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 295:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Fault Mask
 296:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 297:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 298:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 299:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 300:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 301:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 302:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 303:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 304:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif /* (__CORTEX_M >= 0x03U) */
 305:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 306:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 307:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
 308:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 309:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 310:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get FPSCR
 311:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 312:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 313:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 314:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
 315:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 316:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 317:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 318:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 319:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 320:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("");
 321:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 322:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("");
 323:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 324:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 325:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****    return(0);
 326:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 327:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 328:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 329:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 330:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 331:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set FPSCR
 332:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 333:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 334:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 335:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 336:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 337:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 338:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 339:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("");
 340:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
 341:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("");
 342:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 343:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 344:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 345:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
 346:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 347:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 348:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 349:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 350:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 351:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 352:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 353:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 354:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   Access to dedicated instructions
 355:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   @{
 356:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** */
 357:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 358:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 359:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 360:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 361:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 362:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 363:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 364:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 365:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 366:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 367:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 368:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 369:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 370:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   No Operation
 371:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 372:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 373:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 374:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 375:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("nop");
 275              	 .loc 4 375 0 discriminator 3
 276              	
 277 0026 00BF     	 nop
 278              	
 279              	 .thumb
 280              	.LBE5:
 281              	.LBE4:
 282              	 .loc 3 181 0 discriminator 3
 283 0028 FB68     	 ldr r3,[r7,#12]
 284 002a 0133     	 adds r3,r3,#1
 285 002c FB60     	 str r3,[r7,#12]
 286              	.L22:
 287              	 .loc 3 181 0 is_stmt 0 discriminator 1
 288 002e FA68     	 ldr r2,[r7,#12]
 289 0030 7B68     	 ldr r3,[r7,#4]
 290 0032 9A42     	 cmp r2,r3
 291 0034 F7D3     	 bcc .L23
 182:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 183:../Libraries/XMCLib/src/xmc4_scu.c ****     __NOP();
 184:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 185:../Libraries/XMCLib/src/xmc4_scu.c **** }
 292              	 .loc 3 185 0 is_stmt 1
 293 0036 1037     	 adds r7,r7,#16
 294              	.LCFI23:
 295              	 .cfi_def_cfa_offset 8
 296 0038 BD46     	 mov sp,r7
 297              	.LCFI24:
 298              	 .cfi_def_cfa_register 13
 299              	 
 300 003a 80BD     	 pop {r7,pc}
 301              	.L25:
 302              	 .align 2
 303              	.L24:
 304 003c 00000000 	 .word SystemCoreClock
 305 0040 83DE1B43 	 .word 1125899907
 306              	 .cfi_endproc
 307              	.LFE153:
 309              	 .section .text.XMC_SCU_INTERRUPT_EnableEvent,"ax",%progbits
 310              	 .align 2
 311              	 .global XMC_SCU_INTERRUPT_EnableEvent
 312              	 .thumb
 313              	 .thumb_func
 315              	XMC_SCU_INTERRUPT_EnableEvent:
 316              	.LFB154:
 186:../Libraries/XMCLib/src/xmc4_scu.c **** 
 187:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to enable the SCU event */
 188:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_INTERRUPT_EnableEvent(const XMC_SCU_INTERRUPT_EVENT_t event)
 189:../Libraries/XMCLib/src/xmc4_scu.c **** {
 317              	 .loc 3 189 0
 318              	 .cfi_startproc
 319              	 
 320              	 
 321              	 
 322 0000 80B4     	 push {r7}
 323              	.LCFI25:
 324              	 .cfi_def_cfa_offset 4
 325              	 .cfi_offset 7,-4
 326 0002 83B0     	 sub sp,sp,#12
 327              	.LCFI26:
 328              	 .cfi_def_cfa_offset 16
 329 0004 00AF     	 add r7,sp,#0
 330              	.LCFI27:
 331              	 .cfi_def_cfa_register 7
 332 0006 7860     	 str r0,[r7,#4]
 190:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_INTERRUPT->SRMSK |= (uint32_t)event;
 333              	 .loc 3 190 0
 334 0008 0549     	 ldr r1,.L27
 335 000a 054B     	 ldr r3,.L27
 336 000c 9A68     	 ldr r2,[r3,#8]
 337 000e 7B68     	 ldr r3,[r7,#4]
 338 0010 1343     	 orrs r3,r3,r2
 339 0012 8B60     	 str r3,[r1,#8]
 191:../Libraries/XMCLib/src/xmc4_scu.c **** }
 340              	 .loc 3 191 0
 341 0014 0C37     	 adds r7,r7,#12
 342              	.LCFI28:
 343              	 .cfi_def_cfa_offset 4
 344 0016 BD46     	 mov sp,r7
 345              	.LCFI29:
 346              	 .cfi_def_cfa_register 13
 347              	 
 348 0018 5DF8047B 	 ldr r7,[sp],#4
 349              	.LCFI30:
 350              	 .cfi_restore 7
 351              	 .cfi_def_cfa_offset 0
 352 001c 7047     	 bx lr
 353              	.L28:
 354 001e 00BF     	 .align 2
 355              	.L27:
 356 0020 74400050 	 .word 1342193780
 357              	 .cfi_endproc
 358              	.LFE154:
 360              	 .section .text.XMC_SCU_INTERRUPT_DisableEvent,"ax",%progbits
 361              	 .align 2
 362              	 .global XMC_SCU_INTERRUPT_DisableEvent
 363              	 .thumb
 364              	 .thumb_func
 366              	XMC_SCU_INTERRUPT_DisableEvent:
 367              	.LFB155:
 192:../Libraries/XMCLib/src/xmc4_scu.c **** 
 193:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to disable the SCU event */
 194:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_INTERRUPT_DisableEvent(const XMC_SCU_INTERRUPT_EVENT_t event)
 195:../Libraries/XMCLib/src/xmc4_scu.c **** {
 368              	 .loc 3 195 0
 369              	 .cfi_startproc
 370              	 
 371              	 
 372              	 
 373 0000 80B4     	 push {r7}
 374              	.LCFI31:
 375              	 .cfi_def_cfa_offset 4
 376              	 .cfi_offset 7,-4
 377 0002 83B0     	 sub sp,sp,#12
 378              	.LCFI32:
 379              	 .cfi_def_cfa_offset 16
 380 0004 00AF     	 add r7,sp,#0
 381              	.LCFI33:
 382              	 .cfi_def_cfa_register 7
 383 0006 7860     	 str r0,[r7,#4]
 196:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_INTERRUPT->SRMSK &= (uint32_t)~event;
 384              	 .loc 3 196 0
 385 0008 0549     	 ldr r1,.L30
 386 000a 054B     	 ldr r3,.L30
 387 000c 9A68     	 ldr r2,[r3,#8]
 388 000e 7B68     	 ldr r3,[r7,#4]
 389 0010 DB43     	 mvns r3,r3
 390 0012 1340     	 ands r3,r3,r2
 391 0014 8B60     	 str r3,[r1,#8]
 197:../Libraries/XMCLib/src/xmc4_scu.c **** }
 392              	 .loc 3 197 0
 393 0016 0C37     	 adds r7,r7,#12
 394              	.LCFI34:
 395              	 .cfi_def_cfa_offset 4
 396 0018 BD46     	 mov sp,r7
 397              	.LCFI35:
 398              	 .cfi_def_cfa_register 13
 399              	 
 400 001a 5DF8047B 	 ldr r7,[sp],#4
 401              	.LCFI36:
 402              	 .cfi_restore 7
 403              	 .cfi_def_cfa_offset 0
 404 001e 7047     	 bx lr
 405              	.L31:
 406              	 .align 2
 407              	.L30:
 408 0020 74400050 	 .word 1342193780
 409              	 .cfi_endproc
 410              	.LFE155:
 412              	 .section .text.XMC_SCU_INTERRUPT_TriggerEvent,"ax",%progbits
 413              	 .align 2
 414              	 .global XMC_SCU_INTERRUPT_TriggerEvent
 415              	 .thumb
 416              	 .thumb_func
 418              	XMC_SCU_INTERRUPT_TriggerEvent:
 419              	.LFB156:
 198:../Libraries/XMCLib/src/xmc4_scu.c **** 
 199:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to trigger the SCU event */
 200:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_INTERRUPT_TriggerEvent(const XMC_SCU_INTERRUPT_EVENT_t event)
 201:../Libraries/XMCLib/src/xmc4_scu.c **** {
 420              	 .loc 3 201 0
 421              	 .cfi_startproc
 422              	 
 423              	 
 424              	 
 425 0000 80B4     	 push {r7}
 426              	.LCFI37:
 427              	 .cfi_def_cfa_offset 4
 428              	 .cfi_offset 7,-4
 429 0002 83B0     	 sub sp,sp,#12
 430              	.LCFI38:
 431              	 .cfi_def_cfa_offset 16
 432 0004 00AF     	 add r7,sp,#0
 433              	.LCFI39:
 434              	 .cfi_def_cfa_register 7
 435 0006 7860     	 str r0,[r7,#4]
 202:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_INTERRUPT->SRSET |= (uint32_t)event;
 436              	 .loc 3 202 0
 437 0008 0549     	 ldr r1,.L33
 438 000a 054B     	 ldr r3,.L33
 439 000c 1A69     	 ldr r2,[r3,#16]
 440 000e 7B68     	 ldr r3,[r7,#4]
 441 0010 1343     	 orrs r3,r3,r2
 442 0012 0B61     	 str r3,[r1,#16]
 203:../Libraries/XMCLib/src/xmc4_scu.c **** }
 443              	 .loc 3 203 0
 444 0014 0C37     	 adds r7,r7,#12
 445              	.LCFI40:
 446              	 .cfi_def_cfa_offset 4
 447 0016 BD46     	 mov sp,r7
 448              	.LCFI41:
 449              	 .cfi_def_cfa_register 13
 450              	 
 451 0018 5DF8047B 	 ldr r7,[sp],#4
 452              	.LCFI42:
 453              	 .cfi_restore 7
 454              	 .cfi_def_cfa_offset 0
 455 001c 7047     	 bx lr
 456              	.L34:
 457 001e 00BF     	 .align 2
 458              	.L33:
 459 0020 74400050 	 .word 1342193780
 460              	 .cfi_endproc
 461              	.LFE156:
 463              	 .section .text.XMC_SCU_INTERUPT_GetEventStatus,"ax",%progbits
 464              	 .align 2
 465              	 .global XMC_SCU_INTERUPT_GetEventStatus
 466              	 .thumb
 467              	 .thumb_func
 469              	XMC_SCU_INTERUPT_GetEventStatus:
 470              	.LFB157:
 204:../Libraries/XMCLib/src/xmc4_scu.c **** 
 205:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to retrieve the SCU event status */
 206:../Libraries/XMCLib/src/xmc4_scu.c **** XMC_SCU_INTERRUPT_EVENT_t XMC_SCU_INTERUPT_GetEventStatus(void)
 207:../Libraries/XMCLib/src/xmc4_scu.c **** {
 471              	 .loc 3 207 0
 472              	 .cfi_startproc
 473              	 
 474              	 
 475              	 
 476 0000 80B4     	 push {r7}
 477              	.LCFI43:
 478              	 .cfi_def_cfa_offset 4
 479              	 .cfi_offset 7,-4
 480 0002 00AF     	 add r7,sp,#0
 481              	.LCFI44:
 482              	 .cfi_def_cfa_register 7
 208:../Libraries/XMCLib/src/xmc4_scu.c ****   return (SCU_INTERRUPT->SRRAW);
 483              	 .loc 3 208 0
 484 0004 034B     	 ldr r3,.L37
 485 0006 5B68     	 ldr r3,[r3,#4]
 209:../Libraries/XMCLib/src/xmc4_scu.c **** }
 486              	 .loc 3 209 0
 487 0008 1846     	 mov r0,r3
 488 000a BD46     	 mov sp,r7
 489              	.LCFI45:
 490              	 .cfi_def_cfa_register 13
 491              	 
 492 000c 5DF8047B 	 ldr r7,[sp],#4
 493              	.LCFI46:
 494              	 .cfi_restore 7
 495              	 .cfi_def_cfa_offset 0
 496 0010 7047     	 bx lr
 497              	.L38:
 498 0012 00BF     	 .align 2
 499              	.L37:
 500 0014 74400050 	 .word 1342193780
 501              	 .cfi_endproc
 502              	.LFE157:
 504              	 .section .text.XMC_SCU_INTERRUPT_ClearEventStatus,"ax",%progbits
 505              	 .align 2
 506              	 .global XMC_SCU_INTERRUPT_ClearEventStatus
 507              	 .thumb
 508              	 .thumb_func
 510              	XMC_SCU_INTERRUPT_ClearEventStatus:
 511              	.LFB158:
 210:../Libraries/XMCLib/src/xmc4_scu.c **** 
 211:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to clear the SCU event status */
 212:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_INTERRUPT_ClearEventStatus(const XMC_SCU_INTERRUPT_EVENT_t event)
 213:../Libraries/XMCLib/src/xmc4_scu.c **** {
 512              	 .loc 3 213 0
 513              	 .cfi_startproc
 514              	 
 515              	 
 516              	 
 517 0000 80B4     	 push {r7}
 518              	.LCFI47:
 519              	 .cfi_def_cfa_offset 4
 520              	 .cfi_offset 7,-4
 521 0002 83B0     	 sub sp,sp,#12
 522              	.LCFI48:
 523              	 .cfi_def_cfa_offset 16
 524 0004 00AF     	 add r7,sp,#0
 525              	.LCFI49:
 526              	 .cfi_def_cfa_register 7
 527 0006 7860     	 str r0,[r7,#4]
 214:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_INTERRUPT->SRCLR |= (uint32_t)event;
 528              	 .loc 3 214 0
 529 0008 0549     	 ldr r1,.L40
 530 000a 054B     	 ldr r3,.L40
 531 000c DA68     	 ldr r2,[r3,#12]
 532 000e 7B68     	 ldr r3,[r7,#4]
 533 0010 1343     	 orrs r3,r3,r2
 534 0012 CB60     	 str r3,[r1,#12]
 215:../Libraries/XMCLib/src/xmc4_scu.c **** }
 535              	 .loc 3 215 0
 536 0014 0C37     	 adds r7,r7,#12
 537              	.LCFI50:
 538              	 .cfi_def_cfa_offset 4
 539 0016 BD46     	 mov sp,r7
 540              	.LCFI51:
 541              	 .cfi_def_cfa_register 13
 542              	 
 543 0018 5DF8047B 	 ldr r7,[sp],#4
 544              	.LCFI52:
 545              	 .cfi_restore 7
 546              	 .cfi_def_cfa_offset 0
 547 001c 7047     	 bx lr
 548              	.L41:
 549 001e 00BF     	 .align 2
 550              	.L40:
 551 0020 74400050 	 .word 1342193780
 552              	 .cfi_endproc
 553              	.LFE158:
 555              	 .section .text.XMC_SCU_GetBootMode,"ax",%progbits
 556              	 .align 2
 557              	 .global XMC_SCU_GetBootMode
 558              	 .thumb
 559              	 .thumb_func
 561              	XMC_SCU_GetBootMode:
 562              	.LFB159:
 216:../Libraries/XMCLib/src/xmc4_scu.c **** 
 217:../Libraries/XMCLib/src/xmc4_scu.c **** 
 218:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to retrieve the currently deployed device bootmode */
 219:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_GetBootMode(void)
 220:../Libraries/XMCLib/src/xmc4_scu.c **** {
 563              	 .loc 3 220 0
 564              	 .cfi_startproc
 565              	 
 566              	 
 567              	 
 568 0000 80B4     	 push {r7}
 569              	.LCFI53:
 570              	 .cfi_def_cfa_offset 4
 571              	 .cfi_offset 7,-4
 572 0002 00AF     	 add r7,sp,#0
 573              	.LCFI54:
 574              	 .cfi_def_cfa_register 7
 221:../Libraries/XMCLib/src/xmc4_scu.c ****   return (uint32_t)(SCU_GENERAL->STCON & SCU_GENERAL_STCON_SWCON_Msk);
 575              	 .loc 3 221 0
 576 0004 044B     	 ldr r3,.L44
 577 0006 1B69     	 ldr r3,[r3,#16]
 578 0008 03F47063 	 and r3,r3,#3840
 222:../Libraries/XMCLib/src/xmc4_scu.c **** }
 579              	 .loc 3 222 0
 580 000c 1846     	 mov r0,r3
 581 000e BD46     	 mov sp,r7
 582              	.LCFI55:
 583              	 .cfi_def_cfa_register 13
 584              	 
 585 0010 5DF8047B 	 ldr r7,[sp],#4
 586              	.LCFI56:
 587              	 .cfi_restore 7
 588              	 .cfi_def_cfa_offset 0
 589 0014 7047     	 bx lr
 590              	.L45:
 591 0016 00BF     	 .align 2
 592              	.L44:
 593 0018 00400050 	 .word 1342193664
 594              	 .cfi_endproc
 595              	.LFE159:
 597              	 .section .text.XMC_SCU_SetBootMode,"ax",%progbits
 598              	 .align 2
 599              	 .global XMC_SCU_SetBootMode
 600              	 .thumb
 601              	 .thumb_func
 603              	XMC_SCU_SetBootMode:
 604              	.LFB160:
 223:../Libraries/XMCLib/src/xmc4_scu.c **** 
 224:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to program a new device bootmode */
 225:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_SetBootMode(const XMC_SCU_BOOTMODE_t bootmode)
 226:../Libraries/XMCLib/src/xmc4_scu.c **** {
 605              	 .loc 3 226 0
 606              	 .cfi_startproc
 607              	 
 608              	 
 609              	 
 610 0000 80B4     	 push {r7}
 611              	.LCFI57:
 612              	 .cfi_def_cfa_offset 4
 613              	 .cfi_offset 7,-4
 614 0002 83B0     	 sub sp,sp,#12
 615              	.LCFI58:
 616              	 .cfi_def_cfa_offset 16
 617 0004 00AF     	 add r7,sp,#0
 618              	.LCFI59:
 619              	 .cfi_def_cfa_register 7
 620 0006 0346     	 mov r3,r0
 621 0008 FB80     	 strh r3,[r7,#6]
 227:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->STCON = (uint32_t)bootmode;
 622              	 .loc 3 227 0
 623 000a 044A     	 ldr r2,.L47
 624 000c FB88     	 ldrh r3,[r7,#6]
 625 000e 1361     	 str r3,[r2,#16]
 228:../Libraries/XMCLib/src/xmc4_scu.c **** }
 626              	 .loc 3 228 0
 627 0010 0C37     	 adds r7,r7,#12
 628              	.LCFI60:
 629              	 .cfi_def_cfa_offset 4
 630 0012 BD46     	 mov sp,r7
 631              	.LCFI61:
 632              	 .cfi_def_cfa_register 13
 633              	 
 634 0014 5DF8047B 	 ldr r7,[sp],#4
 635              	.LCFI62:
 636              	 .cfi_restore 7
 637              	 .cfi_def_cfa_offset 0
 638 0018 7047     	 bx lr
 639              	.L48:
 640 001a 00BF     	 .align 2
 641              	.L47:
 642 001c 00400050 	 .word 1342193664
 643              	 .cfi_endproc
 644              	.LFE160:
 646              	 .section .text.XMC_SCU_ReadGPR,"ax",%progbits
 647              	 .align 2
 648              	 .global XMC_SCU_ReadGPR
 649              	 .thumb
 650              	 .thumb_func
 652              	XMC_SCU_ReadGPR:
 653              	.LFB161:
 229:../Libraries/XMCLib/src/xmc4_scu.c **** 
 230:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to read from General purpose register */
 231:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_ReadGPR(const uint32_t index)
 232:../Libraries/XMCLib/src/xmc4_scu.c **** {
 654              	 .loc 3 232 0
 655              	 .cfi_startproc
 656              	 
 657              	 
 658              	 
 659 0000 80B4     	 push {r7}
 660              	.LCFI63:
 661              	 .cfi_def_cfa_offset 4
 662              	 .cfi_offset 7,-4
 663 0002 83B0     	 sub sp,sp,#12
 664              	.LCFI64:
 665              	 .cfi_def_cfa_offset 16
 666 0004 00AF     	 add r7,sp,#0
 667              	.LCFI65:
 668              	 .cfi_def_cfa_register 7
 669 0006 7860     	 str r0,[r7,#4]
 233:../Libraries/XMCLib/src/xmc4_scu.c ****   return (SCU_GENERAL->GPR[index]);
 670              	 .loc 3 233 0
 671 0008 054A     	 ldr r2,.L51
 672 000a 7B68     	 ldr r3,[r7,#4]
 673 000c 0A33     	 adds r3,r3,#10
 674 000e 9B00     	 lsls r3,r3,#2
 675 0010 1344     	 add r3,r3,r2
 676 0012 5B68     	 ldr r3,[r3,#4]
 234:../Libraries/XMCLib/src/xmc4_scu.c **** }
 677              	 .loc 3 234 0
 678 0014 1846     	 mov r0,r3
 679 0016 0C37     	 adds r7,r7,#12
 680              	.LCFI66:
 681              	 .cfi_def_cfa_offset 4
 682 0018 BD46     	 mov sp,r7
 683              	.LCFI67:
 684              	 .cfi_def_cfa_register 13
 685              	 
 686 001a 5DF8047B 	 ldr r7,[sp],#4
 687              	.LCFI68:
 688              	 .cfi_restore 7
 689              	 .cfi_def_cfa_offset 0
 690 001e 7047     	 bx lr
 691              	.L52:
 692              	 .align 2
 693              	.L51:
 694 0020 00400050 	 .word 1342193664
 695              	 .cfi_endproc
 696              	.LFE161:
 698              	 .section .text.XMC_SCU_WriteGPR,"ax",%progbits
 699              	 .align 2
 700              	 .global XMC_SCU_WriteGPR
 701              	 .thumb
 702              	 .thumb_func
 704              	XMC_SCU_WriteGPR:
 705              	.LFB162:
 235:../Libraries/XMCLib/src/xmc4_scu.c **** 
 236:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to write to GPR */
 237:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_WriteGPR(const uint32_t index, const uint32_t data)
 238:../Libraries/XMCLib/src/xmc4_scu.c **** {
 706              	 .loc 3 238 0
 707              	 .cfi_startproc
 708              	 
 709              	 
 710              	 
 711 0000 80B4     	 push {r7}
 712              	.LCFI69:
 713              	 .cfi_def_cfa_offset 4
 714              	 .cfi_offset 7,-4
 715 0002 83B0     	 sub sp,sp,#12
 716              	.LCFI70:
 717              	 .cfi_def_cfa_offset 16
 718 0004 00AF     	 add r7,sp,#0
 719              	.LCFI71:
 720              	 .cfi_def_cfa_register 7
 721 0006 7860     	 str r0,[r7,#4]
 722 0008 3960     	 str r1,[r7]
 239:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->GPR[index] = data;
 723              	 .loc 3 239 0
 724 000a 064A     	 ldr r2,.L54
 725 000c 7B68     	 ldr r3,[r7,#4]
 726 000e 0A33     	 adds r3,r3,#10
 727 0010 9B00     	 lsls r3,r3,#2
 728 0012 1344     	 add r3,r3,r2
 729 0014 3A68     	 ldr r2,[r7]
 730 0016 5A60     	 str r2,[r3,#4]
 240:../Libraries/XMCLib/src/xmc4_scu.c **** }
 731              	 .loc 3 240 0
 732 0018 0C37     	 adds r7,r7,#12
 733              	.LCFI72:
 734              	 .cfi_def_cfa_offset 4
 735 001a BD46     	 mov sp,r7
 736              	.LCFI73:
 737              	 .cfi_def_cfa_register 13
 738              	 
 739 001c 5DF8047B 	 ldr r7,[sp],#4
 740              	.LCFI74:
 741              	 .cfi_restore 7
 742              	 .cfi_def_cfa_offset 0
 743 0020 7047     	 bx lr
 744              	.L55:
 745 0022 00BF     	 .align 2
 746              	.L54:
 747 0024 00400050 	 .word 1342193664
 748              	 .cfi_endproc
 749              	.LFE162:
 751              	 .section .text.XMC_SCU_EnableOutOfRangeComparator,"ax",%progbits
 752              	 .align 2
 753              	 .global XMC_SCU_EnableOutOfRangeComparator
 754              	 .thumb
 755              	 .thumb_func
 757              	XMC_SCU_EnableOutOfRangeComparator:
 758              	.LFB163:
 241:../Libraries/XMCLib/src/xmc4_scu.c **** 
 242:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to enable Out of Range Comparator(ORC) for a desired group and a desired channel input */
 243:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_EnableOutOfRangeComparator(const uint32_t group, const uint32_t channel)
 244:../Libraries/XMCLib/src/xmc4_scu.c **** {
 759              	 .loc 3 244 0
 760              	 .cfi_startproc
 761              	 
 762              	 
 763              	 
 764 0000 80B4     	 push {r7}
 765              	.LCFI75:
 766              	 .cfi_def_cfa_offset 4
 767              	 .cfi_offset 7,-4
 768 0002 83B0     	 sub sp,sp,#12
 769              	.LCFI76:
 770              	 .cfi_def_cfa_offset 16
 771 0004 00AF     	 add r7,sp,#0
 772              	.LCFI77:
 773              	 .cfi_def_cfa_register 7
 774 0006 7860     	 str r0,[r7,#4]
 775 0008 3960     	 str r1,[r7]
 245:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("XMC_SCU_EnableOutOfangeComparator:Wrong Group Number",XMC_SCU_CHECK_GRPNUM(group));
 246:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("XMC_SCU_EnableOutOfangeComparator:Wrong Channel Number",XMC_SCU_CHECK_CHNUM(channel))
 247:../Libraries/XMCLib/src/xmc4_scu.c ****    
 248:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->GORCEN[group] |= (uint32_t)(1UL << channel);
 776              	 .loc 3 248 0
 777 000a 0A49     	 ldr r1,.L57
 778 000c 094A     	 ldr r2,.L57
 779 000e 7B68     	 ldr r3,[r7,#4]
 780 0010 2833     	 adds r3,r3,#40
 781 0012 52F82320 	 ldr r2,[r2,r3,lsl#2]
 782 0016 3B68     	 ldr r3,[r7]
 783 0018 0120     	 movs r0,#1
 784 001a 00FA03F3 	 lsl r3,r0,r3
 785 001e 1A43     	 orrs r2,r2,r3
 786 0020 7B68     	 ldr r3,[r7,#4]
 787 0022 2833     	 adds r3,r3,#40
 788 0024 41F82320 	 str r2,[r1,r3,lsl#2]
 249:../Libraries/XMCLib/src/xmc4_scu.c **** }
 789              	 .loc 3 249 0
 790 0028 0C37     	 adds r7,r7,#12
 791              	.LCFI78:
 792              	 .cfi_def_cfa_offset 4
 793 002a BD46     	 mov sp,r7
 794              	.LCFI79:
 795              	 .cfi_def_cfa_register 13
 796              	 
 797 002c 5DF8047B 	 ldr r7,[sp],#4
 798              	.LCFI80:
 799              	 .cfi_restore 7
 800              	 .cfi_def_cfa_offset 0
 801 0030 7047     	 bx lr
 802              	.L58:
 803 0032 00BF     	 .align 2
 804              	.L57:
 805 0034 00400050 	 .word 1342193664
 806              	 .cfi_endproc
 807              	.LFE163:
 809              	 .section .text.XMC_SCU_DisableOutOfRangeComparator,"ax",%progbits
 810              	 .align 2
 811              	 .global XMC_SCU_DisableOutOfRangeComparator
 812              	 .thumb
 813              	 .thumb_func
 815              	XMC_SCU_DisableOutOfRangeComparator:
 816              	.LFB164:
 250:../Libraries/XMCLib/src/xmc4_scu.c **** 
 251:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to enable Out of Range Comparator(ORC) for a desired group and a desired channel input */
 252:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_DisableOutOfRangeComparator(const uint32_t group, const uint32_t channel)
 253:../Libraries/XMCLib/src/xmc4_scu.c **** {
 817              	 .loc 3 253 0
 818              	 .cfi_startproc
 819              	 
 820              	 
 821              	 
 822 0000 80B4     	 push {r7}
 823              	.LCFI81:
 824              	 .cfi_def_cfa_offset 4
 825              	 .cfi_offset 7,-4
 826 0002 83B0     	 sub sp,sp,#12
 827              	.LCFI82:
 828              	 .cfi_def_cfa_offset 16
 829 0004 00AF     	 add r7,sp,#0
 830              	.LCFI83:
 831              	 .cfi_def_cfa_register 7
 832 0006 7860     	 str r0,[r7,#4]
 833 0008 3960     	 str r1,[r7]
 254:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("XMC_SCU_DisableOutOfRangeComparator:Wrong Group Number",XMC_SCU_CHECK_GRPNUM(group));
 255:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("XMC_SCU_DisableOutOfRangeComparator:Wrong Channel Number",XMC_SCU_CHECK_CHNUM(channel
 256:../Libraries/XMCLib/src/xmc4_scu.c ****    
 257:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->GORCEN[group] &= (uint32_t)~(1UL << channel);
 834              	 .loc 3 257 0
 835 000a 0A49     	 ldr r1,.L60
 836 000c 094A     	 ldr r2,.L60
 837 000e 7B68     	 ldr r3,[r7,#4]
 838 0010 2833     	 adds r3,r3,#40
 839 0012 52F82320 	 ldr r2,[r2,r3,lsl#2]
 840 0016 3B68     	 ldr r3,[r7]
 841 0018 0120     	 movs r0,#1
 842 001a 00FA03F3 	 lsl r3,r0,r3
 843 001e DB43     	 mvns r3,r3
 844 0020 1A40     	 ands r2,r2,r3
 845 0022 7B68     	 ldr r3,[r7,#4]
 846 0024 2833     	 adds r3,r3,#40
 847 0026 41F82320 	 str r2,[r1,r3,lsl#2]
 258:../Libraries/XMCLib/src/xmc4_scu.c **** }
 848              	 .loc 3 258 0
 849 002a 0C37     	 adds r7,r7,#12
 850              	.LCFI84:
 851              	 .cfi_def_cfa_offset 4
 852 002c BD46     	 mov sp,r7
 853              	.LCFI85:
 854              	 .cfi_def_cfa_register 13
 855              	 
 856 002e 5DF8047B 	 ldr r7,[sp],#4
 857              	.LCFI86:
 858              	 .cfi_restore 7
 859              	 .cfi_def_cfa_offset 0
 860 0032 7047     	 bx lr
 861              	.L61:
 862              	 .align 2
 863              	.L60:
 864 0034 00400050 	 .word 1342193664
 865              	 .cfi_endproc
 866              	.LFE164:
 868              	 .section .text.XMC_SCU_CalibrateTemperatureSensor,"ax",%progbits
 869              	 .align 2
 870              	 .global XMC_SCU_CalibrateTemperatureSensor
 871              	 .thumb
 872              	 .thumb_func
 874              	XMC_SCU_CalibrateTemperatureSensor:
 875              	.LFB165:
 259:../Libraries/XMCLib/src/xmc4_scu.c **** 
 260:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to calibrate temperature sensor */
 261:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CalibrateTemperatureSensor(uint32_t offset, uint32_t gain)
 262:../Libraries/XMCLib/src/xmc4_scu.c **** {
 876              	 .loc 3 262 0
 877              	 .cfi_startproc
 878              	 
 879              	 
 880              	 
 881 0000 80B4     	 push {r7}
 882              	.LCFI87:
 883              	 .cfi_def_cfa_offset 4
 884              	 .cfi_offset 7,-4
 885 0002 83B0     	 sub sp,sp,#12
 886              	.LCFI88:
 887              	 .cfi_def_cfa_offset 16
 888 0004 00AF     	 add r7,sp,#0
 889              	.LCFI89:
 890              	 .cfi_def_cfa_register 7
 891 0006 7860     	 str r0,[r7,#4]
 892 0008 3960     	 str r1,[r7]
 263:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->DTSCON = ((uint32_t)(offset << SCU_GENERAL_DTSCON_OFFSET_Pos) |
 893              	 .loc 3 263 0
 894 000a 0749     	 ldr r1,.L63
 895 000c 7B68     	 ldr r3,[r7,#4]
 896 000e 1A01     	 lsls r2,r3,#4
 264:../Libraries/XMCLib/src/xmc4_scu.c ****                         (uint32_t)(gain << SCU_GENERAL_DTSCON_GAIN_Pos) |
 897              	 .loc 3 264 0
 898 0010 3B68     	 ldr r3,[r7]
 899 0012 DB02     	 lsls r3,r3,#11
 263:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->DTSCON = ((uint32_t)(offset << SCU_GENERAL_DTSCON_OFFSET_Pos) |
 900              	 .loc 3 263 0
 901 0014 1343     	 orrs r3,r3,r2
 265:../Libraries/XMCLib/src/xmc4_scu.c ****                         (uint32_t)(0x4UL << SCU_GENERAL_DTSCON_REFTRIM_Pos) |
 902              	 .loc 3 265 0
 903 0016 43F40803 	 orr r3,r3,#8912896
 263:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->DTSCON = ((uint32_t)(offset << SCU_GENERAL_DTSCON_OFFSET_Pos) |
 904              	 .loc 3 263 0
 905 001a C1F88C30 	 str r3,[r1,#140]
 266:../Libraries/XMCLib/src/xmc4_scu.c ****                         (uint32_t)(0x8UL << SCU_GENERAL_DTSCON_BGTRIM_Pos));
 267:../Libraries/XMCLib/src/xmc4_scu.c **** }
 906              	 .loc 3 267 0
 907 001e 0C37     	 adds r7,r7,#12
 908              	.LCFI90:
 909              	 .cfi_def_cfa_offset 4
 910 0020 BD46     	 mov sp,r7
 911              	.LCFI91:
 912              	 .cfi_def_cfa_register 13
 913              	 
 914 0022 5DF8047B 	 ldr r7,[sp],#4
 915              	.LCFI92:
 916              	 .cfi_restore 7
 917              	 .cfi_def_cfa_offset 0
 918 0026 7047     	 bx lr
 919              	.L64:
 920              	 .align 2
 921              	.L63:
 922 0028 00400050 	 .word 1342193664
 923              	 .cfi_endproc
 924              	.LFE165:
 926              	 .section .text.XMC_SCU_EnableTemperatureSensor,"ax",%progbits
 927              	 .align 2
 928              	 .global XMC_SCU_EnableTemperatureSensor
 929              	 .thumb
 930              	 .thumb_func
 932              	XMC_SCU_EnableTemperatureSensor:
 933              	.LFB166:
 268:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to enable die temperature measurement by powering the DTS module. */
 269:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_EnableTemperatureSensor(void)
 270:../Libraries/XMCLib/src/xmc4_scu.c **** {
 934              	 .loc 3 270 0
 935              	 .cfi_startproc
 936              	 
 937              	 
 938              	 
 939 0000 80B4     	 push {r7}
 940              	.LCFI93:
 941              	 .cfi_def_cfa_offset 4
 942              	 .cfi_offset 7,-4
 943 0002 00AF     	 add r7,sp,#0
 944              	.LCFI94:
 945              	 .cfi_def_cfa_register 7
 271:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->DTSCON &= (uint32_t)~(SCU_GENERAL_DTSCON_PWD_Msk);
 946              	 .loc 3 271 0
 947 0004 054A     	 ldr r2,.L66
 948 0006 054B     	 ldr r3,.L66
 949 0008 D3F88C30 	 ldr r3,[r3,#140]
 950 000c 23F00103 	 bic r3,r3,#1
 951 0010 C2F88C30 	 str r3,[r2,#140]
 272:../Libraries/XMCLib/src/xmc4_scu.c **** }
 952              	 .loc 3 272 0
 953 0014 BD46     	 mov sp,r7
 954              	.LCFI95:
 955              	 .cfi_def_cfa_register 13
 956              	 
 957 0016 5DF8047B 	 ldr r7,[sp],#4
 958              	.LCFI96:
 959              	 .cfi_restore 7
 960              	 .cfi_def_cfa_offset 0
 961 001a 7047     	 bx lr
 962              	.L67:
 963              	 .align 2
 964              	.L66:
 965 001c 00400050 	 .word 1342193664
 966              	 .cfi_endproc
 967              	.LFE166:
 969              	 .section .text.XMC_SCU_DisableTemperatureSensor,"ax",%progbits
 970              	 .align 2
 971              	 .global XMC_SCU_DisableTemperatureSensor
 972              	 .thumb
 973              	 .thumb_func
 975              	XMC_SCU_DisableTemperatureSensor:
 976              	.LFB167:
 273:../Libraries/XMCLib/src/xmc4_scu.c **** 
 274:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to disable die temperature measurement by powering the DTS module off. */
 275:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_DisableTemperatureSensor(void)
 276:../Libraries/XMCLib/src/xmc4_scu.c **** {
 977              	 .loc 3 276 0
 978              	 .cfi_startproc
 979              	 
 980              	 
 981              	 
 982 0000 80B4     	 push {r7}
 983              	.LCFI97:
 984              	 .cfi_def_cfa_offset 4
 985              	 .cfi_offset 7,-4
 986 0002 00AF     	 add r7,sp,#0
 987              	.LCFI98:
 988              	 .cfi_def_cfa_register 7
 277:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->DTSCON |= (uint32_t)SCU_GENERAL_DTSCON_PWD_Msk;
 989              	 .loc 3 277 0
 990 0004 054A     	 ldr r2,.L69
 991 0006 054B     	 ldr r3,.L69
 992 0008 D3F88C30 	 ldr r3,[r3,#140]
 993 000c 43F00103 	 orr r3,r3,#1
 994 0010 C2F88C30 	 str r3,[r2,#140]
 278:../Libraries/XMCLib/src/xmc4_scu.c **** }
 995              	 .loc 3 278 0
 996 0014 BD46     	 mov sp,r7
 997              	.LCFI99:
 998              	 .cfi_def_cfa_register 13
 999              	 
 1000 0016 5DF8047B 	 ldr r7,[sp],#4
 1001              	.LCFI100:
 1002              	 .cfi_restore 7
 1003              	 .cfi_def_cfa_offset 0
 1004 001a 7047     	 bx lr
 1005              	.L70:
 1006              	 .align 2
 1007              	.L69:
 1008 001c 00400050 	 .word 1342193664
 1009              	 .cfi_endproc
 1010              	.LFE167:
 1012              	 .section .text.XMC_SCU_IsTemperatureSensorEnabled,"ax",%progbits
 1013              	 .align 2
 1014              	 .global XMC_SCU_IsTemperatureSensorEnabled
 1015              	 .thumb
 1016              	 .thumb_func
 1018              	XMC_SCU_IsTemperatureSensorEnabled:
 1019              	.LFB168:
 279:../Libraries/XMCLib/src/xmc4_scu.c **** 
 280:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to provide the die temperature sensor power status. */
 281:../Libraries/XMCLib/src/xmc4_scu.c **** bool XMC_SCU_IsTemperatureSensorEnabled(void)
 282:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1020              	 .loc 3 282 0
 1021              	 .cfi_startproc
 1022              	 
 1023              	 
 1024              	 
 1025 0000 80B4     	 push {r7}
 1026              	.LCFI101:
 1027              	 .cfi_def_cfa_offset 4
 1028              	 .cfi_offset 7,-4
 1029 0002 00AF     	 add r7,sp,#0
 1030              	.LCFI102:
 1031              	 .cfi_def_cfa_register 7
 283:../Libraries/XMCLib/src/xmc4_scu.c ****   return ((SCU_GENERAL->DTSCON & SCU_GENERAL_DTSCON_PWD_Msk) == 0U);
 1032              	 .loc 3 283 0
 1033 0004 074B     	 ldr r3,.L73
 1034 0006 D3F88C30 	 ldr r3,[r3,#140]
 1035 000a 03F00103 	 and r3,r3,#1
 1036 000e 002B     	 cmp r3,#0
 1037 0010 0CBF     	 ite eq
 1038 0012 0123     	 moveq r3,#1
 1039 0014 0023     	 movne r3,#0
 1040 0016 DBB2     	 uxtb r3,r3
 284:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1041              	 .loc 3 284 0
 1042 0018 1846     	 mov r0,r3
 1043 001a BD46     	 mov sp,r7
 1044              	.LCFI103:
 1045              	 .cfi_def_cfa_register 13
 1046              	 
 1047 001c 5DF8047B 	 ldr r7,[sp],#4
 1048              	.LCFI104:
 1049              	 .cfi_restore 7
 1050              	 .cfi_def_cfa_offset 0
 1051 0020 7047     	 bx lr
 1052              	.L74:
 1053 0022 00BF     	 .align 2
 1054              	.L73:
 1055 0024 00400050 	 .word 1342193664
 1056              	 .cfi_endproc
 1057              	.LFE168:
 1059              	 .section .text.XMC_SCU_IsTemperatureSensorReady,"ax",%progbits
 1060              	 .align 2
 1061              	 .global XMC_SCU_IsTemperatureSensorReady
 1062              	 .thumb
 1063              	 .thumb_func
 1065              	XMC_SCU_IsTemperatureSensorReady:
 1066              	.LFB169:
 285:../Libraries/XMCLib/src/xmc4_scu.c **** 
 286:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to check if the die temperature sensor is ready to start a measurement. */
 287:../Libraries/XMCLib/src/xmc4_scu.c **** bool XMC_SCU_IsTemperatureSensorReady(void)
 288:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1067              	 .loc 3 288 0
 1068              	 .cfi_startproc
 1069              	 
 1070              	 
 1071              	 
 1072 0000 80B4     	 push {r7}
 1073              	.LCFI105:
 1074              	 .cfi_def_cfa_offset 4
 1075              	 .cfi_offset 7,-4
 1076 0002 00AF     	 add r7,sp,#0
 1077              	.LCFI106:
 1078              	 .cfi_def_cfa_register 7
 289:../Libraries/XMCLib/src/xmc4_scu.c ****   return ((SCU_GENERAL->DTSSTAT & SCU_GENERAL_DTSSTAT_RDY_Msk) != 0U);
 1079              	 .loc 3 289 0
 1080 0004 074B     	 ldr r3,.L77
 1081 0006 D3F89030 	 ldr r3,[r3,#144]
 1082 000a 03F48043 	 and r3,r3,#16384
 1083 000e 002B     	 cmp r3,#0
 1084 0010 14BF     	 ite ne
 1085 0012 0123     	 movne r3,#1
 1086 0014 0023     	 moveq r3,#0
 1087 0016 DBB2     	 uxtb r3,r3
 290:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1088              	 .loc 3 290 0
 1089 0018 1846     	 mov r0,r3
 1090 001a BD46     	 mov sp,r7
 1091              	.LCFI107:
 1092              	 .cfi_def_cfa_register 13
 1093              	 
 1094 001c 5DF8047B 	 ldr r7,[sp],#4
 1095              	.LCFI108:
 1096              	 .cfi_restore 7
 1097              	 .cfi_def_cfa_offset 0
 1098 0020 7047     	 bx lr
 1099              	.L78:
 1100 0022 00BF     	 .align 2
 1101              	.L77:
 1102 0024 00400050 	 .word 1342193664
 1103              	 .cfi_endproc
 1104              	.LFE169:
 1106              	 .section .text.XMC_SCU_StartTemperatureMeasurement,"ax",%progbits
 1107              	 .align 2
 1108              	 .global XMC_SCU_StartTemperatureMeasurement
 1109              	 .thumb
 1110              	 .thumb_func
 1112              	XMC_SCU_StartTemperatureMeasurement:
 1113              	.LFB170:
 291:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to start device temperature measurements */
 292:../Libraries/XMCLib/src/xmc4_scu.c **** XMC_SCU_STATUS_t XMC_SCU_StartTemperatureMeasurement(void)
 293:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1114              	 .loc 3 293 0
 1115              	 .cfi_startproc
 1116              	 
 1117              	 
 1118 0000 80B5     	 push {r7,lr}
 1119              	.LCFI109:
 1120              	 .cfi_def_cfa_offset 8
 1121              	 .cfi_offset 7,-8
 1122              	 .cfi_offset 14,-4
 1123 0002 82B0     	 sub sp,sp,#8
 1124              	.LCFI110:
 1125              	 .cfi_def_cfa_offset 16
 1126 0004 00AF     	 add r7,sp,#0
 1127              	.LCFI111:
 1128              	 .cfi_def_cfa_register 7
 294:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_STATUS_t status = XMC_SCU_STATUS_OK;
 1129              	 .loc 3 294 0
 1130 0006 0023     	 movs r3,#0
 1131 0008 FB71     	 strb r3,[r7,#7]
 295:../Libraries/XMCLib/src/xmc4_scu.c **** 
 296:../Libraries/XMCLib/src/xmc4_scu.c ****   if (XMC_SCU_IsTemperatureSensorEnabled() == false)
 1132              	 .loc 3 296 0
 1133 000a FFF7FEFF 	 bl XMC_SCU_IsTemperatureSensorEnabled
 1134 000e 0346     	 mov r3,r0
 1135 0010 83F00103 	 eor r3,r3,#1
 1136 0014 DBB2     	 uxtb r3,r3
 1137 0016 002B     	 cmp r3,#0
 1138 0018 01D0     	 beq .L80
 297:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 298:../Libraries/XMCLib/src/xmc4_scu.c ****     status = XMC_SCU_STATUS_ERROR;
 1139              	 .loc 3 298 0
 1140 001a 0123     	 movs r3,#1
 1141 001c FB71     	 strb r3,[r7,#7]
 1142              	.L80:
 299:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 300:../Libraries/XMCLib/src/xmc4_scu.c ****    
 301:../Libraries/XMCLib/src/xmc4_scu.c ****   if (XMC_SCU_IsTemperatureSensorBusy() == true)
 1143              	 .loc 3 301 0
 1144 001e FFF7FEFF 	 bl XMC_SCU_IsTemperatureSensorBusy
 1145 0022 0346     	 mov r3,r0
 1146 0024 002B     	 cmp r3,#0
 1147 0026 01D0     	 beq .L81
 302:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 303:../Libraries/XMCLib/src/xmc4_scu.c ****     status = XMC_SCU_STATUS_BUSY;
 1148              	 .loc 3 303 0
 1149 0028 0223     	 movs r3,#2
 1150 002a FB71     	 strb r3,[r7,#7]
 1151              	.L81:
 304:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 305:../Libraries/XMCLib/src/xmc4_scu.c **** 
 306:../Libraries/XMCLib/src/xmc4_scu.c ****   /* And start the measurement */
 307:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->DTSCON |= (uint32_t)SCU_GENERAL_DTSCON_START_Msk;
 1152              	 .loc 3 307 0
 1153 002c 064A     	 ldr r2,.L83
 1154 002e 064B     	 ldr r3,.L83
 1155 0030 D3F88C30 	 ldr r3,[r3,#140]
 1156 0034 43F00203 	 orr r3,r3,#2
 1157 0038 C2F88C30 	 str r3,[r2,#140]
 308:../Libraries/XMCLib/src/xmc4_scu.c ****   
 309:../Libraries/XMCLib/src/xmc4_scu.c ****   return (status);
 1158              	 .loc 3 309 0
 1159 003c FB79     	 ldrb r3,[r7,#7]
 310:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1160              	 .loc 3 310 0
 1161 003e 1846     	 mov r0,r3
 1162 0040 0837     	 adds r7,r7,#8
 1163              	.LCFI112:
 1164              	 .cfi_def_cfa_offset 8
 1165 0042 BD46     	 mov sp,r7
 1166              	.LCFI113:
 1167              	 .cfi_def_cfa_register 13
 1168              	 
 1169 0044 80BD     	 pop {r7,pc}
 1170              	.L84:
 1171 0046 00BF     	 .align 2
 1172              	.L83:
 1173 0048 00400050 	 .word 1342193664
 1174              	 .cfi_endproc
 1175              	.LFE170:
 1177              	 .section .text.XMC_SCU_GetTemperatureMeasurement,"ax",%progbits
 1178              	 .align 2
 1179              	 .global XMC_SCU_GetTemperatureMeasurement
 1180              	 .thumb
 1181              	 .thumb_func
 1183              	XMC_SCU_GetTemperatureMeasurement:
 1184              	.LFB171:
 311:../Libraries/XMCLib/src/xmc4_scu.c **** 
 312:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to retrieve the temperature measured */
 313:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_GetTemperatureMeasurement(void)
 314:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1185              	 .loc 3 314 0
 1186              	 .cfi_startproc
 1187              	 
 1188              	 
 1189 0000 80B5     	 push {r7,lr}
 1190              	.LCFI114:
 1191              	 .cfi_def_cfa_offset 8
 1192              	 .cfi_offset 7,-8
 1193              	 .cfi_offset 14,-4
 1194 0002 82B0     	 sub sp,sp,#8
 1195              	.LCFI115:
 1196              	 .cfi_def_cfa_offset 16
 1197 0004 00AF     	 add r7,sp,#0
 1198              	.LCFI116:
 1199              	 .cfi_def_cfa_register 7
 315:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t temperature;
 316:../Libraries/XMCLib/src/xmc4_scu.c **** 
 317:../Libraries/XMCLib/src/xmc4_scu.c ****   if (XMC_SCU_IsTemperatureSensorEnabled() == false)
 1200              	 .loc 3 317 0
 1201 0006 FFF7FEFF 	 bl XMC_SCU_IsTemperatureSensorEnabled
 1202 000a 0346     	 mov r3,r0
 1203 000c 83F00103 	 eor r3,r3,#1
 1204 0010 DBB2     	 uxtb r3,r3
 1205 0012 002B     	 cmp r3,#0
 1206 0014 03D0     	 beq .L86
 318:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 319:../Libraries/XMCLib/src/xmc4_scu.c ****     temperature = 0x7FFFFFFFUL;
 1207              	 .loc 3 319 0
 1208 0016 6FF00043 	 mvn r3,#-2147483648
 1209 001a 7B60     	 str r3,[r7,#4]
 1210 001c 05E0     	 b .L87
 1211              	.L86:
 320:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 321:../Libraries/XMCLib/src/xmc4_scu.c ****   else
 322:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 323:../Libraries/XMCLib/src/xmc4_scu.c ****     temperature = (uint32_t)((SCU_GENERAL->DTSSTAT & SCU_GENERAL_DTSSTAT_RESULT_Msk) >> SCU_GENERAL
 1212              	 .loc 3 323 0
 1213 001e 054B     	 ldr r3,.L89
 1214 0020 D3F89030 	 ldr r3,[r3,#144]
 1215 0024 C3F30903 	 ubfx r3,r3,#0,#10
 1216 0028 7B60     	 str r3,[r7,#4]
 1217              	.L87:
 324:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 325:../Libraries/XMCLib/src/xmc4_scu.c ****   
 326:../Libraries/XMCLib/src/xmc4_scu.c ****   return ((uint32_t)temperature);
 1218              	 .loc 3 326 0
 1219 002a 7B68     	 ldr r3,[r7,#4]
 327:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1220              	 .loc 3 327 0
 1221 002c 1846     	 mov r0,r3
 1222 002e 0837     	 adds r7,r7,#8
 1223              	.LCFI117:
 1224              	 .cfi_def_cfa_offset 8
 1225 0030 BD46     	 mov sp,r7
 1226              	.LCFI118:
 1227              	 .cfi_def_cfa_register 13
 1228              	 
 1229 0032 80BD     	 pop {r7,pc}
 1230              	.L90:
 1231              	 .align 2
 1232              	.L89:
 1233 0034 00400050 	 .word 1342193664
 1234              	 .cfi_endproc
 1235              	.LFE171:
 1237              	 .section .text.XMC_SCU_IsTemperatureSensorBusy,"ax",%progbits
 1238              	 .align 2
 1239              	 .global XMC_SCU_IsTemperatureSensorBusy
 1240              	 .thumb
 1241              	 .thumb_func
 1243              	XMC_SCU_IsTemperatureSensorBusy:
 1244              	.LFB172:
 328:../Libraries/XMCLib/src/xmc4_scu.c **** 
 329:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to know whether Die temperature sensor is busy */
 330:../Libraries/XMCLib/src/xmc4_scu.c **** bool XMC_SCU_IsTemperatureSensorBusy(void)
 331:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1245              	 .loc 3 331 0
 1246              	 .cfi_startproc
 1247              	 
 1248              	 
 1249              	 
 1250 0000 80B4     	 push {r7}
 1251              	.LCFI119:
 1252              	 .cfi_def_cfa_offset 4
 1253              	 .cfi_offset 7,-4
 1254 0002 00AF     	 add r7,sp,#0
 1255              	.LCFI120:
 1256              	 .cfi_def_cfa_register 7
 332:../Libraries/XMCLib/src/xmc4_scu.c ****   return ((SCU_GENERAL->DTSSTAT & SCU_GENERAL_DTSSTAT_BUSY_Msk) != 0U);
 1257              	 .loc 3 332 0
 1258 0004 074B     	 ldr r3,.L93
 1259 0006 D3F89030 	 ldr r3,[r3,#144]
 1260 000a 03F40043 	 and r3,r3,#32768
 1261 000e 002B     	 cmp r3,#0
 1262 0010 14BF     	 ite ne
 1263 0012 0123     	 movne r3,#1
 1264 0014 0023     	 moveq r3,#0
 1265 0016 DBB2     	 uxtb r3,r3
 333:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1266              	 .loc 3 333 0
 1267 0018 1846     	 mov r0,r3
 1268 001a BD46     	 mov sp,r7
 1269              	.LCFI121:
 1270              	 .cfi_def_cfa_register 13
 1271              	 
 1272 001c 5DF8047B 	 ldr r7,[sp],#4
 1273              	.LCFI122:
 1274              	 .cfi_restore 7
 1275              	 .cfi_def_cfa_offset 0
 1276 0020 7047     	 bx lr
 1277              	.L94:
 1278 0022 00BF     	 .align 2
 1279              	.L93:
 1280 0024 00400050 	 .word 1342193664
 1281              	 .cfi_endproc
 1282              	.LFE172:
 1284              	 .section .text.XMC_SCU_WriteToRetentionMemory,"ax",%progbits
 1285              	 .align 2
 1286              	 .global XMC_SCU_WriteToRetentionMemory
 1287              	 .thumb
 1288              	 .thumb_func
 1290              	XMC_SCU_WriteToRetentionMemory:
 1291              	.LFB173:
 334:../Libraries/XMCLib/src/xmc4_scu.c **** 
 335:../Libraries/XMCLib/src/xmc4_scu.c **** 
 336:../Libraries/XMCLib/src/xmc4_scu.c **** #if defined(SCU_GENERAL_DTEMPLIM_LOWER_Msk) && defined(SCU_GENERAL_DTEMPLIM_UPPER_Msk)
 337:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to determine if device temperature has gone past the ceiling */
 338:../Libraries/XMCLib/src/xmc4_scu.c **** bool XMC_SCU_HighTemperature(void)
 339:../Libraries/XMCLib/src/xmc4_scu.c **** {
 340:../Libraries/XMCLib/src/xmc4_scu.c ****   bool ret_val;
 341:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t   dtscon;
 342:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t   dtempalarm;
 343:../Libraries/XMCLib/src/xmc4_scu.c ****   dtscon = SCU_GENERAL->DTSCON;
 344:../Libraries/XMCLib/src/xmc4_scu.c ****   dtscon = dtscon & SCU_GENERAL_DTSCON_PWD_Msk;
 345:../Libraries/XMCLib/src/xmc4_scu.c **** 
 346:../Libraries/XMCLib/src/xmc4_scu.c ****   ret_val = false;
 347:../Libraries/XMCLib/src/xmc4_scu.c **** 
 348:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Any audit makes sense only if the DTS were powered up */  
 349:../Libraries/XMCLib/src/xmc4_scu.c ****   if(dtscon)
 350:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 351:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Powered down - return false */
 352:../Libraries/XMCLib/src/xmc4_scu.c ****     ret_val = false;
 353:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 354:../Libraries/XMCLib/src/xmc4_scu.c ****   else
 355:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 356:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Powered up - Read the overflow bit and decide accordingly*/
 357:../Libraries/XMCLib/src/xmc4_scu.c ****     dtempalarm = SCU_GENERAL->DTEMPALARM;
 358:../Libraries/XMCLib/src/xmc4_scu.c ****     dtempalarm = dtempalarm & SCU_GENERAL_DTEMPALARM_OVERFL_Msk;
 359:../Libraries/XMCLib/src/xmc4_scu.c ****     
 360:../Libraries/XMCLib/src/xmc4_scu.c ****     if(dtempalarm)
 361:../Libraries/XMCLib/src/xmc4_scu.c ****     {
 362:../Libraries/XMCLib/src/xmc4_scu.c ****       ret_val = true;
 363:../Libraries/XMCLib/src/xmc4_scu.c ****     }
 364:../Libraries/XMCLib/src/xmc4_scu.c ****     else
 365:../Libraries/XMCLib/src/xmc4_scu.c ****     {
 366:../Libraries/XMCLib/src/xmc4_scu.c ****       ret_val = false;
 367:../Libraries/XMCLib/src/xmc4_scu.c ****     }
 368:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 369:../Libraries/XMCLib/src/xmc4_scu.c ****   return (ret_val);
 370:../Libraries/XMCLib/src/xmc4_scu.c **** }
 371:../Libraries/XMCLib/src/xmc4_scu.c **** 
 372:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to program raw values of temperature limits into the DTS */
 373:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_SetRawTempLimits(const uint32_t lower_temp, const uint32_t upper_temp)
 374:../Libraries/XMCLib/src/xmc4_scu.c **** {
 375:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Power up the DTS module */
 376:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->DTSCON &= (uint32_t)~SCU_GENERAL_DTSCON_PWD_Msk;
 377:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->DTEMPLIM = 0;
 378:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->DTEMPLIM = (lower_temp & SCU_GENERAL_DTEMPLIM_LOWER_Msk);
 379:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->DTEMPLIM |= (uint32_t)((upper_temp & SCU_GENERAL_DTEMPLIM_LOWER_Msk) << SCU_GENERAL_
 380:../Libraries/XMCLib/src/xmc4_scu.c **** }
 381:../Libraries/XMCLib/src/xmc4_scu.c **** 
 382:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to determine if device temperature has gone below the stipulated limit */
 383:../Libraries/XMCLib/src/xmc4_scu.c **** bool XMC_SCU_LowTemperature(void)
 384:../Libraries/XMCLib/src/xmc4_scu.c **** {
 385:../Libraries/XMCLib/src/xmc4_scu.c ****   bool ret_val;
 386:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t   dtscon;
 387:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t   dtempalarm;
 388:../Libraries/XMCLib/src/xmc4_scu.c ****   dtscon = SCU_GENERAL->DTSCON;
 389:../Libraries/XMCLib/src/xmc4_scu.c ****   dtscon = dtscon & SCU_GENERAL_DTSCON_PWD_Msk;
 390:../Libraries/XMCLib/src/xmc4_scu.c **** 
 391:../Libraries/XMCLib/src/xmc4_scu.c ****   ret_val = false;
 392:../Libraries/XMCLib/src/xmc4_scu.c **** 
 393:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Any audit makes sense only if the DTS were powered up */  
 394:../Libraries/XMCLib/src/xmc4_scu.c ****   if(dtscon)
 395:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 396:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Powered down - return false */
 397:../Libraries/XMCLib/src/xmc4_scu.c ****     ret_val = false;
 398:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 399:../Libraries/XMCLib/src/xmc4_scu.c ****   else
 400:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 401:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Powered up - Read the overflow bit and decide accordingly*/
 402:../Libraries/XMCLib/src/xmc4_scu.c ****     dtempalarm = SCU_GENERAL->DTEMPALARM;
 403:../Libraries/XMCLib/src/xmc4_scu.c ****     dtempalarm = dtempalarm & SCU_GENERAL_DTEMPALARM_UNDERFL_Msk;
 404:../Libraries/XMCLib/src/xmc4_scu.c ****     
 405:../Libraries/XMCLib/src/xmc4_scu.c ****     if(dtempalarm)
 406:../Libraries/XMCLib/src/xmc4_scu.c ****     {
 407:../Libraries/XMCLib/src/xmc4_scu.c ****       ret_val = true;
 408:../Libraries/XMCLib/src/xmc4_scu.c ****     }
 409:../Libraries/XMCLib/src/xmc4_scu.c ****     else
 410:../Libraries/XMCLib/src/xmc4_scu.c ****     {
 411:../Libraries/XMCLib/src/xmc4_scu.c ****       ret_val = false;
 412:../Libraries/XMCLib/src/xmc4_scu.c ****     }
 413:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 414:../Libraries/XMCLib/src/xmc4_scu.c ****   
 415:../Libraries/XMCLib/src/xmc4_scu.c ****   return (ret_val);
 416:../Libraries/XMCLib/src/xmc4_scu.c **** }
 417:../Libraries/XMCLib/src/xmc4_scu.c **** #endif  
 418:../Libraries/XMCLib/src/xmc4_scu.c **** 
 419:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to write into Retention memory in hibernate domain */
 420:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_WriteToRetentionMemory(uint32_t address, uint32_t data)
 421:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1292              	 .loc 3 421 0
 1293              	 .cfi_startproc
 1294              	 
 1295              	 
 1296              	 
 1297 0000 80B4     	 push {r7}
 1298              	.LCFI123:
 1299              	 .cfi_def_cfa_offset 4
 1300              	 .cfi_offset 7,-4
 1301 0002 85B0     	 sub sp,sp,#20
 1302              	.LCFI124:
 1303              	 .cfi_def_cfa_offset 24
 1304 0004 00AF     	 add r7,sp,#0
 1305              	.LCFI125:
 1306              	 .cfi_def_cfa_register 7
 1307 0006 7860     	 str r0,[r7,#4]
 1308 0008 3960     	 str r1,[r7]
 422:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t rmacr;
 423:../Libraries/XMCLib/src/xmc4_scu.c ****   
 424:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Get the address right */  
 425:../Libraries/XMCLib/src/xmc4_scu.c ****   rmacr = (uint32_t)((address << SCU_GENERAL_RMACR_ADDR_Pos) & (uint32_t)SCU_GENERAL_RMACR_ADDR_Msk
 1309              	 .loc 3 425 0
 1310 000a 7B68     	 ldr r3,[r7,#4]
 1311 000c 1B04     	 lsls r3,r3,#16
 1312 000e 03F47023 	 and r3,r3,#983040
 1313 0012 FB60     	 str r3,[r7,#12]
 426:../Libraries/XMCLib/src/xmc4_scu.c ****   
 427:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Transfer from RMDATA to Retention memory */
 428:../Libraries/XMCLib/src/xmc4_scu.c ****   rmacr |= (uint32_t)(SCU_GENERAL_RMACR_RDWR_Msk);
 1314              	 .loc 3 428 0
 1315 0014 FB68     	 ldr r3,[r7,#12]
 1316 0016 43F00103 	 orr r3,r3,#1
 1317 001a FB60     	 str r3,[r7,#12]
 429:../Libraries/XMCLib/src/xmc4_scu.c ****   
 430:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Write desired data into RMDATA register */  
 431:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->RMDATA = data;
 1318              	 .loc 3 431 0
 1319 001c 0A4A     	 ldr r2,.L97
 1320 001e 3B68     	 ldr r3,[r7]
 1321 0020 C2F8CC30 	 str r3,[r2,#204]
 432:../Libraries/XMCLib/src/xmc4_scu.c ****   
 433:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Write address & direction of transfer into RMACR register */  
 434:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->RMACR = rmacr;
 1322              	 .loc 3 434 0
 1323 0024 084A     	 ldr r2,.L97
 1324 0026 FB68     	 ldr r3,[r7,#12]
 1325 0028 C2F8C830 	 str r3,[r2,#200]
 435:../Libraries/XMCLib/src/xmc4_scu.c ****   
 436:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Wait until the update of RMX register in hibernate domain is completed */
 437:../Libraries/XMCLib/src/xmc4_scu.c ****   while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_RMX_Msk)
 1326              	 .loc 3 437 0
 1327 002c 00BF     	 nop
 1328              	.L96:
 1329              	 .loc 3 437 0 is_stmt 0 discriminator 1
 1330 002e 064B     	 ldr r3,.L97
 1331 0030 D3F8C430 	 ldr r3,[r3,#196]
 1332 0034 03F40053 	 and r3,r3,#8192
 1333 0038 002B     	 cmp r3,#0
 1334 003a F8D1     	 bne .L96
 438:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 439:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 440:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1335              	 .loc 3 440 0 is_stmt 1
 1336 003c 1437     	 adds r7,r7,#20
 1337              	.LCFI126:
 1338              	 .cfi_def_cfa_offset 4
 1339 003e BD46     	 mov sp,r7
 1340              	.LCFI127:
 1341              	 .cfi_def_cfa_register 13
 1342              	 
 1343 0040 5DF8047B 	 ldr r7,[sp],#4
 1344              	.LCFI128:
 1345              	 .cfi_restore 7
 1346              	 .cfi_def_cfa_offset 0
 1347 0044 7047     	 bx lr
 1348              	.L98:
 1349 0046 00BF     	 .align 2
 1350              	.L97:
 1351 0048 00400050 	 .word 1342193664
 1352              	 .cfi_endproc
 1353              	.LFE173:
 1355              	 .section .text.XMC_SCU_ReadFromRetentionMemory,"ax",%progbits
 1356              	 .align 2
 1357              	 .global XMC_SCU_ReadFromRetentionMemory
 1358              	 .thumb
 1359              	 .thumb_func
 1361              	XMC_SCU_ReadFromRetentionMemory:
 1362              	.LFB174:
 441:../Libraries/XMCLib/src/xmc4_scu.c **** 
 442:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to read from Retention memory in hibernate domain */
 443:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_ReadFromRetentionMemory(uint32_t address)
 444:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1363              	 .loc 3 444 0
 1364              	 .cfi_startproc
 1365              	 
 1366              	 
 1367              	 
 1368 0000 80B4     	 push {r7}
 1369              	.LCFI129:
 1370              	 .cfi_def_cfa_offset 4
 1371              	 .cfi_offset 7,-4
 1372 0002 85B0     	 sub sp,sp,#20
 1373              	.LCFI130:
 1374              	 .cfi_def_cfa_offset 24
 1375 0004 00AF     	 add r7,sp,#0
 1376              	.LCFI131:
 1377              	 .cfi_def_cfa_register 7
 1378 0006 7860     	 str r0,[r7,#4]
 445:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t rmacr;
 446:../Libraries/XMCLib/src/xmc4_scu.c **** 
 447:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Get the address right */  
 448:../Libraries/XMCLib/src/xmc4_scu.c ****   rmacr = ((uint32_t)(address << SCU_GENERAL_RMACR_ADDR_Pos) & (uint32_t)SCU_GENERAL_RMACR_ADDR_Msk
 1379              	 .loc 3 448 0
 1380 0008 7B68     	 ldr r3,[r7,#4]
 1381 000a 1B04     	 lsls r3,r3,#16
 1382 000c 03F47023 	 and r3,r3,#983040
 1383 0010 FB60     	 str r3,[r7,#12]
 449:../Libraries/XMCLib/src/xmc4_scu.c ****   
 450:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Transfer from RMDATA to Retention memory */
 451:../Libraries/XMCLib/src/xmc4_scu.c ****   rmacr |= (uint32_t)(SCU_GENERAL_RMACR_RDWR_Msk);
 1384              	 .loc 3 451 0
 1385 0012 FB68     	 ldr r3,[r7,#12]
 1386 0014 43F00103 	 orr r3,r3,#1
 1387 0018 FB60     	 str r3,[r7,#12]
 452:../Libraries/XMCLib/src/xmc4_scu.c ****   
 453:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Writing an adress & direction of transfer into RMACR register */  
 454:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_GENERAL->RMACR = rmacr;
 1388              	 .loc 3 454 0
 1389 001a 0A4A     	 ldr r2,.L102
 1390 001c FB68     	 ldr r3,[r7,#12]
 1391 001e C2F8C830 	 str r3,[r2,#200]
 455:../Libraries/XMCLib/src/xmc4_scu.c ****   
 456:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Wait until the update of RMX register in hibernate domain is completed */
 457:../Libraries/XMCLib/src/xmc4_scu.c ****   while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_RMX_Msk)
 1392              	 .loc 3 457 0
 1393 0022 00BF     	 nop
 1394              	.L100:
 1395              	 .loc 3 457 0 is_stmt 0 discriminator 1
 1396 0024 074B     	 ldr r3,.L102
 1397 0026 D3F8C430 	 ldr r3,[r3,#196]
 1398 002a 03F40053 	 and r3,r3,#8192
 1399 002e 002B     	 cmp r3,#0
 1400 0030 F8D1     	 bne .L100
 458:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 459:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 460:../Libraries/XMCLib/src/xmc4_scu.c **** 
 461:../Libraries/XMCLib/src/xmc4_scu.c ****   return (SCU_GENERAL->RMDATA);
 1401              	 .loc 3 461 0 is_stmt 1
 1402 0032 044B     	 ldr r3,.L102
 1403 0034 D3F8CC30 	 ldr r3,[r3,#204]
 462:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1404              	 .loc 3 462 0
 1405 0038 1846     	 mov r0,r3
 1406 003a 1437     	 adds r7,r7,#20
 1407              	.LCFI132:
 1408              	 .cfi_def_cfa_offset 4
 1409 003c BD46     	 mov sp,r7
 1410              	.LCFI133:
 1411              	 .cfi_def_cfa_register 13
 1412              	 
 1413 003e 5DF8047B 	 ldr r7,[sp],#4
 1414              	.LCFI134:
 1415              	 .cfi_restore 7
 1416              	 .cfi_def_cfa_offset 0
 1417 0042 7047     	 bx lr
 1418              	.L103:
 1419              	 .align 2
 1420              	.L102:
 1421 0044 00400050 	 .word 1342193664
 1422              	 .cfi_endproc
 1423              	.LFE174:
 1425              	 .section .text.XMC_SCU_CLOCK_Init,"ax",%progbits
 1426              	 .align 2
 1427              	 .global XMC_SCU_CLOCK_Init
 1428              	 .thumb
 1429              	 .thumb_func
 1431              	XMC_SCU_CLOCK_Init:
 1432              	.LFB175:
 463:../Libraries/XMCLib/src/xmc4_scu.c **** 
 464:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to initialize the clock tree */
 465:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
 466:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1433              	 .loc 3 466 0
 1434              	 .cfi_startproc
 1435              	 
 1436              	 
 1437 0000 B0B5     	 push {r4,r5,r7,lr}
 1438              	.LCFI135:
 1439              	 .cfi_def_cfa_offset 16
 1440              	 .cfi_offset 4,-16
 1441              	 .cfi_offset 5,-12
 1442              	 .cfi_offset 7,-8
 1443              	 .cfi_offset 14,-4
 1444 0002 84B0     	 sub sp,sp,#16
 1445              	.LCFI136:
 1446              	 .cfi_def_cfa_offset 32
 1447 0004 02AF     	 add r7,sp,#8
 1448              	.LCFI137:
 1449              	 .cfi_def_cfa 7,24
 1450 0006 7860     	 str r0,[r7,#4]
 467:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("", config->fsys_clkdiv != 0);
 468:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("", config->fcpu_clkdiv != 0);
 469:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("", config->fccu_clkdiv != 0);
 470:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("", config->fperipheral_clkdiv != 0);
 471:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("", ((config->syspll_config.p_div != 0) &&
 472:../Libraries/XMCLib/src/xmc4_scu.c ****                   (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)) ||
 473:../Libraries/XMCLib/src/xmc4_scu.c ****                   (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_PRESCALAR));
 474:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("", ((config->syspll_config.n_div != 0) &&
 475:../Libraries/XMCLib/src/xmc4_scu.c ****                   (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)) ||
 476:../Libraries/XMCLib/src/xmc4_scu.c ****                   (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_PRESCALAR));
 477:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("", (config->syspll_config.k_div != 0) &&
 478:../Libraries/XMCLib/src/xmc4_scu.c ****                  ((config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL) ||
 479:../Libraries/XMCLib/src/xmc4_scu.c ****                   (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_PRESCALAR)));
 480:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("", ((config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL) ||
 481:../Libraries/XMCLib/src/xmc4_scu.c ****                  (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_OFI)) &&
 482:../Libraries/XMCLib/src/xmc4_scu.c ****                  ((config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL) ||
 483:../Libraries/XMCLib/src/xmc4_scu.c ****                   (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_PRESCALAR)));
 484:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("", ((config->fstdby_clksrc == XMC_SCU_HIB_STDBYCLKSRC_OSCULP) && (config->enable_oscu
 485:../Libraries/XMCLib/src/xmc4_scu.c ****                  (config->fstdby_clksrc != XMC_SCU_HIB_STDBYCLKSRC_OSCULP));
 486:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("", ((config->syspll_config.clksrc == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) &&
 487:../Libraries/XMCLib/src/xmc4_scu.c ****                  (config->enable_oschp == true)) || (config->syspll_config.clksrc != XMC_SCU_CLOCK_
 488:../Libraries/XMCLib/src/xmc4_scu.c **** 
 489:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_OFI);
 1451              	 .loc 3 489 0
 1452 0008 0020     	 movs r0,#0
 1453 000a FFF7FEFF 	 bl XMC_SCU_CLOCK_SetSystemClockSource
 490:../Libraries/XMCLib/src/xmc4_scu.c **** 
 491:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_HIB_EnableHibernateDomain();
 1454              	 .loc 3 491 0
 1455 000e FFF7FEFF 	 bl XMC_SCU_HIB_EnableHibernateDomain
 492:../Libraries/XMCLib/src/xmc4_scu.c ****   if (config->enable_osculp == true)
 1456              	 .loc 3 492 0
 1457 0012 7B68     	 ldr r3,[r7,#4]
 1458 0014 DB79     	 ldrb r3,[r3,#7]
 1459 0016 002B     	 cmp r3,#0
 1460 0018 01D0     	 beq .L105
 493:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 494:../Libraries/XMCLib/src/xmc4_scu.c ****     XMC_SCU_CLOCK_EnableLowPowerOscillator();
 1461              	 .loc 3 494 0
 1462 001a FFF7FEFF 	 bl XMC_SCU_CLOCK_EnableLowPowerOscillator
 1463              	.L105:
 495:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 496:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_HIB_SetStandbyClockSource(config->fstdby_clksrc);
 1464              	 .loc 3 496 0
 1465 001e 7B68     	 ldr r3,[r7,#4]
 1466 0020 5B7A     	 ldrb r3,[r3,#9]
 1467 0022 1846     	 mov r0,r3
 1468 0024 FFF7FEFF 	 bl XMC_SCU_HIB_SetStandbyClockSource
 497:../Libraries/XMCLib/src/xmc4_scu.c **** 
 498:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);
 1469              	 .loc 3 498 0
 1470 0028 7B68     	 ldr r3,[r7,#4]
 1471 002a 1B7A     	 ldrb r3,[r3,#8]
 1472 002c 1846     	 mov r0,r3
 1473 002e FFF7FEFF 	 bl XMC_SCU_CLOCK_SetBackupClockCalibrationMode
 499:../Libraries/XMCLib/src/xmc4_scu.c **** 
 500:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
 1474              	 .loc 3 500 0
 1475 0032 7B68     	 ldr r3,[r7,#4]
 1476 0034 1B7C     	 ldrb r3,[r3,#16]
 1477 0036 1846     	 mov r0,r3
 1478 0038 FFF7FEFF 	 bl XMC_SCU_CLOCK_SetSystemClockDivider
 501:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
 1479              	 .loc 3 501 0
 1480 003c 7B68     	 ldr r3,[r7,#4]
 1481 003e 5B7C     	 ldrb r3,[r3,#17]
 1482 0040 1846     	 mov r0,r3
 1483 0042 FFF7FEFF 	 bl XMC_SCU_CLOCK_SetCpuClockDivider
 502:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
 1484              	 .loc 3 502 0
 1485 0046 7B68     	 ldr r3,[r7,#4]
 1486 0048 9B7C     	 ldrb r3,[r3,#18]
 1487 004a 1846     	 mov r0,r3
 1488 004c FFF7FEFF 	 bl XMC_SCU_CLOCK_SetCcuClockDivider
 503:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);
 1489              	 .loc 3 503 0
 1490 0050 7B68     	 ldr r3,[r7,#4]
 1491 0052 DB7C     	 ldrb r3,[r3,#19]
 1492 0054 1846     	 mov r0,r3
 1493 0056 FFF7FEFF 	 bl XMC_SCU_CLOCK_SetPeripheralClockDivider
 504:../Libraries/XMCLib/src/xmc4_scu.c **** 
 505:../Libraries/XMCLib/src/xmc4_scu.c ****   if (config->enable_oschp == true)
 1494              	 .loc 3 505 0
 1495 005a 7B68     	 ldr r3,[r7,#4]
 1496 005c 9B79     	 ldrb r3,[r3,#6]
 1497 005e 002B     	 cmp r3,#0
 1498 0060 01D0     	 beq .L106
 506:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 507:../Libraries/XMCLib/src/xmc4_scu.c ****     XMC_SCU_CLOCK_EnableHighPerformanceOscillator();
 1499              	 .loc 3 507 0
 1500 0062 FFF7FEFF 	 bl XMC_SCU_CLOCK_EnableHighPerformanceOscillator
 1501              	.L106:
 508:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 509:../Libraries/XMCLib/src/xmc4_scu.c **** 
 510:../Libraries/XMCLib/src/xmc4_scu.c ****   if (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_DISABLED)
 1502              	 .loc 3 510 0
 1503 0066 7B68     	 ldr r3,[r7,#4]
 1504 0068 DB78     	 ldrb r3,[r3,#3]
 1505 006a 002B     	 cmp r3,#0
 1506 006c 02D1     	 bne .L107
 511:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 512:../Libraries/XMCLib/src/xmc4_scu.c ****     XMC_SCU_CLOCK_DisableSystemPll();
 1507              	 .loc 3 512 0
 1508 006e FFF7FEFF 	 bl XMC_SCU_CLOCK_DisableSystemPll
 1509 0072 14E0     	 b .L108
 1510              	.L107:
 513:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 514:../Libraries/XMCLib/src/xmc4_scu.c ****   else
 515:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 516:../Libraries/XMCLib/src/xmc4_scu.c **** 
 517:../Libraries/XMCLib/src/xmc4_scu.c ****     XMC_SCU_CLOCK_EnableSystemPll();
 1511              	 .loc 3 517 0
 1512 0074 FFF7FEFF 	 bl XMC_SCU_CLOCK_EnableSystemPll
 518:../Libraries/XMCLib/src/xmc4_scu.c ****     XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 1513              	 .loc 3 518 0
 1514 0078 7B68     	 ldr r3,[r7,#4]
 1515 007a 9988     	 ldrh r1,[r3,#4]
 1516 007c 7B68     	 ldr r3,[r7,#4]
 1517 007e DA78     	 ldrb r2,[r3,#3]
 519:../Libraries/XMCLib/src/xmc4_scu.c ****                                  config->syspll_config.mode,
 520:../Libraries/XMCLib/src/xmc4_scu.c ****                                  (uint32_t)config->syspll_config.p_div,
 1518              	 .loc 3 520 0
 1519 0080 7B68     	 ldr r3,[r7,#4]
 1520 0082 5B78     	 ldrb r3,[r3,#1]
 518:../Libraries/XMCLib/src/xmc4_scu.c ****     XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 1521              	 .loc 3 518 0
 1522 0084 1D46     	 mov r5,r3
 521:../Libraries/XMCLib/src/xmc4_scu.c ****                                  (uint32_t)config->syspll_config.n_div,
 1523              	 .loc 3 521 0
 1524 0086 7B68     	 ldr r3,[r7,#4]
 1525 0088 1B78     	 ldrb r3,[r3]
 518:../Libraries/XMCLib/src/xmc4_scu.c ****     XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 1526              	 .loc 3 518 0
 1527 008a 1C46     	 mov r4,r3
 522:../Libraries/XMCLib/src/xmc4_scu.c ****                                  (uint32_t)config->syspll_config.k_div);
 1528              	 .loc 3 522 0
 1529 008c 7B68     	 ldr r3,[r7,#4]
 1530 008e 9B78     	 ldrb r3,[r3,#2]
 518:../Libraries/XMCLib/src/xmc4_scu.c ****                                  config->syspll_config.mode,
 1531              	 .loc 3 518 0
 1532 0090 0093     	 str r3,[sp]
 1533 0092 0846     	 mov r0,r1
 1534 0094 1146     	 mov r1,r2
 1535 0096 2A46     	 mov r2,r5
 1536 0098 2346     	 mov r3,r4
 1537 009a FFF7FEFF 	 bl XMC_SCU_CLOCK_StartSystemPll
 1538              	.L108:
 523:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 524:../Libraries/XMCLib/src/xmc4_scu.c **** 
 525:../Libraries/XMCLib/src/xmc4_scu.c ****   /* use SYSPLL? */
 526:../Libraries/XMCLib/src/xmc4_scu.c ****   if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
 1539              	 .loc 3 526 0
 1540 009e 7B68     	 ldr r3,[r7,#4]
 1541 00a0 DB68     	 ldr r3,[r3,#12]
 1542 00a2 B3F5803F 	 cmp r3,#65536
 1543 00a6 03D1     	 bne .L109
 527:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 528:../Libraries/XMCLib/src/xmc4_scu.c ****     XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_PLL);    
 1544              	 .loc 3 528 0
 1545 00a8 4FF48030 	 mov r0,#65536
 1546 00ac FFF7FEFF 	 bl XMC_SCU_CLOCK_SetSystemClockSource
 1547              	.L109:
 529:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 530:../Libraries/XMCLib/src/xmc4_scu.c ****   SystemCoreClockUpdate();
 1548              	 .loc 3 530 0
 1549 00b0 FFF7FEFF 	 bl SystemCoreClockUpdate
 531:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1550              	 .loc 3 531 0
 1551 00b4 0837     	 adds r7,r7,#8
 1552              	.LCFI138:
 1553              	 .cfi_def_cfa_offset 16
 1554 00b6 BD46     	 mov sp,r7
 1555              	.LCFI139:
 1556              	 .cfi_def_cfa_register 13
 1557              	 
 1558 00b8 B0BD     	 pop {r4,r5,r7,pc}
 1559              	 .cfi_endproc
 1560              	.LFE175:
 1562 00ba 00BF     	 .section .text.XMC_SCU_TRAP_Enable,"ax",%progbits
 1563              	 .align 2
 1564              	 .global XMC_SCU_TRAP_Enable
 1565              	 .thumb
 1566              	 .thumb_func
 1568              	XMC_SCU_TRAP_Enable:
 1569              	.LFB176:
 532:../Libraries/XMCLib/src/xmc4_scu.c **** 
 533:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to enable a trap source */
 534:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_TRAP_Enable(const uint32_t trap)
 535:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1570              	 .loc 3 535 0
 1571              	 .cfi_startproc
 1572              	 
 1573              	 
 1574              	 
 1575 0000 80B4     	 push {r7}
 1576              	.LCFI140:
 1577              	 .cfi_def_cfa_offset 4
 1578              	 .cfi_offset 7,-4
 1579 0002 83B0     	 sub sp,sp,#12
 1580              	.LCFI141:
 1581              	 .cfi_def_cfa_offset 16
 1582 0004 00AF     	 add r7,sp,#0
 1583              	.LCFI142:
 1584              	 .cfi_def_cfa_register 7
 1585 0006 7860     	 str r0,[r7,#4]
 536:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_TRAP->TRAPDIS &= (uint32_t)~trap;
 1586              	 .loc 3 536 0
 1587 0008 0549     	 ldr r1,.L111
 1588 000a 054B     	 ldr r3,.L111
 1589 000c 9A68     	 ldr r2,[r3,#8]
 1590 000e 7B68     	 ldr r3,[r7,#4]
 1591 0010 DB43     	 mvns r3,r3
 1592 0012 1340     	 ands r3,r3,r2
 1593 0014 8B60     	 str r3,[r1,#8]
 537:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1594              	 .loc 3 537 0
 1595 0016 0C37     	 adds r7,r7,#12
 1596              	.LCFI143:
 1597              	 .cfi_def_cfa_offset 4
 1598 0018 BD46     	 mov sp,r7
 1599              	.LCFI144:
 1600              	 .cfi_def_cfa_register 13
 1601              	 
 1602 001a 5DF8047B 	 ldr r7,[sp],#4
 1603              	.LCFI145:
 1604              	 .cfi_restore 7
 1605              	 .cfi_def_cfa_offset 0
 1606 001e 7047     	 bx lr
 1607              	.L112:
 1608              	 .align 2
 1609              	.L111:
 1610 0020 60410050 	 .word 1342194016
 1611              	 .cfi_endproc
 1612              	.LFE176:
 1614              	 .section .text.XMC_SCU_TRAP_Disable,"ax",%progbits
 1615              	 .align 2
 1616              	 .global XMC_SCU_TRAP_Disable
 1617              	 .thumb
 1618              	 .thumb_func
 1620              	XMC_SCU_TRAP_Disable:
 1621              	.LFB177:
 538:../Libraries/XMCLib/src/xmc4_scu.c **** 
 539:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to disable a trap source */
 540:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_TRAP_Disable(const uint32_t trap)
 541:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1622              	 .loc 3 541 0
 1623              	 .cfi_startproc
 1624              	 
 1625              	 
 1626              	 
 1627 0000 80B4     	 push {r7}
 1628              	.LCFI146:
 1629              	 .cfi_def_cfa_offset 4
 1630              	 .cfi_offset 7,-4
 1631 0002 83B0     	 sub sp,sp,#12
 1632              	.LCFI147:
 1633              	 .cfi_def_cfa_offset 16
 1634 0004 00AF     	 add r7,sp,#0
 1635              	.LCFI148:
 1636              	 .cfi_def_cfa_register 7
 1637 0006 7860     	 str r0,[r7,#4]
 542:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_TRAP->TRAPDIS |= (uint32_t)trap;
 1638              	 .loc 3 542 0
 1639 0008 0549     	 ldr r1,.L114
 1640 000a 054B     	 ldr r3,.L114
 1641 000c 9A68     	 ldr r2,[r3,#8]
 1642 000e 7B68     	 ldr r3,[r7,#4]
 1643 0010 1343     	 orrs r3,r3,r2
 1644 0012 8B60     	 str r3,[r1,#8]
 543:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1645              	 .loc 3 543 0
 1646 0014 0C37     	 adds r7,r7,#12
 1647              	.LCFI149:
 1648              	 .cfi_def_cfa_offset 4
 1649 0016 BD46     	 mov sp,r7
 1650              	.LCFI150:
 1651              	 .cfi_def_cfa_register 13
 1652              	 
 1653 0018 5DF8047B 	 ldr r7,[sp],#4
 1654              	.LCFI151:
 1655              	 .cfi_restore 7
 1656              	 .cfi_def_cfa_offset 0
 1657 001c 7047     	 bx lr
 1658              	.L115:
 1659 001e 00BF     	 .align 2
 1660              	.L114:
 1661 0020 60410050 	 .word 1342194016
 1662              	 .cfi_endproc
 1663              	.LFE177:
 1665              	 .section .text.XMC_SCU_TRAP_GetStatus,"ax",%progbits
 1666              	 .align 2
 1667              	 .global XMC_SCU_TRAP_GetStatus
 1668              	 .thumb
 1669              	 .thumb_func
 1671              	XMC_SCU_TRAP_GetStatus:
 1672              	.LFB178:
 544:../Libraries/XMCLib/src/xmc4_scu.c **** 
 545:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to determine if a trap source has generated event */
 546:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_TRAP_GetStatus(void)
 547:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1673              	 .loc 3 547 0
 1674              	 .cfi_startproc
 1675              	 
 1676              	 
 1677              	 
 1678 0000 80B4     	 push {r7}
 1679              	.LCFI152:
 1680              	 .cfi_def_cfa_offset 4
 1681              	 .cfi_offset 7,-4
 1682 0002 00AF     	 add r7,sp,#0
 1683              	.LCFI153:
 1684              	 .cfi_def_cfa_register 7
 548:../Libraries/XMCLib/src/xmc4_scu.c ****   return (SCU_TRAP->TRAPRAW);
 1685              	 .loc 3 548 0
 1686 0004 034B     	 ldr r3,.L118
 1687 0006 5B68     	 ldr r3,[r3,#4]
 549:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1688              	 .loc 3 549 0
 1689 0008 1846     	 mov r0,r3
 1690 000a BD46     	 mov sp,r7
 1691              	.LCFI154:
 1692              	 .cfi_def_cfa_register 13
 1693              	 
 1694 000c 5DF8047B 	 ldr r7,[sp],#4
 1695              	.LCFI155:
 1696              	 .cfi_restore 7
 1697              	 .cfi_def_cfa_offset 0
 1698 0010 7047     	 bx lr
 1699              	.L119:
 1700 0012 00BF     	 .align 2
 1701              	.L118:
 1702 0014 60410050 	 .word 1342194016
 1703              	 .cfi_endproc
 1704              	.LFE178:
 1706              	 .section .text.XMC_SCU_TRAP_Trigger,"ax",%progbits
 1707              	 .align 2
 1708              	 .global XMC_SCU_TRAP_Trigger
 1709              	 .thumb
 1710              	 .thumb_func
 1712              	XMC_SCU_TRAP_Trigger:
 1713              	.LFB179:
 550:../Libraries/XMCLib/src/xmc4_scu.c **** 
 551:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to manually trigger a trap event */
 552:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_TRAP_Trigger(const uint32_t trap)
 553:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1714              	 .loc 3 553 0
 1715              	 .cfi_startproc
 1716              	 
 1717              	 
 1718              	 
 1719 0000 80B4     	 push {r7}
 1720              	.LCFI156:
 1721              	 .cfi_def_cfa_offset 4
 1722              	 .cfi_offset 7,-4
 1723 0002 83B0     	 sub sp,sp,#12
 1724              	.LCFI157:
 1725              	 .cfi_def_cfa_offset 16
 1726 0004 00AF     	 add r7,sp,#0
 1727              	.LCFI158:
 1728              	 .cfi_def_cfa_register 7
 1729 0006 7860     	 str r0,[r7,#4]
 554:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_TRAP->TRAPSET |= (uint32_t)trap;
 1730              	 .loc 3 554 0
 1731 0008 0549     	 ldr r1,.L121
 1732 000a 054B     	 ldr r3,.L121
 1733 000c 1A69     	 ldr r2,[r3,#16]
 1734 000e 7B68     	 ldr r3,[r7,#4]
 1735 0010 1343     	 orrs r3,r3,r2
 1736 0012 0B61     	 str r3,[r1,#16]
 555:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1737              	 .loc 3 555 0
 1738 0014 0C37     	 adds r7,r7,#12
 1739              	.LCFI159:
 1740              	 .cfi_def_cfa_offset 4
 1741 0016 BD46     	 mov sp,r7
 1742              	.LCFI160:
 1743              	 .cfi_def_cfa_register 13
 1744              	 
 1745 0018 5DF8047B 	 ldr r7,[sp],#4
 1746              	.LCFI161:
 1747              	 .cfi_restore 7
 1748              	 .cfi_def_cfa_offset 0
 1749 001c 7047     	 bx lr
 1750              	.L122:
 1751 001e 00BF     	 .align 2
 1752              	.L121:
 1753 0020 60410050 	 .word 1342194016
 1754              	 .cfi_endproc
 1755              	.LFE179:
 1757              	 .section .text.XMC_SCU_TRAP_ClearStatus,"ax",%progbits
 1758              	 .align 2
 1759              	 .global XMC_SCU_TRAP_ClearStatus
 1760              	 .thumb
 1761              	 .thumb_func
 1763              	XMC_SCU_TRAP_ClearStatus:
 1764              	.LFB180:
 556:../Libraries/XMCLib/src/xmc4_scu.c **** 
 557:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to clear a trap event */
 558:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_TRAP_ClearStatus(const uint32_t trap)
 559:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1765              	 .loc 3 559 0
 1766              	 .cfi_startproc
 1767              	 
 1768              	 
 1769              	 
 1770 0000 80B4     	 push {r7}
 1771              	.LCFI162:
 1772              	 .cfi_def_cfa_offset 4
 1773              	 .cfi_offset 7,-4
 1774 0002 83B0     	 sub sp,sp,#12
 1775              	.LCFI163:
 1776              	 .cfi_def_cfa_offset 16
 1777 0004 00AF     	 add r7,sp,#0
 1778              	.LCFI164:
 1779              	 .cfi_def_cfa_register 7
 1780 0006 7860     	 str r0,[r7,#4]
 560:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_TRAP->TRAPCLR |= (uint32_t)trap;
 1781              	 .loc 3 560 0
 1782 0008 0549     	 ldr r1,.L124
 1783 000a 054B     	 ldr r3,.L124
 1784 000c DA68     	 ldr r2,[r3,#12]
 1785 000e 7B68     	 ldr r3,[r7,#4]
 1786 0010 1343     	 orrs r3,r3,r2
 1787 0012 CB60     	 str r3,[r1,#12]
 561:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1788              	 .loc 3 561 0
 1789 0014 0C37     	 adds r7,r7,#12
 1790              	.LCFI165:
 1791              	 .cfi_def_cfa_offset 4
 1792 0016 BD46     	 mov sp,r7
 1793              	.LCFI166:
 1794              	 .cfi_def_cfa_register 13
 1795              	 
 1796 0018 5DF8047B 	 ldr r7,[sp],#4
 1797              	.LCFI167:
 1798              	 .cfi_restore 7
 1799              	 .cfi_def_cfa_offset 0
 1800 001c 7047     	 bx lr
 1801              	.L125:
 1802 001e 00BF     	 .align 2
 1803              	.L124:
 1804 0020 60410050 	 .word 1342194016
 1805              	 .cfi_endproc
 1806              	.LFE180:
 1808              	 .section .text.XMC_SCU_PARITY_ClearStatus,"ax",%progbits
 1809              	 .align 2
 1810              	 .global XMC_SCU_PARITY_ClearStatus
 1811              	 .thumb
 1812              	 .thumb_func
 1814              	XMC_SCU_PARITY_ClearStatus:
 1815              	.LFB181:
 562:../Libraries/XMCLib/src/xmc4_scu.c **** 
 563:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to clear parity error event */
 564:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_PARITY_ClearStatus(const uint32_t memory)
 565:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1816              	 .loc 3 565 0
 1817              	 .cfi_startproc
 1818              	 
 1819              	 
 1820              	 
 1821 0000 80B4     	 push {r7}
 1822              	.LCFI168:
 1823              	 .cfi_def_cfa_offset 4
 1824              	 .cfi_offset 7,-4
 1825 0002 83B0     	 sub sp,sp,#12
 1826              	.LCFI169:
 1827              	 .cfi_def_cfa_offset 16
 1828 0004 00AF     	 add r7,sp,#0
 1829              	.LCFI170:
 1830              	 .cfi_def_cfa_register 7
 1831 0006 7860     	 str r0,[r7,#4]
 566:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PARITY->PEFLAG |= (uint32_t)memory; 
 1832              	 .loc 3 566 0
 1833 0008 0549     	 ldr r1,.L127
 1834 000a 054B     	 ldr r3,.L127
 1835 000c 5A69     	 ldr r2,[r3,#20]
 1836 000e 7B68     	 ldr r3,[r7,#4]
 1837 0010 1343     	 orrs r3,r3,r2
 1838 0012 4B61     	 str r3,[r1,#20]
 567:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1839              	 .loc 3 567 0
 1840 0014 0C37     	 adds r7,r7,#12
 1841              	.LCFI171:
 1842              	 .cfi_def_cfa_offset 4
 1843 0016 BD46     	 mov sp,r7
 1844              	.LCFI172:
 1845              	 .cfi_def_cfa_register 13
 1846              	 
 1847 0018 5DF8047B 	 ldr r7,[sp],#4
 1848              	.LCFI173:
 1849              	 .cfi_restore 7
 1850              	 .cfi_def_cfa_offset 0
 1851 001c 7047     	 bx lr
 1852              	.L128:
 1853 001e 00BF     	 .align 2
 1854              	.L127:
 1855 0020 3C410050 	 .word 1342193980
 1856              	 .cfi_endproc
 1857              	.LFE181:
 1859              	 .section .text.XMC_SCU_PARITY_GetStatus,"ax",%progbits
 1860              	 .align 2
 1861              	 .global XMC_SCU_PARITY_GetStatus
 1862              	 .thumb
 1863              	 .thumb_func
 1865              	XMC_SCU_PARITY_GetStatus:
 1866              	.LFB182:
 568:../Libraries/XMCLib/src/xmc4_scu.c **** 
 569:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to determine if the specified parity error has occured or not */
 570:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_PARITY_GetStatus(void)
 571:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1867              	 .loc 3 571 0
 1868              	 .cfi_startproc
 1869              	 
 1870              	 
 1871              	 
 1872 0000 80B4     	 push {r7}
 1873              	.LCFI174:
 1874              	 .cfi_def_cfa_offset 4
 1875              	 .cfi_offset 7,-4
 1876 0002 00AF     	 add r7,sp,#0
 1877              	.LCFI175:
 1878              	 .cfi_def_cfa_register 7
 572:../Libraries/XMCLib/src/xmc4_scu.c ****   return (SCU_PARITY->PEFLAG);
 1879              	 .loc 3 572 0
 1880 0004 034B     	 ldr r3,.L131
 1881 0006 5B69     	 ldr r3,[r3,#20]
 573:../Libraries/XMCLib/src/xmc4_scu.c **** } 
 1882              	 .loc 3 573 0
 1883 0008 1846     	 mov r0,r3
 1884 000a BD46     	 mov sp,r7
 1885              	.LCFI176:
 1886              	 .cfi_def_cfa_register 13
 1887              	 
 1888 000c 5DF8047B 	 ldr r7,[sp],#4
 1889              	.LCFI177:
 1890              	 .cfi_restore 7
 1891              	 .cfi_def_cfa_offset 0
 1892 0010 7047     	 bx lr
 1893              	.L132:
 1894 0012 00BF     	 .align 2
 1895              	.L131:
 1896 0014 3C410050 	 .word 1342193980
 1897              	 .cfi_endproc
 1898              	.LFE182:
 1900              	 .section .text.XMC_SCU_PARITY_Enable,"ax",%progbits
 1901              	 .align 2
 1902              	 .global XMC_SCU_PARITY_Enable
 1903              	 .thumb
 1904              	 .thumb_func
 1906              	XMC_SCU_PARITY_Enable:
 1907              	.LFB183:
 574:../Libraries/XMCLib/src/xmc4_scu.c **** 
 575:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to enable parity error checking for the selected on-chip RAM type */
 576:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_PARITY_Enable(const uint32_t memory)
 577:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1908              	 .loc 3 577 0
 1909              	 .cfi_startproc
 1910              	 
 1911              	 
 1912              	 
 1913 0000 80B4     	 push {r7}
 1914              	.LCFI178:
 1915              	 .cfi_def_cfa_offset 4
 1916              	 .cfi_offset 7,-4
 1917 0002 83B0     	 sub sp,sp,#12
 1918              	.LCFI179:
 1919              	 .cfi_def_cfa_offset 16
 1920 0004 00AF     	 add r7,sp,#0
 1921              	.LCFI180:
 1922              	 .cfi_def_cfa_register 7
 1923 0006 7860     	 str r0,[r7,#4]
 578:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PARITY->PEEN |= (uint32_t)memory; 
 1924              	 .loc 3 578 0
 1925 0008 0549     	 ldr r1,.L134
 1926 000a 054B     	 ldr r3,.L134
 1927 000c 1A68     	 ldr r2,[r3]
 1928 000e 7B68     	 ldr r3,[r7,#4]
 1929 0010 1343     	 orrs r3,r3,r2
 1930 0012 0B60     	 str r3,[r1]
 579:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1931              	 .loc 3 579 0
 1932 0014 0C37     	 adds r7,r7,#12
 1933              	.LCFI181:
 1934              	 .cfi_def_cfa_offset 4
 1935 0016 BD46     	 mov sp,r7
 1936              	.LCFI182:
 1937              	 .cfi_def_cfa_register 13
 1938              	 
 1939 0018 5DF8047B 	 ldr r7,[sp],#4
 1940              	.LCFI183:
 1941              	 .cfi_restore 7
 1942              	 .cfi_def_cfa_offset 0
 1943 001c 7047     	 bx lr
 1944              	.L135:
 1945 001e 00BF     	 .align 2
 1946              	.L134:
 1947 0020 3C410050 	 .word 1342193980
 1948              	 .cfi_endproc
 1949              	.LFE183:
 1951              	 .section .text.XMC_SCU_PARITY_Disable,"ax",%progbits
 1952              	 .align 2
 1953              	 .global XMC_SCU_PARITY_Disable
 1954              	 .thumb
 1955              	 .thumb_func
 1957              	XMC_SCU_PARITY_Disable:
 1958              	.LFB184:
 580:../Libraries/XMCLib/src/xmc4_scu.c **** 
 581:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to disable parity error checking for the selected on-chip RAM type */
 582:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_PARITY_Disable(const uint32_t memory)
 583:../Libraries/XMCLib/src/xmc4_scu.c **** {
 1959              	 .loc 3 583 0
 1960              	 .cfi_startproc
 1961              	 
 1962              	 
 1963              	 
 1964 0000 80B4     	 push {r7}
 1965              	.LCFI184:
 1966              	 .cfi_def_cfa_offset 4
 1967              	 .cfi_offset 7,-4
 1968 0002 83B0     	 sub sp,sp,#12
 1969              	.LCFI185:
 1970              	 .cfi_def_cfa_offset 16
 1971 0004 00AF     	 add r7,sp,#0
 1972              	.LCFI186:
 1973              	 .cfi_def_cfa_register 7
 1974 0006 7860     	 str r0,[r7,#4]
 584:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PARITY->PEEN &= (uint32_t)~memory; 
 1975              	 .loc 3 584 0
 1976 0008 0549     	 ldr r1,.L137
 1977 000a 054B     	 ldr r3,.L137
 1978 000c 1A68     	 ldr r2,[r3]
 1979 000e 7B68     	 ldr r3,[r7,#4]
 1980 0010 DB43     	 mvns r3,r3
 1981 0012 1340     	 ands r3,r3,r2
 1982 0014 0B60     	 str r3,[r1]
 585:../Libraries/XMCLib/src/xmc4_scu.c **** }
 1983              	 .loc 3 585 0
 1984 0016 0C37     	 adds r7,r7,#12
 1985              	.LCFI187:
 1986              	 .cfi_def_cfa_offset 4
 1987 0018 BD46     	 mov sp,r7
 1988              	.LCFI188:
 1989              	 .cfi_def_cfa_register 13
 1990              	 
 1991 001a 5DF8047B 	 ldr r7,[sp],#4
 1992              	.LCFI189:
 1993              	 .cfi_restore 7
 1994              	 .cfi_def_cfa_offset 0
 1995 001e 7047     	 bx lr
 1996              	.L138:
 1997              	 .align 2
 1998              	.L137:
 1999 0020 3C410050 	 .word 1342193980
 2000              	 .cfi_endproc
 2001              	.LFE184:
 2003              	 .section .text.XMC_SCU_PARITY_EnableTrapGeneration,"ax",%progbits
 2004              	 .align 2
 2005              	 .global XMC_SCU_PARITY_EnableTrapGeneration
 2006              	 .thumb
 2007              	 .thumb_func
 2009              	XMC_SCU_PARITY_EnableTrapGeneration:
 2010              	.LFB185:
 586:../Libraries/XMCLib/src/xmc4_scu.c **** 
 587:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to enable trap assertion for the parity error source */
 588:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_PARITY_EnableTrapGeneration(const uint32_t memory)
 589:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2011              	 .loc 3 589 0
 2012              	 .cfi_startproc
 2013              	 
 2014              	 
 2015              	 
 2016 0000 80B4     	 push {r7}
 2017              	.LCFI190:
 2018              	 .cfi_def_cfa_offset 4
 2019              	 .cfi_offset 7,-4
 2020 0002 83B0     	 sub sp,sp,#12
 2021              	.LCFI191:
 2022              	 .cfi_def_cfa_offset 16
 2023 0004 00AF     	 add r7,sp,#0
 2024              	.LCFI192:
 2025              	 .cfi_def_cfa_register 7
 2026 0006 7860     	 str r0,[r7,#4]
 590:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PARITY->PETE |= (uint32_t)memory; 
 2027              	 .loc 3 590 0
 2028 0008 0549     	 ldr r1,.L140
 2029 000a 054B     	 ldr r3,.L140
 2030 000c 9A68     	 ldr r2,[r3,#8]
 2031 000e 7B68     	 ldr r3,[r7,#4]
 2032 0010 1343     	 orrs r3,r3,r2
 2033 0012 8B60     	 str r3,[r1,#8]
 591:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2034              	 .loc 3 591 0
 2035 0014 0C37     	 adds r7,r7,#12
 2036              	.LCFI193:
 2037              	 .cfi_def_cfa_offset 4
 2038 0016 BD46     	 mov sp,r7
 2039              	.LCFI194:
 2040              	 .cfi_def_cfa_register 13
 2041              	 
 2042 0018 5DF8047B 	 ldr r7,[sp],#4
 2043              	.LCFI195:
 2044              	 .cfi_restore 7
 2045              	 .cfi_def_cfa_offset 0
 2046 001c 7047     	 bx lr
 2047              	.L141:
 2048 001e 00BF     	 .align 2
 2049              	.L140:
 2050 0020 3C410050 	 .word 1342193980
 2051              	 .cfi_endproc
 2052              	.LFE185:
 2054              	 .section .text.XMC_SCU_PARITY_DisableTrapGeneration,"ax",%progbits
 2055              	 .align 2
 2056              	 .global XMC_SCU_PARITY_DisableTrapGeneration
 2057              	 .thumb
 2058              	 .thumb_func
 2060              	XMC_SCU_PARITY_DisableTrapGeneration:
 2061              	.LFB186:
 592:../Libraries/XMCLib/src/xmc4_scu.c **** 
 593:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to disable the assertion of trap for the parity error source */
 594:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_PARITY_DisableTrapGeneration(const uint32_t memory)
 595:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2062              	 .loc 3 595 0
 2063              	 .cfi_startproc
 2064              	 
 2065              	 
 2066              	 
 2067 0000 80B4     	 push {r7}
 2068              	.LCFI196:
 2069              	 .cfi_def_cfa_offset 4
 2070              	 .cfi_offset 7,-4
 2071 0002 83B0     	 sub sp,sp,#12
 2072              	.LCFI197:
 2073              	 .cfi_def_cfa_offset 16
 2074 0004 00AF     	 add r7,sp,#0
 2075              	.LCFI198:
 2076              	 .cfi_def_cfa_register 7
 2077 0006 7860     	 str r0,[r7,#4]
 596:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PARITY->PETE &= (uint32_t)~memory; 
 2078              	 .loc 3 596 0
 2079 0008 0549     	 ldr r1,.L143
 2080 000a 054B     	 ldr r3,.L143
 2081 000c 9A68     	 ldr r2,[r3,#8]
 2082 000e 7B68     	 ldr r3,[r7,#4]
 2083 0010 DB43     	 mvns r3,r3
 2084 0012 1340     	 ands r3,r3,r2
 2085 0014 8B60     	 str r3,[r1,#8]
 597:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2086              	 .loc 3 597 0
 2087 0016 0C37     	 adds r7,r7,#12
 2088              	.LCFI199:
 2089              	 .cfi_def_cfa_offset 4
 2090 0018 BD46     	 mov sp,r7
 2091              	.LCFI200:
 2092              	 .cfi_def_cfa_register 13
 2093              	 
 2094 001a 5DF8047B 	 ldr r7,[sp],#4
 2095              	.LCFI201:
 2096              	 .cfi_restore 7
 2097              	 .cfi_def_cfa_offset 0
 2098 001e 7047     	 bx lr
 2099              	.L144:
 2100              	 .align 2
 2101              	.L143:
 2102 0020 3C410050 	 .word 1342193980
 2103              	 .cfi_endproc
 2104              	.LFE186:
 2106              	 .section .text.XMC_SCU_INTERRUPT_EnableNmiRequest,"ax",%progbits
 2107              	 .align 2
 2108              	 .global XMC_SCU_INTERRUPT_EnableNmiRequest
 2109              	 .thumb
 2110              	 .thumb_func
 2112              	XMC_SCU_INTERRUPT_EnableNmiRequest:
 2113              	.LFB187:
 598:../Libraries/XMCLib/src/xmc4_scu.c **** 
 599:../Libraries/XMCLib/src/xmc4_scu.c **** /* Enables a NMI source */
 600:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_INTERRUPT_EnableNmiRequest(const uint32_t request)
 601:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2114              	 .loc 3 601 0
 2115              	 .cfi_startproc
 2116              	 
 2117              	 
 2118              	 
 2119 0000 80B4     	 push {r7}
 2120              	.LCFI202:
 2121              	 .cfi_def_cfa_offset 4
 2122              	 .cfi_offset 7,-4
 2123 0002 83B0     	 sub sp,sp,#12
 2124              	.LCFI203:
 2125              	 .cfi_def_cfa_offset 16
 2126 0004 00AF     	 add r7,sp,#0
 2127              	.LCFI204:
 2128              	 .cfi_def_cfa_register 7
 2129 0006 7860     	 str r0,[r7,#4]
 602:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_INTERRUPT->NMIREQEN |= (uint32_t)request;
 2130              	 .loc 3 602 0
 2131 0008 0549     	 ldr r1,.L146
 2132 000a 054B     	 ldr r3,.L146
 2133 000c 5A69     	 ldr r2,[r3,#20]
 2134 000e 7B68     	 ldr r3,[r7,#4]
 2135 0010 1343     	 orrs r3,r3,r2
 2136 0012 4B61     	 str r3,[r1,#20]
 603:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2137              	 .loc 3 603 0
 2138 0014 0C37     	 adds r7,r7,#12
 2139              	.LCFI205:
 2140              	 .cfi_def_cfa_offset 4
 2141 0016 BD46     	 mov sp,r7
 2142              	.LCFI206:
 2143              	 .cfi_def_cfa_register 13
 2144              	 
 2145 0018 5DF8047B 	 ldr r7,[sp],#4
 2146              	.LCFI207:
 2147              	 .cfi_restore 7
 2148              	 .cfi_def_cfa_offset 0
 2149 001c 7047     	 bx lr
 2150              	.L147:
 2151 001e 00BF     	 .align 2
 2152              	.L146:
 2153 0020 74400050 	 .word 1342193780
 2154              	 .cfi_endproc
 2155              	.LFE187:
 2157              	 .section .text.XMC_SCU_INTERRUPT_DisableNmiRequest,"ax",%progbits
 2158              	 .align 2
 2159              	 .global XMC_SCU_INTERRUPT_DisableNmiRequest
 2160              	 .thumb
 2161              	 .thumb_func
 2163              	XMC_SCU_INTERRUPT_DisableNmiRequest:
 2164              	.LFB188:
 604:../Libraries/XMCLib/src/xmc4_scu.c **** 
 605:../Libraries/XMCLib/src/xmc4_scu.c **** /* Disables a NMI source */
 606:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_INTERRUPT_DisableNmiRequest(const uint32_t request)
 607:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2165              	 .loc 3 607 0
 2166              	 .cfi_startproc
 2167              	 
 2168              	 
 2169              	 
 2170 0000 80B4     	 push {r7}
 2171              	.LCFI208:
 2172              	 .cfi_def_cfa_offset 4
 2173              	 .cfi_offset 7,-4
 2174 0002 83B0     	 sub sp,sp,#12
 2175              	.LCFI209:
 2176              	 .cfi_def_cfa_offset 16
 2177 0004 00AF     	 add r7,sp,#0
 2178              	.LCFI210:
 2179              	 .cfi_def_cfa_register 7
 2180 0006 7860     	 str r0,[r7,#4]
 608:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_INTERRUPT->NMIREQEN &= (uint32_t)~request;
 2181              	 .loc 3 608 0
 2182 0008 0549     	 ldr r1,.L149
 2183 000a 054B     	 ldr r3,.L149
 2184 000c 5A69     	 ldr r2,[r3,#20]
 2185 000e 7B68     	 ldr r3,[r7,#4]
 2186 0010 DB43     	 mvns r3,r3
 2187 0012 1340     	 ands r3,r3,r2
 2188 0014 4B61     	 str r3,[r1,#20]
 609:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2189              	 .loc 3 609 0
 2190 0016 0C37     	 adds r7,r7,#12
 2191              	.LCFI211:
 2192              	 .cfi_def_cfa_offset 4
 2193 0018 BD46     	 mov sp,r7
 2194              	.LCFI212:
 2195              	 .cfi_def_cfa_register 13
 2196              	 
 2197 001a 5DF8047B 	 ldr r7,[sp],#4
 2198              	.LCFI213:
 2199              	 .cfi_restore 7
 2200              	 .cfi_def_cfa_offset 0
 2201 001e 7047     	 bx lr
 2202              	.L150:
 2203              	 .align 2
 2204              	.L149:
 2205 0020 74400050 	 .word 1342193780
 2206              	 .cfi_endproc
 2207              	.LFE188:
 2209              	 .section .text.XMC_SCU_RESET_AssertPeripheralReset,"ax",%progbits
 2210              	 .align 2
 2211              	 .global XMC_SCU_RESET_AssertPeripheralReset
 2212              	 .thumb
 2213              	 .thumb_func
 2215              	XMC_SCU_RESET_AssertPeripheralReset:
 2216              	.LFB189:
 610:../Libraries/XMCLib/src/xmc4_scu.c **** 
 611:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to manually assert a reset request */
 612:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_RESET_AssertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
 613:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2217              	 .loc 3 613 0
 2218              	 .cfi_startproc
 2219              	 
 2220              	 
 2221              	 
 2222 0000 80B4     	 push {r7}
 2223              	.LCFI214:
 2224              	 .cfi_def_cfa_offset 4
 2225              	 .cfi_offset 7,-4
 2226 0002 85B0     	 sub sp,sp,#20
 2227              	.LCFI215:
 2228              	 .cfi_def_cfa_offset 24
 2229 0004 00AF     	 add r7,sp,#0
 2230              	.LCFI216:
 2231              	 .cfi_def_cfa_register 7
 2232 0006 7860     	 str r0,[r7,#4]
 614:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 2233              	 .loc 3 614 0
 2234 0008 7B68     	 ldr r3,[r7,#4]
 2235 000a 1B0F     	 lsrs r3,r3,#28
 2236 000c FB60     	 str r3,[r7,#12]
 615:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 2237              	 .loc 3 615 0
 2238 000e 7B68     	 ldr r3,[r7,#4]
 2239 0010 23F07043 	 bic r3,r3,#-268435456
 2240 0014 BB60     	 str r3,[r7,#8]
 616:../Libraries/XMCLib/src/xmc4_scu.c **** 
 617:../Libraries/XMCLib/src/xmc4_scu.c ****   *(uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) |= (uint32_t)mask;
 2241              	 .loc 3 617 0
 2242 0016 FA68     	 ldr r2,[r7,#12]
 2243 0018 1346     	 mov r3,r2
 2244 001a 5B00     	 lsls r3,r3,#1
 2245 001c 1344     	 add r3,r3,r2
 2246 001e 9B00     	 lsls r3,r3,#2
 2247 0020 094A     	 ldr r2,.L152
 2248 0022 1A44     	 add r2,r2,r3
 2249 0024 F968     	 ldr r1,[r7,#12]
 2250 0026 0B46     	 mov r3,r1
 2251 0028 5B00     	 lsls r3,r3,#1
 2252 002a 0B44     	 add r3,r3,r1
 2253 002c 9B00     	 lsls r3,r3,#2
 2254 002e 1946     	 mov r1,r3
 2255 0030 054B     	 ldr r3,.L152
 2256 0032 0B44     	 add r3,r3,r1
 2257 0034 1968     	 ldr r1,[r3]
 2258 0036 BB68     	 ldr r3,[r7,#8]
 2259 0038 0B43     	 orrs r3,r3,r1
 2260 003a 1360     	 str r3,[r2]
 618:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2261              	 .loc 3 618 0
 2262 003c 1437     	 adds r7,r7,#20
 2263              	.LCFI217:
 2264              	 .cfi_def_cfa_offset 4
 2265 003e BD46     	 mov sp,r7
 2266              	.LCFI218:
 2267              	 .cfi_def_cfa_register 13
 2268              	 
 2269 0040 5DF8047B 	 ldr r7,[sp],#4
 2270              	.LCFI219:
 2271              	 .cfi_restore 7
 2272              	 .cfi_def_cfa_offset 0
 2273 0044 7047     	 bx lr
 2274              	.L153:
 2275 0046 00BF     	 .align 2
 2276              	.L152:
 2277 0048 10440050 	 .word 1342194704
 2278              	 .cfi_endproc
 2279              	.LFE189:
 2281              	 .section .text.XMC_SCU_RESET_DeassertPeripheralReset,"ax",%progbits
 2282              	 .align 2
 2283              	 .global XMC_SCU_RESET_DeassertPeripheralReset
 2284              	 .thumb
 2285              	 .thumb_func
 2287              	XMC_SCU_RESET_DeassertPeripheralReset:
 2288              	.LFB190:
 619:../Libraries/XMCLib/src/xmc4_scu.c **** 
 620:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to manually de-assert a reset request */
 621:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
 622:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2289              	 .loc 3 622 0
 2290              	 .cfi_startproc
 2291              	 
 2292              	 
 2293              	 
 2294 0000 80B4     	 push {r7}
 2295              	.LCFI220:
 2296              	 .cfi_def_cfa_offset 4
 2297              	 .cfi_offset 7,-4
 2298 0002 85B0     	 sub sp,sp,#20
 2299              	.LCFI221:
 2300              	 .cfi_def_cfa_offset 24
 2301 0004 00AF     	 add r7,sp,#0
 2302              	.LCFI222:
 2303              	 .cfi_def_cfa_register 7
 2304 0006 7860     	 str r0,[r7,#4]
 623:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 2305              	 .loc 3 623 0
 2306 0008 7B68     	 ldr r3,[r7,#4]
 2307 000a 1B0F     	 lsrs r3,r3,#28
 2308 000c FB60     	 str r3,[r7,#12]
 624:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 2309              	 .loc 3 624 0
 2310 000e 7B68     	 ldr r3,[r7,#4]
 2311 0010 23F07043 	 bic r3,r3,#-268435456
 2312 0014 BB60     	 str r3,[r7,#8]
 625:../Libraries/XMCLib/src/xmc4_scu.c **** 
 626:../Libraries/XMCLib/src/xmc4_scu.c ****   *(uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) |= (uint32_t)mask;
 2313              	 .loc 3 626 0
 2314 0016 FA68     	 ldr r2,[r7,#12]
 2315 0018 1346     	 mov r3,r2
 2316 001a 5B00     	 lsls r3,r3,#1
 2317 001c 1344     	 add r3,r3,r2
 2318 001e 9B00     	 lsls r3,r3,#2
 2319 0020 094A     	 ldr r2,.L155
 2320 0022 1A44     	 add r2,r2,r3
 2321 0024 F968     	 ldr r1,[r7,#12]
 2322 0026 0B46     	 mov r3,r1
 2323 0028 5B00     	 lsls r3,r3,#1
 2324 002a 0B44     	 add r3,r3,r1
 2325 002c 9B00     	 lsls r3,r3,#2
 2326 002e 1946     	 mov r1,r3
 2327 0030 054B     	 ldr r3,.L155
 2328 0032 0B44     	 add r3,r3,r1
 2329 0034 1968     	 ldr r1,[r3]
 2330 0036 BB68     	 ldr r3,[r7,#8]
 2331 0038 0B43     	 orrs r3,r3,r1
 2332 003a 1360     	 str r3,[r2]
 627:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2333              	 .loc 3 627 0
 2334 003c 1437     	 adds r7,r7,#20
 2335              	.LCFI223:
 2336              	 .cfi_def_cfa_offset 4
 2337 003e BD46     	 mov sp,r7
 2338              	.LCFI224:
 2339              	 .cfi_def_cfa_register 13
 2340              	 
 2341 0040 5DF8047B 	 ldr r7,[sp],#4
 2342              	.LCFI225:
 2343              	 .cfi_restore 7
 2344              	 .cfi_def_cfa_offset 0
 2345 0044 7047     	 bx lr
 2346              	.L156:
 2347 0046 00BF     	 .align 2
 2348              	.L155:
 2349 0048 14440050 	 .word 1342194708
 2350              	 .cfi_endproc
 2351              	.LFE190:
 2353              	 .section .text.XMC_SCU_RESET_IsPeripheralResetAsserted,"ax",%progbits
 2354              	 .align 2
 2355              	 .global XMC_SCU_RESET_IsPeripheralResetAsserted
 2356              	 .thumb
 2357              	 .thumb_func
 2359              	XMC_SCU_RESET_IsPeripheralResetAsserted:
 2360              	.LFB191:
 628:../Libraries/XMCLib/src/xmc4_scu.c **** 
 629:../Libraries/XMCLib/src/xmc4_scu.c **** /* Find out if the peripheral reset is asserted */
 630:../Libraries/XMCLib/src/xmc4_scu.c **** bool XMC_SCU_RESET_IsPeripheralResetAsserted(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
 631:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2361              	 .loc 3 631 0
 2362              	 .cfi_startproc
 2363              	 
 2364              	 
 2365              	 
 2366 0000 80B4     	 push {r7}
 2367              	.LCFI226:
 2368              	 .cfi_def_cfa_offset 4
 2369              	 .cfi_offset 7,-4
 2370 0002 85B0     	 sub sp,sp,#20
 2371              	.LCFI227:
 2372              	 .cfi_def_cfa_offset 24
 2373 0004 00AF     	 add r7,sp,#0
 2374              	.LCFI228:
 2375              	 .cfi_def_cfa_register 7
 2376 0006 7860     	 str r0,[r7,#4]
 632:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 2377              	 .loc 3 632 0
 2378 0008 7B68     	 ldr r3,[r7,#4]
 2379 000a 1B0F     	 lsrs r3,r3,#28
 2380 000c FB60     	 str r3,[r7,#12]
 633:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 2381              	 .loc 3 633 0
 2382 000e 7B68     	 ldr r3,[r7,#4]
 2383 0010 23F07043 	 bic r3,r3,#-268435456
 2384 0014 BB60     	 str r3,[r7,#8]
 634:../Libraries/XMCLib/src/xmc4_scu.c **** 
 635:../Libraries/XMCLib/src/xmc4_scu.c ****   return ((*(uint32_t *)(&(SCU_RESET->PRSTAT0) + (index * 3U)) & mask) != 0U);
 2385              	 .loc 3 635 0
 2386 0016 FA68     	 ldr r2,[r7,#12]
 2387 0018 1346     	 mov r3,r2
 2388 001a 5B00     	 lsls r3,r3,#1
 2389 001c 1344     	 add r3,r3,r2
 2390 001e 9B00     	 lsls r3,r3,#2
 2391 0020 1A46     	 mov r2,r3
 2392 0022 084B     	 ldr r3,.L159
 2393 0024 1344     	 add r3,r3,r2
 2394 0026 1A68     	 ldr r2,[r3]
 2395 0028 BB68     	 ldr r3,[r7,#8]
 2396 002a 1340     	 ands r3,r3,r2
 2397 002c 002B     	 cmp r3,#0
 2398 002e 14BF     	 ite ne
 2399 0030 0123     	 movne r3,#1
 2400 0032 0023     	 moveq r3,#0
 2401 0034 DBB2     	 uxtb r3,r3
 636:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2402              	 .loc 3 636 0
 2403 0036 1846     	 mov r0,r3
 2404 0038 1437     	 adds r7,r7,#20
 2405              	.LCFI229:
 2406              	 .cfi_def_cfa_offset 4
 2407 003a BD46     	 mov sp,r7
 2408              	.LCFI230:
 2409              	 .cfi_def_cfa_register 13
 2410              	 
 2411 003c 5DF8047B 	 ldr r7,[sp],#4
 2412              	.LCFI231:
 2413              	 .cfi_restore 7
 2414              	 .cfi_def_cfa_offset 0
 2415 0040 7047     	 bx lr
 2416              	.L160:
 2417 0042 00BF     	 .align 2
 2418              	.L159:
 2419 0044 0C440050 	 .word 1342194700
 2420              	 .cfi_endproc
 2421              	.LFE191:
 2423              	 .section .text.XMC_SCU_CLOCK_GetSystemPllClockFrequency,"ax",%progbits
 2424              	 .align 2
 2425              	 .global XMC_SCU_CLOCK_GetSystemPllClockFrequency
 2426              	 .thumb
 2427              	 .thumb_func
 2429              	XMC_SCU_CLOCK_GetSystemPllClockFrequency:
 2430              	.LFB192:
 637:../Libraries/XMCLib/src/xmc4_scu.c **** 
 638:../Libraries/XMCLib/src/xmc4_scu.c **** /*
 639:../Libraries/XMCLib/src/xmc4_scu.c ****  * API to retrieve frequency of System PLL output clock
 640:../Libraries/XMCLib/src/xmc4_scu.c ****  */
 641:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_CLOCK_GetSystemPllClockFrequency(void)
 642:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2431              	 .loc 3 642 0
 2432              	 .cfi_startproc
 2433              	 
 2434              	 
 2435 0000 80B5     	 push {r7,lr}
 2436              	.LCFI232:
 2437              	 .cfi_def_cfa_offset 8
 2438              	 .cfi_offset 7,-8
 2439              	 .cfi_offset 14,-4
 2440 0002 84B0     	 sub sp,sp,#16
 2441              	.LCFI233:
 2442              	 .cfi_def_cfa_offset 24
 2443 0004 00AF     	 add r7,sp,#0
 2444              	.LCFI234:
 2445              	 .cfi_def_cfa_register 7
 643:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t clock_frequency;
 644:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t p_div;
 645:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t n_div;
 646:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t k2_div;
 647:../Libraries/XMCLib/src/xmc4_scu.c **** 
 648:../Libraries/XMCLib/src/xmc4_scu.c ****   clock_frequency = XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency();
 2446              	 .loc 3 648 0
 2447 0006 FFF7FEFF 	 bl XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency
 2448 000a F860     	 str r0,[r7,#12]
 649:../Libraries/XMCLib/src/xmc4_scu.c ****   if(SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk)
 2449              	 .loc 3 649 0
 2450 000c 1A4B     	 ldr r3,.L165
 2451 000e 1B68     	 ldr r3,[r3]
 2452 0010 03F00103 	 and r3,r3,#1
 2453 0014 002B     	 cmp r3,#0
 2454 0016 09D0     	 beq .L162
 650:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 651:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Prescalar mode - fOSC is the parent*/
 652:../Libraries/XMCLib/src/xmc4_scu.c ****     clock_frequency = (uint32_t)(clock_frequency / 
 653:../Libraries/XMCLib/src/xmc4_scu.c ****                       ((((SCU_PLL->PLLCON1) & SCU_PLL_PLLCON1_K1DIV_Msk) >> SCU_PLL_PLLCON1_K1DIV_P
 2455              	 .loc 3 653 0
 2456 0018 174B     	 ldr r3,.L165
 2457 001a 9B68     	 ldr r3,[r3,#8]
 2458 001c 03F07F03 	 and r3,r3,#127
 2459 0020 0133     	 adds r3,r3,#1
 652:../Libraries/XMCLib/src/xmc4_scu.c ****                       ((((SCU_PLL->PLLCON1) & SCU_PLL_PLLCON1_K1DIV_Msk) >> SCU_PLL_PLLCON1_K1DIV_P
 2460              	 .loc 3 652 0
 2461 0022 FA68     	 ldr r2,[r7,#12]
 2462 0024 B2FBF3F3 	 udiv r3,r2,r3
 2463 0028 FB60     	 str r3,[r7,#12]
 2464 002a 1FE0     	 b .L163
 2465              	.L162:
 654:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 655:../Libraries/XMCLib/src/xmc4_scu.c ****   else
 656:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 657:../Libraries/XMCLib/src/xmc4_scu.c ****     p_div  = (uint32_t)((((SCU_PLL->PLLCON1) & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Po
 2466              	 .loc 3 657 0
 2467 002c 124B     	 ldr r3,.L165
 2468 002e 9B68     	 ldr r3,[r3,#8]
 2469 0030 03F07063 	 and r3,r3,#251658240
 2470 0034 1B0E     	 lsrs r3,r3,#24
 2471 0036 0133     	 adds r3,r3,#1
 2472 0038 BB60     	 str r3,[r7,#8]
 658:../Libraries/XMCLib/src/xmc4_scu.c ****     n_div  = (uint32_t)((((SCU_PLL->PLLCON1) & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Po
 2473              	 .loc 3 658 0
 2474 003a 0F4B     	 ldr r3,.L165
 2475 003c 9B68     	 ldr r3,[r3,#8]
 2476 003e 03F4FE43 	 and r3,r3,#32512
 2477 0042 1B0A     	 lsrs r3,r3,#8
 2478 0044 0133     	 adds r3,r3,#1
 2479 0046 7B60     	 str r3,[r7,#4]
 659:../Libraries/XMCLib/src/xmc4_scu.c ****     k2_div = (uint32_t)((((SCU_PLL->PLLCON1) & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_
 2480              	 .loc 3 659 0
 2481 0048 0B4B     	 ldr r3,.L165
 2482 004a 9B68     	 ldr r3,[r3,#8]
 2483 004c 03F4FE03 	 and r3,r3,#8323072
 2484 0050 1B0C     	 lsrs r3,r3,#16
 2485 0052 0133     	 adds r3,r3,#1
 2486 0054 3B60     	 str r3,[r7]
 660:../Libraries/XMCLib/src/xmc4_scu.c ****        
 661:../Libraries/XMCLib/src/xmc4_scu.c ****     clock_frequency = (clock_frequency * n_div) / (p_div * k2_div);
 2487              	 .loc 3 661 0
 2488 0056 FB68     	 ldr r3,[r7,#12]
 2489 0058 7A68     	 ldr r2,[r7,#4]
 2490 005a 02FB03F2 	 mul r2,r2,r3
 2491 005e BB68     	 ldr r3,[r7,#8]
 2492 0060 3968     	 ldr r1,[r7]
 2493 0062 01FB03F3 	 mul r3,r1,r3
 2494 0066 B2FBF3F3 	 udiv r3,r2,r3
 2495 006a FB60     	 str r3,[r7,#12]
 2496              	.L163:
 662:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 663:../Libraries/XMCLib/src/xmc4_scu.c **** 
 664:../Libraries/XMCLib/src/xmc4_scu.c ****   return (clock_frequency);
 2497              	 .loc 3 664 0
 2498 006c FB68     	 ldr r3,[r7,#12]
 665:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2499              	 .loc 3 665 0
 2500 006e 1846     	 mov r0,r3
 2501 0070 1037     	 adds r7,r7,#16
 2502              	.LCFI235:
 2503              	 .cfi_def_cfa_offset 8
 2504 0072 BD46     	 mov sp,r7
 2505              	.LCFI236:
 2506              	 .cfi_def_cfa_register 13
 2507              	 
 2508 0074 80BD     	 pop {r7,pc}
 2509              	.L166:
 2510 0076 00BF     	 .align 2
 2511              	.L165:
 2512 0078 10470050 	 .word 1342195472
 2513              	 .cfi_endproc
 2514              	.LFE192:
 2516              	 .section .text.XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency,"ax",%progbits
 2517              	 .align 2
 2518              	 .global XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency
 2519              	 .thumb
 2520              	 .thumb_func
 2522              	XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency:
 2523              	.LFB193:
 666:../Libraries/XMCLib/src/xmc4_scu.c **** 
 667:../Libraries/XMCLib/src/xmc4_scu.c **** /**
 668:../Libraries/XMCLib/src/xmc4_scu.c ****  * API to retrieve frequency of System PLL VCO input clock
 669:../Libraries/XMCLib/src/xmc4_scu.c ****  */
 670:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency(void)
 671:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2524              	 .loc 3 671 0
 2525              	 .cfi_startproc
 2526              	 
 2527              	 
 2528 0000 80B5     	 push {r7,lr}
 2529              	.LCFI237:
 2530              	 .cfi_def_cfa_offset 8
 2531              	 .cfi_offset 7,-8
 2532              	 .cfi_offset 14,-4
 2533 0002 82B0     	 sub sp,sp,#8
 2534              	.LCFI238:
 2535              	 .cfi_def_cfa_offset 16
 2536 0004 00AF     	 add r7,sp,#0
 2537              	.LCFI239:
 2538              	 .cfi_def_cfa_register 7
 672:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t clock_frequency;
 673:../Libraries/XMCLib/src/xmc4_scu.c **** 
 674:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Prescalar mode - fOSC is the parent*/
 675:../Libraries/XMCLib/src/xmc4_scu.c ****   if((SCU_PLL->PLLCON2 & SCU_PLL_PLLCON2_PINSEL_Msk) == (uint32_t)XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP)
 2539              	 .loc 3 675 0
 2540 0006 084B     	 ldr r3,.L171
 2541 0008 DB68     	 ldr r3,[r3,#12]
 2542 000a 03F00103 	 and r3,r3,#1
 2543 000e 002B     	 cmp r3,#0
 2544 0010 03D1     	 bne .L168
 676:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 677:../Libraries/XMCLib/src/xmc4_scu.c ****     clock_frequency = OSCHP_GetFrequency();
 2545              	 .loc 3 677 0
 2546 0012 FFF7FEFF 	 bl OSCHP_GetFrequency
 2547 0016 7860     	 str r0,[r7,#4]
 2548 0018 01E0     	 b .L169
 2549              	.L168:
 678:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 679:../Libraries/XMCLib/src/xmc4_scu.c ****   else
 680:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 681:../Libraries/XMCLib/src/xmc4_scu.c ****     clock_frequency = OFI_FREQUENCY;
 2550              	 .loc 3 681 0
 2551 001a 044B     	 ldr r3,.L171+4
 2552 001c 7B60     	 str r3,[r7,#4]
 2553              	.L169:
 682:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 683:../Libraries/XMCLib/src/xmc4_scu.c ****   
 684:../Libraries/XMCLib/src/xmc4_scu.c ****   return (clock_frequency);
 2554              	 .loc 3 684 0
 2555 001e 7B68     	 ldr r3,[r7,#4]
 685:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2556              	 .loc 3 685 0
 2557 0020 1846     	 mov r0,r3
 2558 0022 0837     	 adds r7,r7,#8
 2559              	.LCFI240:
 2560              	 .cfi_def_cfa_offset 8
 2561 0024 BD46     	 mov sp,r7
 2562              	.LCFI241:
 2563              	 .cfi_def_cfa_register 13
 2564              	 
 2565 0026 80BD     	 pop {r7,pc}
 2566              	.L172:
 2567              	 .align 2
 2568              	.L171:
 2569 0028 10470050 	 .word 1342195472
 2570 002c 00366E01 	 .word 24000000
 2571              	 .cfi_endproc
 2572              	.LFE193:
 2574              	 .section .text.XMC_SCU_CLOCK_GetUsbPllClockFrequency,"ax",%progbits
 2575              	 .align 2
 2576              	 .global XMC_SCU_CLOCK_GetUsbPllClockFrequency
 2577              	 .thumb
 2578              	 .thumb_func
 2580              	XMC_SCU_CLOCK_GetUsbPllClockFrequency:
 2581              	.LFB194:
 686:../Libraries/XMCLib/src/xmc4_scu.c **** 
 687:../Libraries/XMCLib/src/xmc4_scu.c **** /*
 688:../Libraries/XMCLib/src/xmc4_scu.c ****  * API to retrieve frequency of USB PLL output clock
 689:../Libraries/XMCLib/src/xmc4_scu.c ****  */
 690:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_CLOCK_GetUsbPllClockFrequency(void)
 691:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2582              	 .loc 3 691 0
 2583              	 .cfi_startproc
 2584              	 
 2585              	 
 2586 0000 80B5     	 push {r7,lr}
 2587              	.LCFI242:
 2588              	 .cfi_def_cfa_offset 8
 2589              	 .cfi_offset 7,-8
 2590              	 .cfi_offset 14,-4
 2591 0002 84B0     	 sub sp,sp,#16
 2592              	.LCFI243:
 2593              	 .cfi_def_cfa_offset 24
 2594 0004 00AF     	 add r7,sp,#0
 2595              	.LCFI244:
 2596              	 .cfi_def_cfa_register 7
 692:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t clock_frequency;
 693:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t n_div;
 694:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t p_div;
 695:../Libraries/XMCLib/src/xmc4_scu.c ****   
 696:../Libraries/XMCLib/src/xmc4_scu.c ****   clock_frequency = OSCHP_GetFrequency();
 2597              	 .loc 3 696 0
 2598 0006 FFF7FEFF 	 bl OSCHP_GetFrequency
 2599 000a F860     	 str r0,[r7,#12]
 697:../Libraries/XMCLib/src/xmc4_scu.c ****   if((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOBYST_Msk) == 0U)
 2600              	 .loc 3 697 0
 2601 000c 104B     	 ldr r3,.L176
 2602 000e 1B69     	 ldr r3,[r3,#16]
 2603 0010 03F00103 	 and r3,r3,#1
 2604 0014 002B     	 cmp r3,#0
 2605 0016 16D1     	 bne .L174
 698:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 699:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Normal mode - fVCO is the parent*/
 700:../Libraries/XMCLib/src/xmc4_scu.c ****     n_div = (uint32_t)((((SCU_PLL->USBPLLCON) & SCU_PLL_USBPLLCON_NDIV_Msk) >> SCU_PLL_USBPLLCON_ND
 2606              	 .loc 3 700 0
 2607 0018 0D4B     	 ldr r3,.L176
 2608 001a 5B69     	 ldr r3,[r3,#20]
 2609 001c 03F4FE43 	 and r3,r3,#32512
 2610 0020 1B0A     	 lsrs r3,r3,#8
 2611 0022 0133     	 adds r3,r3,#1
 2612 0024 BB60     	 str r3,[r7,#8]
 701:../Libraries/XMCLib/src/xmc4_scu.c ****     p_div = (uint32_t)((((SCU_PLL->USBPLLCON) & SCU_PLL_USBPLLCON_PDIV_Msk) >> SCU_PLL_USBPLLCON_PD
 2613              	 .loc 3 701 0
 2614 0026 0A4B     	 ldr r3,.L176
 2615 0028 5B69     	 ldr r3,[r3,#20]
 2616 002a 03F07063 	 and r3,r3,#251658240
 2617 002e 1B0E     	 lsrs r3,r3,#24
 2618 0030 0133     	 adds r3,r3,#1
 2619 0032 7B60     	 str r3,[r7,#4]
 702:../Libraries/XMCLib/src/xmc4_scu.c ****     clock_frequency = (uint32_t)((clock_frequency * n_div)/ (uint32_t)(p_div * 2UL));
 2620              	 .loc 3 702 0
 2621 0034 FB68     	 ldr r3,[r7,#12]
 2622 0036 BA68     	 ldr r2,[r7,#8]
 2623 0038 02FB03F2 	 mul r2,r2,r3
 2624 003c 7B68     	 ldr r3,[r7,#4]
 2625 003e 5B00     	 lsls r3,r3,#1
 2626 0040 B2FBF3F3 	 udiv r3,r2,r3
 2627 0044 FB60     	 str r3,[r7,#12]
 2628              	.L174:
 703:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 704:../Libraries/XMCLib/src/xmc4_scu.c ****   return (clock_frequency);
 2629              	 .loc 3 704 0
 2630 0046 FB68     	 ldr r3,[r7,#12]
 705:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2631              	 .loc 3 705 0
 2632 0048 1846     	 mov r0,r3
 2633 004a 1037     	 adds r7,r7,#16
 2634              	.LCFI245:
 2635              	 .cfi_def_cfa_offset 8
 2636 004c BD46     	 mov sp,r7
 2637              	.LCFI246:
 2638              	 .cfi_def_cfa_register 13
 2639              	 
 2640 004e 80BD     	 pop {r7,pc}
 2641              	.L177:
 2642              	 .align 2
 2643              	.L176:
 2644 0050 10470050 	 .word 1342195472
 2645              	 .cfi_endproc
 2646              	.LFE194:
 2648              	 .section .text.XMC_SCU_CLOCK_GetCcuClockFrequency,"ax",%progbits
 2649              	 .align 2
 2650              	 .global XMC_SCU_CLOCK_GetCcuClockFrequency
 2651              	 .thumb
 2652              	 .thumb_func
 2654              	XMC_SCU_CLOCK_GetCcuClockFrequency:
 2655              	.LFB195:
 706:../Libraries/XMCLib/src/xmc4_scu.c **** 
 707:../Libraries/XMCLib/src/xmc4_scu.c **** /*
 708:../Libraries/XMCLib/src/xmc4_scu.c ****  * API to retrieve frequency of CCU clock frequency
 709:../Libraries/XMCLib/src/xmc4_scu.c ****  */
 710:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_CLOCK_GetCcuClockFrequency(void)
 711:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2656              	 .loc 3 711 0
 2657              	 .cfi_startproc
 2658              	 
 2659              	 
 2660 0000 80B5     	 push {r7,lr}
 2661              	.LCFI247:
 2662              	 .cfi_def_cfa_offset 8
 2663              	 .cfi_offset 7,-8
 2664              	 .cfi_offset 14,-4
 2665 0002 82B0     	 sub sp,sp,#8
 2666              	.LCFI248:
 2667              	 .cfi_def_cfa_offset 16
 2668 0004 00AF     	 add r7,sp,#0
 2669              	.LCFI249:
 2670              	 .cfi_def_cfa_register 7
 712:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t frequency = 0UL;
 2671              	 .loc 3 712 0
 2672 0006 0023     	 movs r3,#0
 2673 0008 7B60     	 str r3,[r7,#4]
 713:../Libraries/XMCLib/src/xmc4_scu.c ****   frequency = XMC_SCU_CLOCK_GetSystemClockFrequency();
 2674              	 .loc 3 713 0
 2675 000a FFF7FEFF 	 bl XMC_SCU_CLOCK_GetSystemClockFrequency
 2676 000e 7860     	 str r0,[r7,#4]
 714:../Libraries/XMCLib/src/xmc4_scu.c ****   
 715:../Libraries/XMCLib/src/xmc4_scu.c ****   return (uint32_t)(frequency >> ((uint32_t)((SCU_CLK->CCUCLKCR & SCU_CLK_CCUCLKCR_CCUDIV_Msk) >>
 2677              	 .loc 3 715 0
 2678 0010 054B     	 ldr r3,.L180
 2679 0012 1B6A     	 ldr r3,[r3,#32]
 2680 0014 03F00103 	 and r3,r3,#1
 2681 0018 7A68     	 ldr r2,[r7,#4]
 2682 001a 22FA03F3 	 lsr r3,r2,r3
 716:../Libraries/XMCLib/src/xmc4_scu.c ****                                               SCU_CLK_CCUCLKCR_CCUDIV_Pos)));
 717:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2683              	 .loc 3 717 0
 2684 001e 1846     	 mov r0,r3
 2685 0020 0837     	 adds r7,r7,#8
 2686              	.LCFI250:
 2687              	 .cfi_def_cfa_offset 8
 2688 0022 BD46     	 mov sp,r7
 2689              	.LCFI251:
 2690              	 .cfi_def_cfa_register 13
 2691              	 
 2692 0024 80BD     	 pop {r7,pc}
 2693              	.L181:
 2694 0026 00BF     	 .align 2
 2695              	.L180:
 2696 0028 00460050 	 .word 1342195200
 2697              	 .cfi_endproc
 2698              	.LFE195:
 2700              	 .section .text.XMC_SCU_CLOCK_GetUsbClockFrequency,"ax",%progbits
 2701              	 .align 2
 2702              	 .global XMC_SCU_CLOCK_GetUsbClockFrequency
 2703              	 .thumb
 2704              	 .thumb_func
 2706              	XMC_SCU_CLOCK_GetUsbClockFrequency:
 2707              	.LFB196:
 718:../Libraries/XMCLib/src/xmc4_scu.c **** 
 719:../Libraries/XMCLib/src/xmc4_scu.c **** /*
 720:../Libraries/XMCLib/src/xmc4_scu.c ****  * API to retrieve USB and SDMMC clock frequency
 721:../Libraries/XMCLib/src/xmc4_scu.c ****  */
 722:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_CLOCK_GetUsbClockFrequency(void)
 723:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2708              	 .loc 3 723 0
 2709              	 .cfi_startproc
 2710              	 
 2711              	 
 2712 0000 80B5     	 push {r7,lr}
 2713              	.LCFI252:
 2714              	 .cfi_def_cfa_offset 8
 2715              	 .cfi_offset 7,-8
 2716              	 .cfi_offset 14,-4
 2717 0002 82B0     	 sub sp,sp,#8
 2718              	.LCFI253:
 2719              	 .cfi_def_cfa_offset 16
 2720 0004 00AF     	 add r7,sp,#0
 2721              	.LCFI254:
 2722              	 .cfi_def_cfa_register 7
 724:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t frequency = 0UL;
 2723              	 .loc 3 724 0
 2724 0006 0023     	 movs r3,#0
 2725 0008 7B60     	 str r3,[r7,#4]
 725:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_CLOCK_USBCLKSRC_t clksrc;
 726:../Libraries/XMCLib/src/xmc4_scu.c **** 
 727:../Libraries/XMCLib/src/xmc4_scu.c ****   clksrc = XMC_SCU_CLOCK_GetUsbClockSource();
 2726              	 .loc 3 727 0
 2727 000a FFF7FEFF 	 bl XMC_SCU_CLOCK_GetUsbClockSource
 2728 000e 3860     	 str r0,[r7]
 728:../Libraries/XMCLib/src/xmc4_scu.c **** 
 729:../Libraries/XMCLib/src/xmc4_scu.c ****   if (clksrc == XMC_SCU_CLOCK_USBCLKSRC_SYSPLL)
 2729              	 .loc 3 729 0
 2730 0010 3B68     	 ldr r3,[r7]
 2731 0012 B3F5803F 	 cmp r3,#65536
 2732 0016 03D1     	 bne .L183
 730:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 731:../Libraries/XMCLib/src/xmc4_scu.c ****     frequency = XMC_SCU_CLOCK_GetSystemPllClockFrequency();
 2733              	 .loc 3 731 0
 2734 0018 FFF7FEFF 	 bl XMC_SCU_CLOCK_GetSystemPllClockFrequency
 2735 001c 7860     	 str r0,[r7,#4]
 2736 001e 05E0     	 b .L184
 2737              	.L183:
 732:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 733:../Libraries/XMCLib/src/xmc4_scu.c ****   else if (clksrc == XMC_SCU_CLOCK_USBCLKSRC_USBPLL)
 2738              	 .loc 3 733 0
 2739 0020 3B68     	 ldr r3,[r7]
 2740 0022 002B     	 cmp r3,#0
 2741 0024 02D1     	 bne .L184
 734:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 735:../Libraries/XMCLib/src/xmc4_scu.c ****     frequency = XMC_SCU_CLOCK_GetUsbPllClockFrequency();
 2742              	 .loc 3 735 0
 2743 0026 FFF7FEFF 	 bl XMC_SCU_CLOCK_GetUsbPllClockFrequency
 2744 002a 7860     	 str r0,[r7,#4]
 2745              	.L184:
 736:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 737:../Libraries/XMCLib/src/xmc4_scu.c ****   else
 738:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 739:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 740:../Libraries/XMCLib/src/xmc4_scu.c **** 
 741:../Libraries/XMCLib/src/xmc4_scu.c ****   return (uint32_t)(frequency / (((SCU_CLK->USBCLKCR & SCU_CLK_USBCLKCR_USBDIV_Msk) >>
 2746              	 .loc 3 741 0
 2747 002c 054B     	 ldr r3,.L186
 2748 002e 9B69     	 ldr r3,[r3,#24]
 2749 0030 03F00703 	 and r3,r3,#7
 742:../Libraries/XMCLib/src/xmc4_scu.c ****                                    SCU_CLK_USBCLKCR_USBDIV_Pos) + 1UL));
 2750              	 .loc 3 742 0
 2751 0034 0133     	 adds r3,r3,#1
 741:../Libraries/XMCLib/src/xmc4_scu.c ****                                    SCU_CLK_USBCLKCR_USBDIV_Pos) + 1UL));
 2752              	 .loc 3 741 0
 2753 0036 7A68     	 ldr r2,[r7,#4]
 2754 0038 B2FBF3F3 	 udiv r3,r2,r3
 743:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2755              	 .loc 3 743 0
 2756 003c 1846     	 mov r0,r3
 2757 003e 0837     	 adds r7,r7,#8
 2758              	.LCFI255:
 2759              	 .cfi_def_cfa_offset 8
 2760 0040 BD46     	 mov sp,r7
 2761              	.LCFI256:
 2762              	 .cfi_def_cfa_register 13
 2763              	 
 2764 0042 80BD     	 pop {r7,pc}
 2765              	.L187:
 2766              	 .align 2
 2767              	.L186:
 2768 0044 00460050 	 .word 1342195200
 2769              	 .cfi_endproc
 2770              	.LFE196:
 2772              	 .section .text.XMC_SCU_CLOCK_GetEbuClockFrequency,"ax",%progbits
 2773              	 .align 2
 2774              	 .global XMC_SCU_CLOCK_GetEbuClockFrequency
 2775              	 .thumb
 2776              	 .thumb_func
 2778              	XMC_SCU_CLOCK_GetEbuClockFrequency:
 2779              	.LFB197:
 744:../Libraries/XMCLib/src/xmc4_scu.c **** 
 745:../Libraries/XMCLib/src/xmc4_scu.c **** #if defined(EBU)
 746:../Libraries/XMCLib/src/xmc4_scu.c **** /*
 747:../Libraries/XMCLib/src/xmc4_scu.c ****  * API to retrieve EBU clock frequency
 748:../Libraries/XMCLib/src/xmc4_scu.c ****  */
 749:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_CLOCK_GetEbuClockFrequency(void)
 750:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2780              	 .loc 3 750 0
 2781              	 .cfi_startproc
 2782              	 
 2783              	 
 2784 0000 80B5     	 push {r7,lr}
 2785              	.LCFI257:
 2786              	 .cfi_def_cfa_offset 8
 2787              	 .cfi_offset 7,-8
 2788              	 .cfi_offset 14,-4
 2789 0002 82B0     	 sub sp,sp,#8
 2790              	.LCFI258:
 2791              	 .cfi_def_cfa_offset 16
 2792 0004 00AF     	 add r7,sp,#0
 2793              	.LCFI259:
 2794              	 .cfi_def_cfa_register 7
 751:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t frequency = XMC_SCU_CLOCK_GetSystemPllClockFrequency();
 2795              	 .loc 3 751 0
 2796 0006 FFF7FEFF 	 bl XMC_SCU_CLOCK_GetSystemPllClockFrequency
 2797 000a 7860     	 str r0,[r7,#4]
 752:../Libraries/XMCLib/src/xmc4_scu.c ****   
 753:../Libraries/XMCLib/src/xmc4_scu.c ****   return (uint32_t)((frequency /(((SCU_CLK->EBUCLKCR & SCU_CLK_EBUCLKCR_EBUDIV_Msk) >>
 2798              	 .loc 3 753 0
 2799 000c 054B     	 ldr r3,.L190
 2800 000e DB69     	 ldr r3,[r3,#28]
 2801 0010 03F03F03 	 and r3,r3,#63
 754:../Libraries/XMCLib/src/xmc4_scu.c ****                                    SCU_CLK_EBUCLKCR_EBUDIV_Pos) + 1UL)));
 2802              	 .loc 3 754 0
 2803 0014 0133     	 adds r3,r3,#1
 753:../Libraries/XMCLib/src/xmc4_scu.c ****                                    SCU_CLK_EBUCLKCR_EBUDIV_Pos) + 1UL)));
 2804              	 .loc 3 753 0
 2805 0016 7A68     	 ldr r2,[r7,#4]
 2806 0018 B2FBF3F3 	 udiv r3,r2,r3
 755:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2807              	 .loc 3 755 0
 2808 001c 1846     	 mov r0,r3
 2809 001e 0837     	 adds r7,r7,#8
 2810              	.LCFI260:
 2811              	 .cfi_def_cfa_offset 8
 2812 0020 BD46     	 mov sp,r7
 2813              	.LCFI261:
 2814              	 .cfi_def_cfa_register 13
 2815              	 
 2816 0022 80BD     	 pop {r7,pc}
 2817              	.L191:
 2818              	 .align 2
 2819              	.L190:
 2820 0024 00460050 	 .word 1342195200
 2821              	 .cfi_endproc
 2822              	.LFE197:
 2824              	 .section .text.XMC_SCU_CLOCK_GetWdtClockFrequency,"ax",%progbits
 2825              	 .align 2
 2826              	 .global XMC_SCU_CLOCK_GetWdtClockFrequency
 2827              	 .thumb
 2828              	 .thumb_func
 2830              	XMC_SCU_CLOCK_GetWdtClockFrequency:
 2831              	.LFB198:
 756:../Libraries/XMCLib/src/xmc4_scu.c **** #endif
 757:../Libraries/XMCLib/src/xmc4_scu.c **** 
 758:../Libraries/XMCLib/src/xmc4_scu.c **** #if defined(ECAT0)
 759:../Libraries/XMCLib/src/xmc4_scu.c **** /*
 760:../Libraries/XMCLib/src/xmc4_scu.c ****  * API to retrieve ECAT clock frequency
 761:../Libraries/XMCLib/src/xmc4_scu.c ****  */
 762:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_CLOCK_GetECATClockFrequency(void)
 763:../Libraries/XMCLib/src/xmc4_scu.c **** {
 764:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t frequency;
 765:../Libraries/XMCLib/src/xmc4_scu.c **** 
 766:../Libraries/XMCLib/src/xmc4_scu.c ****   if ((SCU_CLK->ECATCLKCR & SCU_CLK_ECATCLKCR_ECATSEL_Msk) != 0U)
 767:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 768:../Libraries/XMCLib/src/xmc4_scu.c ****     frequency =  XMC_SCU_CLOCK_GetSystemPllClockFrequency();
 769:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 770:../Libraries/XMCLib/src/xmc4_scu.c ****   else
 771:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 772:../Libraries/XMCLib/src/xmc4_scu.c ****     frequency =  XMC_SCU_CLOCK_GetUsbPllClockFrequency();
 773:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 774:../Libraries/XMCLib/src/xmc4_scu.c **** 
 775:../Libraries/XMCLib/src/xmc4_scu.c ****   return (uint32_t)((frequency / (XMC_SCU_CLOCK_GetECATClockDivider() + 1UL)));
 776:../Libraries/XMCLib/src/xmc4_scu.c **** }
 777:../Libraries/XMCLib/src/xmc4_scu.c **** #endif
 778:../Libraries/XMCLib/src/xmc4_scu.c **** 
 779:../Libraries/XMCLib/src/xmc4_scu.c **** /*
 780:../Libraries/XMCLib/src/xmc4_scu.c ****  * API to retrieve WDT clock frequency
 781:../Libraries/XMCLib/src/xmc4_scu.c ****  */
 782:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_CLOCK_GetWdtClockFrequency(void)
 783:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2832              	 .loc 3 783 0
 2833              	 .cfi_startproc
 2834              	 
 2835              	 
 2836 0000 80B5     	 push {r7,lr}
 2837              	.LCFI262:
 2838              	 .cfi_def_cfa_offset 8
 2839              	 .cfi_offset 7,-8
 2840              	 .cfi_offset 14,-4
 2841 0002 82B0     	 sub sp,sp,#8
 2842              	.LCFI263:
 2843              	 .cfi_def_cfa_offset 16
 2844 0004 00AF     	 add r7,sp,#0
 2845              	.LCFI264:
 2846              	 .cfi_def_cfa_register 7
 784:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t frequency = 0UL;
 2847              	 .loc 3 784 0
 2848 0006 0023     	 movs r3,#0
 2849 0008 7B60     	 str r3,[r7,#4]
 785:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_CLOCK_WDTCLKSRC_t clksrc;
 786:../Libraries/XMCLib/src/xmc4_scu.c **** 
 787:../Libraries/XMCLib/src/xmc4_scu.c ****   clksrc = XMC_SCU_CLOCK_GetWdtClockSource();
 2850              	 .loc 3 787 0
 2851 000a FFF7FEFF 	 bl XMC_SCU_CLOCK_GetWdtClockSource
 2852 000e 3860     	 str r0,[r7]
 788:../Libraries/XMCLib/src/xmc4_scu.c **** 
 789:../Libraries/XMCLib/src/xmc4_scu.c ****   if (clksrc == XMC_SCU_CLOCK_WDTCLKSRC_PLL)
 2853              	 .loc 3 789 0
 2854 0010 3B68     	 ldr r3,[r7]
 2855 0012 B3F5003F 	 cmp r3,#131072
 2856 0016 03D1     	 bne .L193
 790:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 791:../Libraries/XMCLib/src/xmc4_scu.c ****     frequency = XMC_SCU_CLOCK_GetSystemPllClockFrequency();
 2857              	 .loc 3 791 0
 2858 0018 FFF7FEFF 	 bl XMC_SCU_CLOCK_GetSystemPllClockFrequency
 2859 001c 7860     	 str r0,[r7,#4]
 2860 001e 0CE0     	 b .L194
 2861              	.L193:
 792:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 793:../Libraries/XMCLib/src/xmc4_scu.c ****   else if (clksrc == XMC_SCU_CLOCK_WDTCLKSRC_OFI)
 2862              	 .loc 3 793 0
 2863 0020 3B68     	 ldr r3,[r7]
 2864 0022 002B     	 cmp r3,#0
 2865 0024 02D1     	 bne .L195
 794:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 795:../Libraries/XMCLib/src/xmc4_scu.c ****     frequency = OFI_FREQUENCY;
 2866              	 .loc 3 795 0
 2867 0026 0A4B     	 ldr r3,.L197
 2868 0028 7B60     	 str r3,[r7,#4]
 2869 002a 06E0     	 b .L194
 2870              	.L195:
 796:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 797:../Libraries/XMCLib/src/xmc4_scu.c ****   else if (clksrc == XMC_SCU_CLOCK_WDTCLKSRC_STDBY)
 2871              	 .loc 3 797 0
 2872 002c 3B68     	 ldr r3,[r7]
 2873 002e B3F5803F 	 cmp r3,#65536
 2874 0032 02D1     	 bne .L194
 798:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 799:../Libraries/XMCLib/src/xmc4_scu.c ****     frequency = OSI_FREQUENCY;
 2875              	 .loc 3 799 0
 2876 0034 4FF40043 	 mov r3,#32768
 2877 0038 7B60     	 str r3,[r7,#4]
 2878              	.L194:
 800:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 801:../Libraries/XMCLib/src/xmc4_scu.c ****   else
 802:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 803:../Libraries/XMCLib/src/xmc4_scu.c **** 
 804:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 805:../Libraries/XMCLib/src/xmc4_scu.c **** 
 806:../Libraries/XMCLib/src/xmc4_scu.c ****   return (uint32_t)((frequency / (((SCU_CLK->WDTCLKCR & SCU_CLK_WDTCLKCR_WDTDIV_Msk) >>
 2879              	 .loc 3 806 0
 2880 003a 064B     	 ldr r3,.L197+4
 2881 003c 5B6A     	 ldr r3,[r3,#36]
 2882 003e DBB2     	 uxtb r3,r3
 807:../Libraries/XMCLib/src/xmc4_scu.c ****                                     SCU_CLK_WDTCLKCR_WDTDIV_Pos) + 1UL)));
 2883              	 .loc 3 807 0
 2884 0040 0133     	 adds r3,r3,#1
 806:../Libraries/XMCLib/src/xmc4_scu.c ****                                     SCU_CLK_WDTCLKCR_WDTDIV_Pos) + 1UL)));
 2885              	 .loc 3 806 0
 2886 0042 7A68     	 ldr r2,[r7,#4]
 2887 0044 B2FBF3F3 	 udiv r3,r2,r3
 808:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2888              	 .loc 3 808 0
 2889 0048 1846     	 mov r0,r3
 2890 004a 0837     	 adds r7,r7,#8
 2891              	.LCFI265:
 2892              	 .cfi_def_cfa_offset 8
 2893 004c BD46     	 mov sp,r7
 2894              	.LCFI266:
 2895              	 .cfi_def_cfa_register 13
 2896              	 
 2897 004e 80BD     	 pop {r7,pc}
 2898              	.L198:
 2899              	 .align 2
 2900              	.L197:
 2901 0050 00366E01 	 .word 24000000
 2902 0054 00460050 	 .word 1342195200
 2903              	 .cfi_endproc
 2904              	.LFE198:
 2906              	 .section .text.XMC_SCU_CLOCK_GetExternalOutputClockFrequency,"ax",%progbits
 2907              	 .align 2
 2908              	 .global XMC_SCU_CLOCK_GetExternalOutputClockFrequency
 2909              	 .thumb
 2910              	 .thumb_func
 2912              	XMC_SCU_CLOCK_GetExternalOutputClockFrequency:
 2913              	.LFB199:
 809:../Libraries/XMCLib/src/xmc4_scu.c **** 
 810:../Libraries/XMCLib/src/xmc4_scu.c **** /**
 811:../Libraries/XMCLib/src/xmc4_scu.c ****  * @brief API to retrieve EXTERNAL-OUT clock frequency
 812:../Libraries/XMCLib/src/xmc4_scu.c ****  * @retval Clock frequency
 813:../Libraries/XMCLib/src/xmc4_scu.c ****  */
 814:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_CLOCK_GetExternalOutputClockFrequency(void)
 815:../Libraries/XMCLib/src/xmc4_scu.c **** {
 2914              	 .loc 3 815 0
 2915              	 .cfi_startproc
 2916              	 
 2917              	 
 2918 0000 80B5     	 push {r7,lr}
 2919              	.LCFI267:
 2920              	 .cfi_def_cfa_offset 8
 2921              	 .cfi_offset 7,-8
 2922              	 .cfi_offset 14,-4
 2923 0002 82B0     	 sub sp,sp,#8
 2924              	.LCFI268:
 2925              	 .cfi_def_cfa_offset 16
 2926 0004 00AF     	 add r7,sp,#0
 2927              	.LCFI269:
 2928              	 .cfi_def_cfa_register 7
 816:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t frequency = 0UL;
 2929              	 .loc 3 816 0
 2930 0006 0023     	 movs r3,#0
 2931 0008 7B60     	 str r3,[r7,#4]
 817:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_CLOCK_EXTOUTCLKSRC_t clksrc;
 818:../Libraries/XMCLib/src/xmc4_scu.c **** 
 819:../Libraries/XMCLib/src/xmc4_scu.c ****   clksrc = XMC_SCU_CLOCK_GetExternalOutputClockSource();
 2932              	 .loc 3 819 0
 2933 000a FFF7FEFF 	 bl XMC_SCU_CLOCK_GetExternalOutputClockSource
 2934 000e 0346     	 mov r3,r0
 2935 0010 FB70     	 strb r3,[r7,#3]
 820:../Libraries/XMCLib/src/xmc4_scu.c **** 
 821:../Libraries/XMCLib/src/xmc4_scu.c ****   if (clksrc == XMC_SCU_CLOCK_EXTOUTCLKSRC_PLL)
 2936              	 .loc 3 821 0
 2937 0012 FB78     	 ldrb r3,[r7,#3]
 2938 0014 032B     	 cmp r3,#3
 2939 0016 0DD1     	 bne .L200
 822:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 823:../Libraries/XMCLib/src/xmc4_scu.c ****     frequency = XMC_SCU_CLOCK_GetSystemPllClockFrequency();
 2940              	 .loc 3 823 0
 2941 0018 FFF7FEFF 	 bl XMC_SCU_CLOCK_GetSystemPllClockFrequency
 2942 001c 7860     	 str r0,[r7,#4]
 824:../Libraries/XMCLib/src/xmc4_scu.c ****     
 825:../Libraries/XMCLib/src/xmc4_scu.c ****     frequency = (uint32_t)((frequency / ((((SCU_CLK->EXTCLKCR) & SCU_CLK_EXTCLKCR_ECKDIV_Msk) >>
 2943              	 .loc 3 825 0
 2944 001e 134B     	 ldr r3,.L204
 2945 0020 9A6A     	 ldr r2,[r3,#40]
 2946 0022 134B     	 ldr r3,.L204+4
 2947 0024 1340     	 ands r3,r3,r2
 2948 0026 1B0C     	 lsrs r3,r3,#16
 826:../Libraries/XMCLib/src/xmc4_scu.c ****                  SCU_CLK_EXTCLKCR_ECKDIV_Pos)+ 1UL)));
 2949              	 .loc 3 826 0
 2950 0028 0133     	 adds r3,r3,#1
 825:../Libraries/XMCLib/src/xmc4_scu.c ****                  SCU_CLK_EXTCLKCR_ECKDIV_Pos)+ 1UL)));
 2951              	 .loc 3 825 0
 2952 002a 7A68     	 ldr r2,[r7,#4]
 2953 002c B2FBF3F3 	 udiv r3,r2,r3
 2954 0030 7B60     	 str r3,[r7,#4]
 2955 0032 16E0     	 b .L201
 2956              	.L200:
 827:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 828:../Libraries/XMCLib/src/xmc4_scu.c ****   else if (clksrc == XMC_SCU_CLOCK_EXTOUTCLKSRC_SYS)
 2957              	 .loc 3 828 0
 2958 0034 FB78     	 ldrb r3,[r7,#3]
 2959 0036 002B     	 cmp r3,#0
 2960 0038 03D1     	 bne .L202
 829:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 830:../Libraries/XMCLib/src/xmc4_scu.c ****     frequency = XMC_SCU_CLOCK_GetSystemClockFrequency();
 2961              	 .loc 3 830 0
 2962 003a FFF7FEFF 	 bl XMC_SCU_CLOCK_GetSystemClockFrequency
 2963 003e 7860     	 str r0,[r7,#4]
 2964 0040 0FE0     	 b .L201
 2965              	.L202:
 831:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 832:../Libraries/XMCLib/src/xmc4_scu.c ****   else if (clksrc == XMC_SCU_CLOCK_EXTOUTCLKSRC_USB)
 2966              	 .loc 3 832 0
 2967 0042 FB78     	 ldrb r3,[r7,#3]
 2968 0044 022B     	 cmp r3,#2
 2969 0046 0CD1     	 bne .L201
 833:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 834:../Libraries/XMCLib/src/xmc4_scu.c ****     frequency = XMC_SCU_CLOCK_GetUsbPllClockFrequency();
 2970              	 .loc 3 834 0
 2971 0048 FFF7FEFF 	 bl XMC_SCU_CLOCK_GetUsbPllClockFrequency
 2972 004c 7860     	 str r0,[r7,#4]
 835:../Libraries/XMCLib/src/xmc4_scu.c ****     
 836:../Libraries/XMCLib/src/xmc4_scu.c ****     frequency = (uint32_t)((frequency / ((((SCU_CLK->EXTCLKCR) & SCU_CLK_EXTCLKCR_ECKDIV_Msk) >>
 2973              	 .loc 3 836 0
 2974 004e 074B     	 ldr r3,.L204
 2975 0050 9A6A     	 ldr r2,[r3,#40]
 2976 0052 074B     	 ldr r3,.L204+4
 2977 0054 1340     	 ands r3,r3,r2
 2978 0056 1B0C     	 lsrs r3,r3,#16
 837:../Libraries/XMCLib/src/xmc4_scu.c ****                  SCU_CLK_EXTCLKCR_ECKDIV_Pos)+ 1UL)));
 2979              	 .loc 3 837 0
 2980 0058 0133     	 adds r3,r3,#1
 836:../Libraries/XMCLib/src/xmc4_scu.c ****                  SCU_CLK_EXTCLKCR_ECKDIV_Pos)+ 1UL)));
 2981              	 .loc 3 836 0
 2982 005a 7A68     	 ldr r2,[r7,#4]
 2983 005c B2FBF3F3 	 udiv r3,r2,r3
 2984 0060 7B60     	 str r3,[r7,#4]
 2985              	.L201:
 838:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 839:../Libraries/XMCLib/src/xmc4_scu.c ****   else
 840:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 841:../Libraries/XMCLib/src/xmc4_scu.c **** 
 842:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 843:../Libraries/XMCLib/src/xmc4_scu.c **** 
 844:../Libraries/XMCLib/src/xmc4_scu.c ****   return (frequency);
 2986              	 .loc 3 844 0
 2987 0062 7B68     	 ldr r3,[r7,#4]
 845:../Libraries/XMCLib/src/xmc4_scu.c **** }
 2988              	 .loc 3 845 0
 2989 0064 1846     	 mov r0,r3
 2990 0066 0837     	 adds r7,r7,#8
 2991              	.LCFI270:
 2992              	 .cfi_def_cfa_offset 8
 2993 0068 BD46     	 mov sp,r7
 2994              	.LCFI271:
 2995              	 .cfi_def_cfa_register 13
 2996              	 
 2997 006a 80BD     	 pop {r7,pc}
 2998              	.L205:
 2999              	 .align 2
 3000              	.L204:
 3001 006c 00460050 	 .word 1342195200
 3002 0070 0000FF01 	 .word 33488896
 3003              	 .cfi_endproc
 3004              	.LFE199:
 3006              	 .section .text.XMC_SCU_CLOCK_GetPeripheralClockFrequency,"ax",%progbits
 3007              	 .align 2
 3008              	 .global XMC_SCU_CLOCK_GetPeripheralClockFrequency
 3009              	 .thumb
 3010              	 .thumb_func
 3012              	XMC_SCU_CLOCK_GetPeripheralClockFrequency:
 3013              	.LFB200:
 846:../Libraries/XMCLib/src/xmc4_scu.c **** 
 847:../Libraries/XMCLib/src/xmc4_scu.c **** /*
 848:../Libraries/XMCLib/src/xmc4_scu.c ****  * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional c
 849:../Libraries/XMCLib/src/xmc4_scu.c ****  */
 850:../Libraries/XMCLib/src/xmc4_scu.c **** uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
 851:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3014              	 .loc 3 851 0
 3015              	 .cfi_startproc
 3016              	 
 3017              	 
 3018 0000 80B5     	 push {r7,lr}
 3019              	.LCFI272:
 3020              	 .cfi_def_cfa_offset 8
 3021              	 .cfi_offset 7,-8
 3022              	 .cfi_offset 14,-4
 3023 0002 00AF     	 add r7,sp,#0
 3024              	.LCFI273:
 3025              	 .cfi_def_cfa_register 7
 852:../Libraries/XMCLib/src/xmc4_scu.c ****   return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
 3026              	 .loc 3 852 0
 3027 0004 FFF7FEFF 	 bl XMC_SCU_CLOCK_GetCpuClockFrequency
 3028 0008 0246     	 mov r2,r0
 853:../Libraries/XMCLib/src/xmc4_scu.c ****          ((SCU_CLK->PBCLKCR & SCU_CLK_PBCLKCR_PBDIV_Msk) >> SCU_CLK_PBCLKCR_PBDIV_Pos));  
 3029              	 .loc 3 853 0
 3030 000a 044B     	 ldr r3,.L208
 3031 000c 5B69     	 ldr r3,[r3,#20]
 852:../Libraries/XMCLib/src/xmc4_scu.c ****   return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
 3032              	 .loc 3 852 0
 3033 000e 03F00103 	 and r3,r3,#1
 3034 0012 22FA03F3 	 lsr r3,r2,r3
 854:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3035              	 .loc 3 854 0
 3036 0016 1846     	 mov r0,r3
 3037 0018 80BD     	 pop {r7,pc}
 3038              	.L209:
 3039 001a 00BF     	 .align 2
 3040              	.L208:
 3041 001c 00460050 	 .word 1342195200
 3042              	 .cfi_endproc
 3043              	.LFE200:
 3045              	 .section .text.XMC_SCU_CLOCK_SetSystemClockSource,"ax",%progbits
 3046              	 .align 2
 3047              	 .global XMC_SCU_CLOCK_SetSystemClockSource
 3048              	 .thumb
 3049              	 .thumb_func
 3051              	XMC_SCU_CLOCK_SetSystemClockSource:
 3052              	.LFB201:
 855:../Libraries/XMCLib/src/xmc4_scu.c **** 
 856:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to select fSYS */
 857:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
 858:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3053              	 .loc 3 858 0
 3054              	 .cfi_startproc
 3055              	 
 3056              	 
 3057              	 
 3058 0000 80B4     	 push {r7}
 3059              	.LCFI274:
 3060              	 .cfi_def_cfa_offset 4
 3061              	 .cfi_offset 7,-4
 3062 0002 83B0     	 sub sp,sp,#12
 3063              	.LCFI275:
 3064              	 .cfi_def_cfa_offset 16
 3065 0004 00AF     	 add r7,sp,#0
 3066              	.LCFI276:
 3067              	 .cfi_def_cfa_register 7
 3068 0006 7860     	 str r0,[r7,#4]
 859:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 3069              	 .loc 3 859 0
 3070 0008 0649     	 ldr r1,.L211
 3071 000a 064B     	 ldr r3,.L211
 3072 000c DB68     	 ldr r3,[r3,#12]
 3073 000e 23F48032 	 bic r2,r3,#65536
 3074 0012 7B68     	 ldr r3,[r7,#4]
 3075 0014 1343     	 orrs r3,r3,r2
 3076 0016 CB60     	 str r3,[r1,#12]
 860:../Libraries/XMCLib/src/xmc4_scu.c ****                       ((uint32_t)source);
 861:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3077              	 .loc 3 861 0
 3078 0018 0C37     	 adds r7,r7,#12
 3079              	.LCFI277:
 3080              	 .cfi_def_cfa_offset 4
 3081 001a BD46     	 mov sp,r7
 3082              	.LCFI278:
 3083              	 .cfi_def_cfa_register 13
 3084              	 
 3085 001c 5DF8047B 	 ldr r7,[sp],#4
 3086              	.LCFI279:
 3087              	 .cfi_restore 7
 3088              	 .cfi_def_cfa_offset 0
 3089 0020 7047     	 bx lr
 3090              	.L212:
 3091 0022 00BF     	 .align 2
 3092              	.L211:
 3093 0024 00460050 	 .word 1342195200
 3094              	 .cfi_endproc
 3095              	.LFE201:
 3097              	 .section .text.XMC_SCU_CLOCK_SetUsbClockSource,"ax",%progbits
 3098              	 .align 2
 3099              	 .global XMC_SCU_CLOCK_SetUsbClockSource
 3100              	 .thumb
 3101              	 .thumb_func
 3103              	XMC_SCU_CLOCK_SetUsbClockSource:
 3104              	.LFB202:
 862:../Libraries/XMCLib/src/xmc4_scu.c **** 
 863:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to select fUSB */
 864:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetUsbClockSource(const XMC_SCU_CLOCK_USBCLKSRC_t source)
 865:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3105              	 .loc 3 865 0
 3106              	 .cfi_startproc
 3107              	 
 3108              	 
 3109              	 
 3110 0000 80B4     	 push {r7}
 3111              	.LCFI280:
 3112              	 .cfi_def_cfa_offset 4
 3113              	 .cfi_offset 7,-4
 3114 0002 83B0     	 sub sp,sp,#12
 3115              	.LCFI281:
 3116              	 .cfi_def_cfa_offset 16
 3117 0004 00AF     	 add r7,sp,#0
 3118              	.LCFI282:
 3119              	 .cfi_def_cfa_register 7
 3120 0006 7860     	 str r0,[r7,#4]
 866:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBSEL_Msk)) |
 3121              	 .loc 3 866 0
 3122 0008 0649     	 ldr r1,.L214
 3123 000a 064B     	 ldr r3,.L214
 3124 000c 9B69     	 ldr r3,[r3,#24]
 3125 000e 23F48032 	 bic r2,r3,#65536
 3126 0012 7B68     	 ldr r3,[r7,#4]
 3127 0014 1343     	 orrs r3,r3,r2
 3128 0016 8B61     	 str r3,[r1,#24]
 867:../Libraries/XMCLib/src/xmc4_scu.c ****                       ((uint32_t)source);
 868:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3129              	 .loc 3 868 0
 3130 0018 0C37     	 adds r7,r7,#12
 3131              	.LCFI283:
 3132              	 .cfi_def_cfa_offset 4
 3133 001a BD46     	 mov sp,r7
 3134              	.LCFI284:
 3135              	 .cfi_def_cfa_register 13
 3136              	 
 3137 001c 5DF8047B 	 ldr r7,[sp],#4
 3138              	.LCFI285:
 3139              	 .cfi_restore 7
 3140              	 .cfi_def_cfa_offset 0
 3141 0020 7047     	 bx lr
 3142              	.L215:
 3143 0022 00BF     	 .align 2
 3144              	.L214:
 3145 0024 00460050 	 .word 1342195200
 3146              	 .cfi_endproc
 3147              	.LFE202:
 3149              	 .section .text.XMC_SCU_CLOCK_SetWdtClockSource,"ax",%progbits
 3150              	 .align 2
 3151              	 .global XMC_SCU_CLOCK_SetWdtClockSource
 3152              	 .thumb
 3153              	 .thumb_func
 3155              	XMC_SCU_CLOCK_SetWdtClockSource:
 3156              	.LFB203:
 869:../Libraries/XMCLib/src/xmc4_scu.c **** 
 870:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to select fWDT */
 871:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetWdtClockSource(const XMC_SCU_CLOCK_WDTCLKSRC_t source)
 872:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3157              	 .loc 3 872 0
 3158              	 .cfi_startproc
 3159              	 
 3160              	 
 3161              	 
 3162 0000 80B4     	 push {r7}
 3163              	.LCFI286:
 3164              	 .cfi_def_cfa_offset 4
 3165              	 .cfi_offset 7,-4
 3166 0002 83B0     	 sub sp,sp,#12
 3167              	.LCFI287:
 3168              	 .cfi_def_cfa_offset 16
 3169 0004 00AF     	 add r7,sp,#0
 3170              	.LCFI288:
 3171              	 .cfi_def_cfa_register 7
 3172 0006 7860     	 str r0,[r7,#4]
 873:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTSEL_Msk)) |
 3173              	 .loc 3 873 0
 3174 0008 0649     	 ldr r1,.L217
 3175 000a 064B     	 ldr r3,.L217
 3176 000c 5B6A     	 ldr r3,[r3,#36]
 3177 000e 23F44032 	 bic r2,r3,#196608
 3178 0012 7B68     	 ldr r3,[r7,#4]
 3179 0014 1343     	 orrs r3,r3,r2
 3180 0016 4B62     	 str r3,[r1,#36]
 874:../Libraries/XMCLib/src/xmc4_scu.c ****                       ((uint32_t)source);
 875:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3181              	 .loc 3 875 0
 3182 0018 0C37     	 adds r7,r7,#12
 3183              	.LCFI289:
 3184              	 .cfi_def_cfa_offset 4
 3185 001a BD46     	 mov sp,r7
 3186              	.LCFI290:
 3187              	 .cfi_def_cfa_register 13
 3188              	 
 3189 001c 5DF8047B 	 ldr r7,[sp],#4
 3190              	.LCFI291:
 3191              	 .cfi_restore 7
 3192              	 .cfi_def_cfa_offset 0
 3193 0020 7047     	 bx lr
 3194              	.L218:
 3195 0022 00BF     	 .align 2
 3196              	.L217:
 3197 0024 00460050 	 .word 1342195200
 3198              	 .cfi_endproc
 3199              	.LFE203:
 3201              	 .section .text.XMC_SCU_CLOCK_SetExternalOutputClockSource,"ax",%progbits
 3202              	 .align 2
 3203              	 .global XMC_SCU_CLOCK_SetExternalOutputClockSource
 3204              	 .thumb
 3205              	 .thumb_func
 3207              	XMC_SCU_CLOCK_SetExternalOutputClockSource:
 3208              	.LFB204:
 876:../Libraries/XMCLib/src/xmc4_scu.c **** 
 877:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to select fEXT */
 878:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetExternalOutputClockSource(const XMC_SCU_CLOCK_EXTOUTCLKSRC_t source)
 879:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3209              	 .loc 3 879 0
 3210              	 .cfi_startproc
 3211              	 
 3212              	 
 3213              	 
 3214 0000 80B4     	 push {r7}
 3215              	.LCFI292:
 3216              	 .cfi_def_cfa_offset 4
 3217              	 .cfi_offset 7,-4
 3218 0002 83B0     	 sub sp,sp,#12
 3219              	.LCFI293:
 3220              	 .cfi_def_cfa_offset 16
 3221 0004 00AF     	 add r7,sp,#0
 3222              	.LCFI294:
 3223              	 .cfi_def_cfa_register 7
 3224 0006 0346     	 mov r3,r0
 3225 0008 FB71     	 strb r3,[r7,#7]
 880:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->EXTCLKCR = (SCU_CLK->EXTCLKCR & ((uint32_t)~SCU_CLK_EXTCLKCR_ECKSEL_Msk)) |
 3226              	 .loc 3 880 0
 3227 000a 0649     	 ldr r1,.L220
 3228 000c 054B     	 ldr r3,.L220
 3229 000e 9B6A     	 ldr r3,[r3,#40]
 3230 0010 23F00302 	 bic r2,r3,#3
 881:../Libraries/XMCLib/src/xmc4_scu.c ****                       ((uint32_t)source);
 3231              	 .loc 3 881 0
 3232 0014 FB79     	 ldrb r3,[r7,#7]
 880:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->EXTCLKCR = (SCU_CLK->EXTCLKCR & ((uint32_t)~SCU_CLK_EXTCLKCR_ECKSEL_Msk)) |
 3233              	 .loc 3 880 0
 3234 0016 1343     	 orrs r3,r3,r2
 3235 0018 8B62     	 str r3,[r1,#40]
 882:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3236              	 .loc 3 882 0
 3237 001a 0C37     	 adds r7,r7,#12
 3238              	.LCFI295:
 3239              	 .cfi_def_cfa_offset 4
 3240 001c BD46     	 mov sp,r7
 3241              	.LCFI296:
 3242              	 .cfi_def_cfa_register 13
 3243              	 
 3244 001e 5DF8047B 	 ldr r7,[sp],#4
 3245              	.LCFI297:
 3246              	 .cfi_restore 7
 3247              	 .cfi_def_cfa_offset 0
 3248 0022 7047     	 bx lr
 3249              	.L221:
 3250              	 .align 2
 3251              	.L220:
 3252 0024 00460050 	 .word 1342195200
 3253              	 .cfi_endproc
 3254              	.LFE204:
 3256              	 .section .text.XMC_SCU_CLOCK_SetSystemPllClockSource,"ax",%progbits
 3257              	 .align 2
 3258              	 .global XMC_SCU_CLOCK_SetSystemPllClockSource
 3259              	 .thumb
 3260              	 .thumb_func
 3262              	XMC_SCU_CLOCK_SetSystemPllClockSource:
 3263              	.LFB205:
 883:../Libraries/XMCLib/src/xmc4_scu.c **** 
 884:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to select fPLL */
 885:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
 886:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3264              	 .loc 3 886 0
 3265              	 .cfi_startproc
 3266              	 
 3267              	 
 3268              	 
 3269 0000 80B4     	 push {r7}
 3270              	.LCFI298:
 3271              	 .cfi_def_cfa_offset 4
 3272              	 .cfi_offset 7,-4
 3273 0002 83B0     	 sub sp,sp,#12
 3274              	.LCFI299:
 3275              	 .cfi_def_cfa_offset 16
 3276 0004 00AF     	 add r7,sp,#0
 3277              	.LCFI300:
 3278              	 .cfi_def_cfa_register 7
 3279 0006 0346     	 mov r3,r0
 3280 0008 FB80     	 strh r3,[r7,#6]
 887:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Check input clock */
 888:../Libraries/XMCLib/src/xmc4_scu.c ****   if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
 3281              	 .loc 3 888 0
 3282 000a FB88     	 ldrh r3,[r7,#6]
 3283 000c 002B     	 cmp r3,#0
 3284 000e 08D1     	 bne .L223
 889:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 890:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 3285              	 .loc 3 890 0
 3286 0010 0A4A     	 ldr r2,.L225
 3287 0012 0A4B     	 ldr r3,.L225
 3288 0014 DB68     	 ldr r3,[r3,#12]
 3289 0016 23F48073 	 bic r3,r3,#256
 3290 001a 23F00103 	 bic r3,r3,#1
 3291 001e D360     	 str r3,[r2,#12]
 3292 0020 07E0     	 b .L222
 3293              	.L223:
 891:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 892:../Libraries/XMCLib/src/xmc4_scu.c ****   else
 893:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 894:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 3294              	 .loc 3 894 0
 3295 0022 064A     	 ldr r2,.L225
 3296 0024 054B     	 ldr r3,.L225
 3297 0026 DB68     	 ldr r3,[r3,#12]
 3298 0028 43F48073 	 orr r3,r3,#256
 3299 002c 43F00103 	 orr r3,r3,#1
 3300 0030 D360     	 str r3,[r2,#12]
 3301              	.L222:
 895:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 896:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3302              	 .loc 3 896 0
 3303 0032 0C37     	 adds r7,r7,#12
 3304              	.LCFI301:
 3305              	 .cfi_def_cfa_offset 4
 3306 0034 BD46     	 mov sp,r7
 3307              	.LCFI302:
 3308              	 .cfi_def_cfa_register 13
 3309              	 
 3310 0036 5DF8047B 	 ldr r7,[sp],#4
 3311              	.LCFI303:
 3312              	 .cfi_restore 7
 3313              	 .cfi_def_cfa_offset 0
 3314 003a 7047     	 bx lr
 3315              	.L226:
 3316              	 .align 2
 3317              	.L225:
 3318 003c 10470050 	 .word 1342195472
 3319              	 .cfi_endproc
 3320              	.LFE205:
 3322              	 .section .text.XMC_SCU_HIB_SetRtcClockSource,"ax",%progbits
 3323              	 .align 2
 3324              	 .global XMC_SCU_HIB_SetRtcClockSource
 3325              	 .thumb
 3326              	 .thumb_func
 3328              	XMC_SCU_HIB_SetRtcClockSource:
 3329              	.LFB206:
 897:../Libraries/XMCLib/src/xmc4_scu.c **** 
 898:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to select fRTC */
 899:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_HIB_SetRtcClockSource(const XMC_SCU_HIB_RTCCLKSRC_t source)
 900:../Libraries/XMCLib/src/xmc4_scu.c **** { 
 3330              	 .loc 3 900 0
 3331              	 .cfi_startproc
 3332              	 
 3333              	 
 3334              	 
 3335 0000 80B4     	 push {r7}
 3336              	.LCFI304:
 3337              	 .cfi_def_cfa_offset 4
 3338              	 .cfi_offset 7,-4
 3339 0002 83B0     	 sub sp,sp,#12
 3340              	.LCFI305:
 3341              	 .cfi_def_cfa_offset 16
 3342 0004 00AF     	 add r7,sp,#0
 3343              	.LCFI306:
 3344              	 .cfi_def_cfa_register 7
 3345 0006 0346     	 mov r3,r0
 3346 0008 FB71     	 strb r3,[r7,#7]
 901:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Wait until the update of HDCR register in hibernate domain is completed */
 902:../Libraries/XMCLib/src/xmc4_scu.c ****   while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 3347              	 .loc 3 902 0
 3348 000a 00BF     	 nop
 3349              	.L228:
 3350              	 .loc 3 902 0 is_stmt 0 discriminator 1
 3351 000c 094B     	 ldr r3,.L229
 3352 000e D3F8C430 	 ldr r3,[r3,#196]
 3353 0012 03F00803 	 and r3,r3,#8
 3354 0016 002B     	 cmp r3,#0
 3355 0018 F8D1     	 bne .L228
 903:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 904:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 905:../Libraries/XMCLib/src/xmc4_scu.c **** 
 906:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_RCS_Msk)) |
 3356              	 .loc 3 906 0 is_stmt 1
 3357 001a 0749     	 ldr r1,.L229+4
 3358 001c 064B     	 ldr r3,.L229+4
 3359 001e DB68     	 ldr r3,[r3,#12]
 3360 0020 23F04002 	 bic r2,r3,#64
 907:../Libraries/XMCLib/src/xmc4_scu.c ****                         ((uint32_t)source);
 3361              	 .loc 3 907 0
 3362 0024 FB79     	 ldrb r3,[r7,#7]
 906:../Libraries/XMCLib/src/xmc4_scu.c ****                         ((uint32_t)source);
 3363              	 .loc 3 906 0
 3364 0026 1343     	 orrs r3,r3,r2
 3365 0028 CB60     	 str r3,[r1,#12]
 908:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3366              	 .loc 3 908 0
 3367 002a 0C37     	 adds r7,r7,#12
 3368              	.LCFI307:
 3369              	 .cfi_def_cfa_offset 4
 3370 002c BD46     	 mov sp,r7
 3371              	.LCFI308:
 3372              	 .cfi_def_cfa_register 13
 3373              	 
 3374 002e 5DF8047B 	 ldr r7,[sp],#4
 3375              	.LCFI309:
 3376              	 .cfi_restore 7
 3377              	 .cfi_def_cfa_offset 0
 3378 0032 7047     	 bx lr
 3379              	.L230:
 3380              	 .align 2
 3381              	.L229:
 3382 0034 00400050 	 .word 1342193664
 3383 0038 00430050 	 .word 1342194432
 3384              	 .cfi_endproc
 3385              	.LFE206:
 3387              	 .section .text.XMC_SCU_HIB_SetStandbyClockSource,"ax",%progbits
 3388              	 .align 2
 3389              	 .global XMC_SCU_HIB_SetStandbyClockSource
 3390              	 .thumb
 3391              	 .thumb_func
 3393              	XMC_SCU_HIB_SetStandbyClockSource:
 3394              	.LFB207:
 909:../Libraries/XMCLib/src/xmc4_scu.c **** 
 910:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to select fSTDBY */
 911:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_HIB_SetStandbyClockSource(const XMC_SCU_HIB_STDBYCLKSRC_t source)
 912:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3395              	 .loc 3 912 0
 3396              	 .cfi_startproc
 3397              	 
 3398              	 
 3399              	 
 3400 0000 80B4     	 push {r7}
 3401              	.LCFI310:
 3402              	 .cfi_def_cfa_offset 4
 3403              	 .cfi_offset 7,-4
 3404 0002 83B0     	 sub sp,sp,#12
 3405              	.LCFI311:
 3406              	 .cfi_def_cfa_offset 16
 3407 0004 00AF     	 add r7,sp,#0
 3408              	.LCFI312:
 3409              	 .cfi_def_cfa_register 7
 3410 0006 0346     	 mov r3,r0
 3411 0008 FB71     	 strb r3,[r7,#7]
 913:../Libraries/XMCLib/src/xmc4_scu.c ****   while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 3412              	 .loc 3 913 0
 3413 000a 00BF     	 nop
 3414              	.L232:
 3415              	 .loc 3 913 0 is_stmt 0 discriminator 1
 3416 000c 094B     	 ldr r3,.L233
 3417 000e D3F8C430 	 ldr r3,[r3,#196]
 3418 0012 03F00803 	 and r3,r3,#8
 3419 0016 002B     	 cmp r3,#0
 3420 0018 F8D1     	 bne .L232
 914:../Libraries/XMCLib/src/xmc4_scu.c ****   {
 915:../Libraries/XMCLib/src/xmc4_scu.c ****     /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
 916:../Libraries/XMCLib/src/xmc4_scu.c ****   }
 917:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_STDBYSEL_Msk)) |
 3421              	 .loc 3 917 0 is_stmt 1
 3422 001a 0749     	 ldr r1,.L233+4
 3423 001c 064B     	 ldr r3,.L233+4
 3424 001e DB68     	 ldr r3,[r3,#12]
 3425 0020 23F08002 	 bic r2,r3,#128
 918:../Libraries/XMCLib/src/xmc4_scu.c ****                         ((uint32_t)source);
 3426              	 .loc 3 918 0
 3427 0024 FB79     	 ldrb r3,[r7,#7]
 917:../Libraries/XMCLib/src/xmc4_scu.c ****                         ((uint32_t)source);
 3428              	 .loc 3 917 0
 3429 0026 1343     	 orrs r3,r3,r2
 3430 0028 CB60     	 str r3,[r1,#12]
 919:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3431              	 .loc 3 919 0
 3432 002a 0C37     	 adds r7,r7,#12
 3433              	.LCFI313:
 3434              	 .cfi_def_cfa_offset 4
 3435 002c BD46     	 mov sp,r7
 3436              	.LCFI314:
 3437              	 .cfi_def_cfa_register 13
 3438              	 
 3439 002e 5DF8047B 	 ldr r7,[sp],#4
 3440              	.LCFI315:
 3441              	 .cfi_restore 7
 3442              	 .cfi_def_cfa_offset 0
 3443 0032 7047     	 bx lr
 3444              	.L234:
 3445              	 .align 2
 3446              	.L233:
 3447 0034 00400050 	 .word 1342193664
 3448 0038 00430050 	 .word 1342194432
 3449              	 .cfi_endproc
 3450              	.LFE207:
 3452              	 .section .text.XMC_SCU_CLOCK_SetSystemClockDivider,"ax",%progbits
 3453              	 .align 2
 3454              	 .global XMC_SCU_CLOCK_SetSystemClockDivider
 3455              	 .thumb
 3456              	 .thumb_func
 3458              	XMC_SCU_CLOCK_SetSystemClockDivider:
 3459              	.LFB208:
 920:../Libraries/XMCLib/src/xmc4_scu.c **** 
 921:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to program the divider placed between fsys and its parent */
 922:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
 923:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3460              	 .loc 3 923 0
 3461              	 .cfi_startproc
 3462              	 
 3463              	 
 3464              	 
 3465 0000 80B4     	 push {r7}
 3466              	.LCFI316:
 3467              	 .cfi_def_cfa_offset 4
 3468              	 .cfi_offset 7,-4
 3469 0002 83B0     	 sub sp,sp,#12
 3470              	.LCFI317:
 3471              	 .cfi_def_cfa_offset 16
 3472 0004 00AF     	 add r7,sp,#0
 3473              	.LCFI318:
 3474              	 .cfi_def_cfa_register 7
 3475 0006 7860     	 str r0,[r7,#4]
 924:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
 925:../Libraries/XMCLib/src/xmc4_scu.c ****               (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );
 926:../Libraries/XMCLib/src/xmc4_scu.c **** 
 927:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 3476              	 .loc 3 927 0
 3477 0008 0649     	 ldr r1,.L236
 3478 000a 064B     	 ldr r3,.L236
 3479 000c DB68     	 ldr r3,[r3,#12]
 3480 000e 23F0FF02 	 bic r2,r3,#255
 928:../Libraries/XMCLib/src/xmc4_scu.c ****                       ((uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_SYSCLKCR_SYSDIV_Pos));
 3481              	 .loc 3 928 0
 3482 0012 7B68     	 ldr r3,[r7,#4]
 3483 0014 013B     	 subs r3,r3,#1
 927:../Libraries/XMCLib/src/xmc4_scu.c ****                       ((uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_SYSCLKCR_SYSDIV_Pos));
 3484              	 .loc 3 927 0
 3485 0016 1343     	 orrs r3,r3,r2
 3486 0018 CB60     	 str r3,[r1,#12]
 929:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3487              	 .loc 3 929 0
 3488 001a 0C37     	 adds r7,r7,#12
 3489              	.LCFI319:
 3490              	 .cfi_def_cfa_offset 4
 3491 001c BD46     	 mov sp,r7
 3492              	.LCFI320:
 3493              	 .cfi_def_cfa_register 13
 3494              	 
 3495 001e 5DF8047B 	 ldr r7,[sp],#4
 3496              	.LCFI321:
 3497              	 .cfi_restore 7
 3498              	 .cfi_def_cfa_offset 0
 3499 0022 7047     	 bx lr
 3500              	.L237:
 3501              	 .align 2
 3502              	.L236:
 3503 0024 00460050 	 .word 1342195200
 3504              	 .cfi_endproc
 3505              	.LFE208:
 3507              	 .section .text.XMC_SCU_CLOCK_SetCcuClockDivider,"ax",%progbits
 3508              	 .align 2
 3509              	 .global XMC_SCU_CLOCK_SetCcuClockDivider
 3510              	 .thumb
 3511              	 .thumb_func
 3513              	XMC_SCU_CLOCK_SetCcuClockDivider:
 3514              	.LFB209:
 930:../Libraries/XMCLib/src/xmc4_scu.c **** 
 931:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to program the divider placed between fccu and its parent */
 932:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
 933:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3515              	 .loc 3 933 0
 3516              	 .cfi_startproc
 3517              	 
 3518              	 
 3519              	 
 3520 0000 80B4     	 push {r7}
 3521              	.LCFI322:
 3522              	 .cfi_def_cfa_offset 4
 3523              	 .cfi_offset 7,-4
 3524 0002 83B0     	 sub sp,sp,#12
 3525              	.LCFI323:
 3526              	 .cfi_def_cfa_offset 16
 3527 0004 00AF     	 add r7,sp,#0
 3528              	.LCFI324:
 3529              	 .cfi_def_cfa_register 7
 3530 0006 7860     	 str r0,[r7,#4]
 934:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );
 935:../Libraries/XMCLib/src/xmc4_scu.c **** 
 936:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 3531              	 .loc 3 936 0
 3532 0008 0649     	 ldr r1,.L239
 3533 000a 064B     	 ldr r3,.L239
 3534 000c 1B6A     	 ldr r3,[r3,#32]
 3535 000e 23F00102 	 bic r2,r3,#1
 937:../Libraries/XMCLib/src/xmc4_scu.c ****                       (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CCUCLKCR_CCUDIV_Pos);
 3536              	 .loc 3 937 0
 3537 0012 7B68     	 ldr r3,[r7,#4]
 3538 0014 013B     	 subs r3,r3,#1
 936:../Libraries/XMCLib/src/xmc4_scu.c ****                       (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CCUCLKCR_CCUDIV_Pos);
 3539              	 .loc 3 936 0
 3540 0016 1343     	 orrs r3,r3,r2
 3541 0018 0B62     	 str r3,[r1,#32]
 938:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3542              	 .loc 3 938 0
 3543 001a 0C37     	 adds r7,r7,#12
 3544              	.LCFI325:
 3545              	 .cfi_def_cfa_offset 4
 3546 001c BD46     	 mov sp,r7
 3547              	.LCFI326:
 3548              	 .cfi_def_cfa_register 13
 3549              	 
 3550 001e 5DF8047B 	 ldr r7,[sp],#4
 3551              	.LCFI327:
 3552              	 .cfi_restore 7
 3553              	 .cfi_def_cfa_offset 0
 3554 0022 7047     	 bx lr
 3555              	.L240:
 3556              	 .align 2
 3557              	.L239:
 3558 0024 00460050 	 .word 1342195200
 3559              	 .cfi_endproc
 3560              	.LFE209:
 3562              	 .section .text.XMC_SCU_CLOCK_SetCpuClockDivider,"ax",%progbits
 3563              	 .align 2
 3564              	 .global XMC_SCU_CLOCK_SetCpuClockDivider
 3565              	 .thumb
 3566              	 .thumb_func
 3568              	XMC_SCU_CLOCK_SetCpuClockDivider:
 3569              	.LFB210:
 939:../Libraries/XMCLib/src/xmc4_scu.c **** 
 940:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to program the divider placed between fcpu and its parent */
 941:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
 942:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3570              	 .loc 3 942 0
 3571              	 .cfi_startproc
 3572              	 
 3573              	 
 3574              	 
 3575 0000 80B4     	 push {r7}
 3576              	.LCFI328:
 3577              	 .cfi_def_cfa_offset 4
 3578              	 .cfi_offset 7,-4
 3579 0002 83B0     	 sub sp,sp,#12
 3580              	.LCFI329:
 3581              	 .cfi_def_cfa_offset 16
 3582 0004 00AF     	 add r7,sp,#0
 3583              	.LCFI330:
 3584              	 .cfi_def_cfa_register 7
 3585 0006 7860     	 str r0,[r7,#4]
 943:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );
 944:../Libraries/XMCLib/src/xmc4_scu.c **** 
 945:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 3586              	 .loc 3 945 0
 3587 0008 0649     	 ldr r1,.L242
 3588 000a 064B     	 ldr r3,.L242
 3589 000c 1B69     	 ldr r3,[r3,#16]
 3590 000e 23F00102 	 bic r2,r3,#1
 946:../Libraries/XMCLib/src/xmc4_scu.c ****                       (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CPUCLKCR_CPUDIV_Pos);
 3591              	 .loc 3 946 0
 3592 0012 7B68     	 ldr r3,[r7,#4]
 3593 0014 013B     	 subs r3,r3,#1
 945:../Libraries/XMCLib/src/xmc4_scu.c ****                       (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CPUCLKCR_CPUDIV_Pos);
 3594              	 .loc 3 945 0
 3595 0016 1343     	 orrs r3,r3,r2
 3596 0018 0B61     	 str r3,[r1,#16]
 947:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3597              	 .loc 3 947 0
 3598 001a 0C37     	 adds r7,r7,#12
 3599              	.LCFI331:
 3600              	 .cfi_def_cfa_offset 4
 3601 001c BD46     	 mov sp,r7
 3602              	.LCFI332:
 3603              	 .cfi_def_cfa_register 13
 3604              	 
 3605 001e 5DF8047B 	 ldr r7,[sp],#4
 3606              	.LCFI333:
 3607              	 .cfi_restore 7
 3608              	 .cfi_def_cfa_offset 0
 3609 0022 7047     	 bx lr
 3610              	.L243:
 3611              	 .align 2
 3612              	.L242:
 3613 0024 00460050 	 .word 1342195200
 3614              	 .cfi_endproc
 3615              	.LFE210:
 3617              	 .section .text.XMC_SCU_CLOCK_SetPeripheralClockDivider,"ax",%progbits
 3618              	 .align 2
 3619              	 .global XMC_SCU_CLOCK_SetPeripheralClockDivider
 3620              	 .thumb
 3621              	 .thumb_func
 3623              	XMC_SCU_CLOCK_SetPeripheralClockDivider:
 3624              	.LFB211:
 948:../Libraries/XMCLib/src/xmc4_scu.c **** 
 949:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to program the divider placed between fperiph and its parent */
 950:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
 951:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3625              	 .loc 3 951 0
 3626              	 .cfi_startproc
 3627              	 
 3628              	 
 3629              	 
 3630 0000 80B4     	 push {r7}
 3631              	.LCFI334:
 3632              	 .cfi_def_cfa_offset 4
 3633              	 .cfi_offset 7,-4
 3634 0002 83B0     	 sub sp,sp,#12
 3635              	.LCFI335:
 3636              	 .cfi_def_cfa_offset 16
 3637 0004 00AF     	 add r7,sp,#0
 3638              	.LCFI336:
 3639              	 .cfi_def_cfa_register 7
 3640 0006 7860     	 str r0,[r7,#4]
 952:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) 
 953:../Libraries/XMCLib/src/xmc4_scu.c **** 
 954:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 3641              	 .loc 3 954 0
 3642 0008 0649     	 ldr r1,.L245
 3643 000a 064B     	 ldr r3,.L245
 3644 000c 5B69     	 ldr r3,[r3,#20]
 3645 000e 23F00102 	 bic r2,r3,#1
 955:../Libraries/XMCLib/src/xmc4_scu.c ****                      ((uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_PBCLKCR_PBDIV_Pos));
 3646              	 .loc 3 955 0
 3647 0012 7B68     	 ldr r3,[r7,#4]
 3648 0014 013B     	 subs r3,r3,#1
 954:../Libraries/XMCLib/src/xmc4_scu.c ****                      ((uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_PBCLKCR_PBDIV_Pos));
 3649              	 .loc 3 954 0
 3650 0016 1343     	 orrs r3,r3,r2
 3651 0018 4B61     	 str r3,[r1,#20]
 956:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3652              	 .loc 3 956 0
 3653 001a 0C37     	 adds r7,r7,#12
 3654              	.LCFI337:
 3655              	 .cfi_def_cfa_offset 4
 3656 001c BD46     	 mov sp,r7
 3657              	.LCFI338:
 3658              	 .cfi_def_cfa_register 13
 3659              	 
 3660 001e 5DF8047B 	 ldr r7,[sp],#4
 3661              	.LCFI339:
 3662              	 .cfi_restore 7
 3663              	 .cfi_def_cfa_offset 0
 3664 0022 7047     	 bx lr
 3665              	.L246:
 3666              	 .align 2
 3667              	.L245:
 3668 0024 00460050 	 .word 1342195200
 3669              	 .cfi_endproc
 3670              	.LFE211:
 3672              	 .section .text.XMC_SCU_CLOCK_SetUsbClockDivider,"ax",%progbits
 3673              	 .align 2
 3674              	 .global XMC_SCU_CLOCK_SetUsbClockDivider
 3675              	 .thumb
 3676              	 .thumb_func
 3678              	XMC_SCU_CLOCK_SetUsbClockDivider:
 3679              	.LFB212:
 957:../Libraries/XMCLib/src/xmc4_scu.c **** 
 958:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to program the divider placed between fsdmmc and its parent */
 959:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t divider)
 960:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3680              	 .loc 3 960 0
 3681              	 .cfi_startproc
 3682              	 
 3683              	 
 3684              	 
 3685 0000 80B4     	 push {r7}
 3686              	.LCFI340:
 3687              	 .cfi_def_cfa_offset 4
 3688              	 .cfi_offset 7,-4
 3689 0002 83B0     	 sub sp,sp,#12
 3690              	.LCFI341:
 3691              	 .cfi_def_cfa_offset 16
 3692 0004 00AF     	 add r7,sp,#0
 3693              	.LCFI342:
 3694              	 .cfi_def_cfa_register 7
 3695 0006 7860     	 str r0,[r7,#4]
 961:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("XMC_SCU_CLOCK_SetSdmmcClockDivider:Wrong clock divider value",
 962:../Libraries/XMCLib/src/xmc4_scu.c ****               (divider <= (SCU_CLK_USBCLKCR_USBDIV_Msk + 1UL)) );
 963:../Libraries/XMCLib/src/xmc4_scu.c **** 
 964:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 3696              	 .loc 3 964 0
 3697 0008 0649     	 ldr r1,.L248
 3698 000a 064B     	 ldr r3,.L248
 3699 000c 9B69     	 ldr r3,[r3,#24]
 3700 000e 23F00702 	 bic r2,r3,#7
 965:../Libraries/XMCLib/src/xmc4_scu.c ****                       (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_USBCLKCR_USBDIV_Pos); 
 3701              	 .loc 3 965 0
 3702 0012 7B68     	 ldr r3,[r7,#4]
 3703 0014 013B     	 subs r3,r3,#1
 964:../Libraries/XMCLib/src/xmc4_scu.c ****                       (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_USBCLKCR_USBDIV_Pos); 
 3704              	 .loc 3 964 0
 3705 0016 1343     	 orrs r3,r3,r2
 3706 0018 8B61     	 str r3,[r1,#24]
 966:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3707              	 .loc 3 966 0
 3708 001a 0C37     	 adds r7,r7,#12
 3709              	.LCFI343:
 3710              	 .cfi_def_cfa_offset 4
 3711 001c BD46     	 mov sp,r7
 3712              	.LCFI344:
 3713              	 .cfi_def_cfa_register 13
 3714              	 
 3715 001e 5DF8047B 	 ldr r7,[sp],#4
 3716              	.LCFI345:
 3717              	 .cfi_restore 7
 3718              	 .cfi_def_cfa_offset 0
 3719 0022 7047     	 bx lr
 3720              	.L249:
 3721              	 .align 2
 3722              	.L248:
 3723 0024 00460050 	 .word 1342195200
 3724              	 .cfi_endproc
 3725              	.LFE212:
 3727              	 .section .text.XMC_SCU_CLOCK_SetEbuClockDivider,"ax",%progbits
 3728              	 .align 2
 3729              	 .global XMC_SCU_CLOCK_SetEbuClockDivider
 3730              	 .thumb
 3731              	 .thumb_func
 3733              	XMC_SCU_CLOCK_SetEbuClockDivider:
 3734              	.LFB213:
 967:../Libraries/XMCLib/src/xmc4_scu.c **** 
 968:../Libraries/XMCLib/src/xmc4_scu.c **** #if defined(EBU)
 969:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to program the divider placed between febu and its parent */
 970:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetEbuClockDivider(const uint32_t divider)
 971:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3735              	 .loc 3 971 0
 3736              	 .cfi_startproc
 3737              	 
 3738              	 
 3739              	 
 3740 0000 80B4     	 push {r7}
 3741              	.LCFI346:
 3742              	 .cfi_def_cfa_offset 4
 3743              	 .cfi_offset 7,-4
 3744 0002 83B0     	 sub sp,sp,#12
 3745              	.LCFI347:
 3746              	 .cfi_def_cfa_offset 16
 3747 0004 00AF     	 add r7,sp,#0
 3748              	.LCFI348:
 3749              	 .cfi_def_cfa_register 7
 3750 0006 7860     	 str r0,[r7,#4]
 972:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("XMC_SCU_CLOCK_SetEbuClockDivider:Wrong clock divider value",
 973:../Libraries/XMCLib/src/xmc4_scu.c ****               (divider <= (SCU_CLK_EBUCLKCR_EBUDIV_Msk + 1UL) ) );
 974:../Libraries/XMCLib/src/xmc4_scu.c **** 
 975:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 3751              	 .loc 3 975 0
 3752 0008 0649     	 ldr r1,.L251
 3753 000a 064B     	 ldr r3,.L251
 3754 000c DB69     	 ldr r3,[r3,#28]
 3755 000e 23F03F02 	 bic r2,r3,#63
 976:../Libraries/XMCLib/src/xmc4_scu.c ****                       (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_EBUCLKCR_EBUDIV_Pos);
 3756              	 .loc 3 976 0
 3757 0012 7B68     	 ldr r3,[r7,#4]
 3758 0014 013B     	 subs r3,r3,#1
 975:../Libraries/XMCLib/src/xmc4_scu.c ****                       (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_EBUCLKCR_EBUDIV_Pos);
 3759              	 .loc 3 975 0
 3760 0016 1343     	 orrs r3,r3,r2
 3761 0018 CB61     	 str r3,[r1,#28]
 977:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3762              	 .loc 3 977 0
 3763 001a 0C37     	 adds r7,r7,#12
 3764              	.LCFI349:
 3765              	 .cfi_def_cfa_offset 4
 3766 001c BD46     	 mov sp,r7
 3767              	.LCFI350:
 3768              	 .cfi_def_cfa_register 13
 3769              	 
 3770 001e 5DF8047B 	 ldr r7,[sp],#4
 3771              	.LCFI351:
 3772              	 .cfi_restore 7
 3773              	 .cfi_def_cfa_offset 0
 3774 0022 7047     	 bx lr
 3775              	.L252:
 3776              	 .align 2
 3777              	.L251:
 3778 0024 00460050 	 .word 1342195200
 3779              	 .cfi_endproc
 3780              	.LFE213:
 3782              	 .section .text.XMC_SCU_CLOCK_SetWdtClockDivider,"ax",%progbits
 3783              	 .align 2
 3784              	 .global XMC_SCU_CLOCK_SetWdtClockDivider
 3785              	 .thumb
 3786              	 .thumb_func
 3788              	XMC_SCU_CLOCK_SetWdtClockDivider:
 3789              	.LFB214:
 978:../Libraries/XMCLib/src/xmc4_scu.c **** #endif
 979:../Libraries/XMCLib/src/xmc4_scu.c **** 
 980:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to program the divider placed between fwdt and its parent */
 981:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
 982:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3790              	 .loc 3 982 0
 3791              	 .cfi_startproc
 3792              	 
 3793              	 
 3794              	 
 3795 0000 80B4     	 push {r7}
 3796              	.LCFI352:
 3797              	 .cfi_def_cfa_offset 4
 3798              	 .cfi_offset 7,-4
 3799 0002 83B0     	 sub sp,sp,#12
 3800              	.LCFI353:
 3801              	 .cfi_def_cfa_offset 16
 3802 0004 00AF     	 add r7,sp,#0
 3803              	.LCFI354:
 3804              	 .cfi_def_cfa_register 7
 3805 0006 7860     	 str r0,[r7,#4]
 983:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
 984:../Libraries/XMCLib/src/xmc4_scu.c ****               (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );
 985:../Libraries/XMCLib/src/xmc4_scu.c **** 
 986:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 3806              	 .loc 3 986 0
 3807 0008 0649     	 ldr r1,.L254
 3808 000a 064B     	 ldr r3,.L254
 3809 000c 5B6A     	 ldr r3,[r3,#36]
 3810 000e 23F0FF02 	 bic r2,r3,#255
 987:../Libraries/XMCLib/src/xmc4_scu.c ****                       (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_WDTCLKCR_WDTDIV_Pos);
 3811              	 .loc 3 987 0
 3812 0012 7B68     	 ldr r3,[r7,#4]
 3813 0014 013B     	 subs r3,r3,#1
 986:../Libraries/XMCLib/src/xmc4_scu.c ****                       (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_WDTCLKCR_WDTDIV_Pos);
 3814              	 .loc 3 986 0
 3815 0016 1343     	 orrs r3,r3,r2
 3816 0018 4B62     	 str r3,[r1,#36]
 988:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3817              	 .loc 3 988 0
 3818 001a 0C37     	 adds r7,r7,#12
 3819              	.LCFI355:
 3820              	 .cfi_def_cfa_offset 4
 3821 001c BD46     	 mov sp,r7
 3822              	.LCFI356:
 3823              	 .cfi_def_cfa_register 13
 3824              	 
 3825 001e 5DF8047B 	 ldr r7,[sp],#4
 3826              	.LCFI357:
 3827              	 .cfi_restore 7
 3828              	 .cfi_def_cfa_offset 0
 3829 0022 7047     	 bx lr
 3830              	.L255:
 3831              	 .align 2
 3832              	.L254:
 3833 0024 00460050 	 .word 1342195200
 3834              	 .cfi_endproc
 3835              	.LFE214:
 3837              	 .section .text.XMC_SCU_CLOCK_SetExternalOutputClockDivider,"ax",%progbits
 3838              	 .align 2
 3839              	 .global XMC_SCU_CLOCK_SetExternalOutputClockDivider
 3840              	 .thumb
 3841              	 .thumb_func
 3843              	XMC_SCU_CLOCK_SetExternalOutputClockDivider:
 3844              	.LFB215:
 989:../Libraries/XMCLib/src/xmc4_scu.c **** 
 990:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to program the divider placed between fext and its parent */
 991:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetExternalOutputClockDivider(const uint32_t divider)
 992:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3845              	 .loc 3 992 0
 3846              	 .cfi_startproc
 3847              	 
 3848              	 
 3849              	 
 3850 0000 80B4     	 push {r7}
 3851              	.LCFI358:
 3852              	 .cfi_def_cfa_offset 4
 3853              	 .cfi_offset 7,-4
 3854 0002 83B0     	 sub sp,sp,#12
 3855              	.LCFI359:
 3856              	 .cfi_def_cfa_offset 16
 3857 0004 00AF     	 add r7,sp,#0
 3858              	.LCFI360:
 3859              	 .cfi_def_cfa_register 7
 3860 0006 7860     	 str r0,[r7,#4]
 993:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_ASSERT("XMC_SCU_CLOCK_SetExternalOutputClockDivider:Wrong clock divider value",
 994:../Libraries/XMCLib/src/xmc4_scu.c ****               (divider <= (SCU_CLK_EXTCLKCR_ECKDIV_Msk + 1UL) ) );
 995:../Libraries/XMCLib/src/xmc4_scu.c **** 
 996:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->EXTCLKCR = (SCU_CLK->EXTCLKCR & ((uint32_t)~SCU_CLK_EXTCLKCR_ECKDIV_Msk)) |
 3861              	 .loc 3 996 0
 3862 0008 0849     	 ldr r1,.L257
 3863 000a 084B     	 ldr r3,.L257
 3864 000c 9B6A     	 ldr r3,[r3,#40]
 3865 000e 23F0FF73 	 bic r3,r3,#33423360
 3866 0012 23F48033 	 bic r3,r3,#65536
 997:../Libraries/XMCLib/src/xmc4_scu.c ****                       (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_EXTCLKCR_ECKDIV_Pos);
 3867              	 .loc 3 997 0
 3868 0016 7A68     	 ldr r2,[r7,#4]
 3869 0018 013A     	 subs r2,r2,#1
 3870 001a 1204     	 lsls r2,r2,#16
 996:../Libraries/XMCLib/src/xmc4_scu.c ****                       (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_EXTCLKCR_ECKDIV_Pos);
 3871              	 .loc 3 996 0
 3872 001c 1343     	 orrs r3,r3,r2
 3873 001e 8B62     	 str r3,[r1,#40]
 998:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3874              	 .loc 3 998 0
 3875 0020 0C37     	 adds r7,r7,#12
 3876              	.LCFI361:
 3877              	 .cfi_def_cfa_offset 4
 3878 0022 BD46     	 mov sp,r7
 3879              	.LCFI362:
 3880              	 .cfi_def_cfa_register 13
 3881              	 
 3882 0024 5DF8047B 	 ldr r7,[sp],#4
 3883              	.LCFI363:
 3884              	 .cfi_restore 7
 3885              	 .cfi_def_cfa_offset 0
 3886 0028 7047     	 bx lr
 3887              	.L258:
 3888 002a 00BF     	 .align 2
 3889              	.L257:
 3890 002c 00460050 	 .word 1342195200
 3891              	 .cfi_endproc
 3892              	.LFE215:
 3894              	 .section .text.XMC_SCU_CLOCK_EnableClock,"ax",%progbits
 3895              	 .align 2
 3896              	 .global XMC_SCU_CLOCK_EnableClock
 3897              	 .thumb
 3898              	 .thumb_func
 3900              	XMC_SCU_CLOCK_EnableClock:
 3901              	.LFB216:
 999:../Libraries/XMCLib/src/xmc4_scu.c **** 
1000:../Libraries/XMCLib/src/xmc4_scu.c **** #if defined(ECAT0)
1001:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to configure the ECAT clock by setting the clock divider for the ECAT clock source */
1002:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetECATClockDivider(const uint32_t divider)
1003:../Libraries/XMCLib/src/xmc4_scu.c **** {
1004:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->ECATCLKCR = (SCU_CLK->ECATCLKCR & ~SCU_CLK_ECATCLKCR_ECADIV_Msk) |
1005:../Libraries/XMCLib/src/xmc4_scu.c ****                        (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_ECATCLKCR_ECADIV_Pos);
1006:../Libraries/XMCLib/src/xmc4_scu.c **** }
1007:../Libraries/XMCLib/src/xmc4_scu.c **** #endif
1008:../Libraries/XMCLib/src/xmc4_scu.c **** 
1009:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to enable a given module clock */
1010:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_EnableClock(const XMC_SCU_CLOCK_t clock)
1011:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3902              	 .loc 3 1011 0
 3903              	 .cfi_startproc
 3904              	 
 3905              	 
 3906              	 
 3907 0000 80B4     	 push {r7}
 3908              	.LCFI364:
 3909              	 .cfi_def_cfa_offset 4
 3910              	 .cfi_offset 7,-4
 3911 0002 83B0     	 sub sp,sp,#12
 3912              	.LCFI365:
 3913              	 .cfi_def_cfa_offset 16
 3914 0004 00AF     	 add r7,sp,#0
 3915              	.LCFI366:
 3916              	 .cfi_def_cfa_register 7
 3917 0006 0346     	 mov r3,r0
 3918 0008 FB71     	 strb r3,[r7,#7]
1012:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->CLKSET = ((uint32_t)clock);
 3919              	 .loc 3 1012 0
 3920 000a 044A     	 ldr r2,.L260
 3921 000c FB79     	 ldrb r3,[r7,#7]
 3922 000e 5360     	 str r3,[r2,#4]
1013:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3923              	 .loc 3 1013 0
 3924 0010 0C37     	 adds r7,r7,#12
 3925              	.LCFI367:
 3926              	 .cfi_def_cfa_offset 4
 3927 0012 BD46     	 mov sp,r7
 3928              	.LCFI368:
 3929              	 .cfi_def_cfa_register 13
 3930              	 
 3931 0014 5DF8047B 	 ldr r7,[sp],#4
 3932              	.LCFI369:
 3933              	 .cfi_restore 7
 3934              	 .cfi_def_cfa_offset 0
 3935 0018 7047     	 bx lr
 3936              	.L261:
 3937 001a 00BF     	 .align 2
 3938              	.L260:
 3939 001c 00460050 	 .word 1342195200
 3940              	 .cfi_endproc
 3941              	.LFE216:
 3943              	 .section .text.XMC_SCU_CLOCK_DisableClock,"ax",%progbits
 3944              	 .align 2
 3945              	 .global XMC_SCU_CLOCK_DisableClock
 3946              	 .thumb
 3947              	 .thumb_func
 3949              	XMC_SCU_CLOCK_DisableClock:
 3950              	.LFB217:
1014:../Libraries/XMCLib/src/xmc4_scu.c **** 
1015:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to disable a given module clock */
1016:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_DisableClock(const XMC_SCU_CLOCK_t clock)
1017:../Libraries/XMCLib/src/xmc4_scu.c **** {
 3951              	 .loc 3 1017 0
 3952              	 .cfi_startproc
 3953              	 
 3954              	 
 3955              	 
 3956 0000 80B4     	 push {r7}
 3957              	.LCFI370:
 3958              	 .cfi_def_cfa_offset 4
 3959              	 .cfi_offset 7,-4
 3960 0002 83B0     	 sub sp,sp,#12
 3961              	.LCFI371:
 3962              	 .cfi_def_cfa_offset 16
 3963 0004 00AF     	 add r7,sp,#0
 3964              	.LCFI372:
 3965              	 .cfi_def_cfa_register 7
 3966 0006 0346     	 mov r3,r0
 3967 0008 FB71     	 strb r3,[r7,#7]
1018:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_CLK->CLKCLR = ((uint32_t)clock);
 3968              	 .loc 3 1018 0
 3969 000a 044A     	 ldr r2,.L263
 3970 000c FB79     	 ldrb r3,[r7,#7]
 3971 000e 9360     	 str r3,[r2,#8]
1019:../Libraries/XMCLib/src/xmc4_scu.c **** }
 3972              	 .loc 3 1019 0
 3973 0010 0C37     	 adds r7,r7,#12
 3974              	.LCFI373:
 3975              	 .cfi_def_cfa_offset 4
 3976 0012 BD46     	 mov sp,r7
 3977              	.LCFI374:
 3978              	 .cfi_def_cfa_register 13
 3979              	 
 3980 0014 5DF8047B 	 ldr r7,[sp],#4
 3981              	.LCFI375:
 3982              	 .cfi_restore 7
 3983              	 .cfi_def_cfa_offset 0
 3984 0018 7047     	 bx lr
 3985              	.L264:
 3986 001a 00BF     	 .align 2
 3987              	.L263:
 3988 001c 00460050 	 .word 1342195200
 3989              	 .cfi_endproc
 3990              	.LFE217:
 3992              	 .section .text.XMC_SCU_CLOCK_IsClockEnabled,"ax",%progbits
 3993              	 .align 2
 3994              	 .global XMC_SCU_CLOCK_IsClockEnabled
 3995              	 .thumb
 3996              	 .thumb_func
 3998              	XMC_SCU_CLOCK_IsClockEnabled:
 3999              	.LFB218:
1020:../Libraries/XMCLib/src/xmc4_scu.c **** 
1021:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to determine if module clock of the given peripheral is enabled */
1022:../Libraries/XMCLib/src/xmc4_scu.c **** bool XMC_SCU_CLOCK_IsClockEnabled(const XMC_SCU_CLOCK_t clock)
1023:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4000              	 .loc 3 1023 0
 4001              	 .cfi_startproc
 4002              	 
 4003              	 
 4004              	 
 4005 0000 80B4     	 push {r7}
 4006              	.LCFI376:
 4007              	 .cfi_def_cfa_offset 4
 4008              	 .cfi_offset 7,-4
 4009 0002 83B0     	 sub sp,sp,#12
 4010              	.LCFI377:
 4011              	 .cfi_def_cfa_offset 16
 4012 0004 00AF     	 add r7,sp,#0
 4013              	.LCFI378:
 4014              	 .cfi_def_cfa_register 7
 4015 0006 0346     	 mov r3,r0
 4016 0008 FB71     	 strb r3,[r7,#7]
1024:../Libraries/XMCLib/src/xmc4_scu.c ****   return (bool)(SCU_CLK->CLKSTAT & ((uint32_t)clock));
 4017              	 .loc 3 1024 0
 4018 000a 074B     	 ldr r3,.L267
 4019 000c 1A68     	 ldr r2,[r3]
 4020 000e FB79     	 ldrb r3,[r7,#7]
 4021 0010 1340     	 ands r3,r3,r2
 4022 0012 002B     	 cmp r3,#0
 4023 0014 14BF     	 ite ne
 4024 0016 0123     	 movne r3,#1
 4025 0018 0023     	 moveq r3,#0
 4026 001a DBB2     	 uxtb r3,r3
1025:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4027              	 .loc 3 1025 0
 4028 001c 1846     	 mov r0,r3
 4029 001e 0C37     	 adds r7,r7,#12
 4030              	.LCFI379:
 4031              	 .cfi_def_cfa_offset 4
 4032 0020 BD46     	 mov sp,r7
 4033              	.LCFI380:
 4034              	 .cfi_def_cfa_register 13
 4035              	 
 4036 0022 5DF8047B 	 ldr r7,[sp],#4
 4037              	.LCFI381:
 4038              	 .cfi_restore 7
 4039              	 .cfi_def_cfa_offset 0
 4040 0026 7047     	 bx lr
 4041              	.L268:
 4042              	 .align 2
 4043              	.L267:
 4044 0028 00460050 	 .word 1342195200
 4045              	 .cfi_endproc
 4046              	.LFE218:
 4048              	 .section .text.XMC_SCU_CLOCK_GatePeripheralClock,"ax",%progbits
 4049              	 .align 2
 4050              	 .global XMC_SCU_CLOCK_GatePeripheralClock
 4051              	 .thumb
 4052              	 .thumb_func
 4054              	XMC_SCU_CLOCK_GatePeripheralClock:
 4055              	.LFB219:
1026:../Libraries/XMCLib/src/xmc4_scu.c **** 
1027:../Libraries/XMCLib/src/xmc4_scu.c **** #if defined(CLOCK_GATING_SUPPORTED)
1028:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to gate a given module clock */
1029:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_GatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
1030:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4056              	 .loc 3 1030 0
 4057              	 .cfi_startproc
 4058              	 
 4059              	 
 4060              	 
 4061 0000 80B4     	 push {r7}
 4062              	.LCFI382:
 4063              	 .cfi_def_cfa_offset 4
 4064              	 .cfi_offset 7,-4
 4065 0002 85B0     	 sub sp,sp,#20
 4066              	.LCFI383:
 4067              	 .cfi_def_cfa_offset 24
 4068 0004 00AF     	 add r7,sp,#0
 4069              	.LCFI384:
 4070              	 .cfi_def_cfa_register 7
 4071 0006 7860     	 str r0,[r7,#4]
1031:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t index = (peripheral & 0xf0000000UL) >> 28UL;
 4072              	 .loc 3 1031 0
 4073 0008 7B68     	 ldr r3,[r7,#4]
 4074 000a 1B0F     	 lsrs r3,r3,#28
 4075 000c FB60     	 str r3,[r7,#12]
1032:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 4076              	 .loc 3 1032 0
 4077 000e 7B68     	 ldr r3,[r7,#4]
 4078 0010 23F07043 	 bic r3,r3,#-268435456
 4079 0014 BB60     	 str r3,[r7,#8]
1033:../Libraries/XMCLib/src/xmc4_scu.c **** 
1034:../Libraries/XMCLib/src/xmc4_scu.c ****   *(uint32_t *)((&(SCU_CLK->CGATSET0)) + (index * 3U)) |= (uint32_t)mask;
 4080              	 .loc 3 1034 0
 4081 0016 FA68     	 ldr r2,[r7,#12]
 4082 0018 1346     	 mov r3,r2
 4083 001a 5B00     	 lsls r3,r3,#1
 4084 001c 1344     	 add r3,r3,r2
 4085 001e 9B00     	 lsls r3,r3,#2
 4086 0020 094A     	 ldr r2,.L270
 4087 0022 1A44     	 add r2,r2,r3
 4088 0024 F968     	 ldr r1,[r7,#12]
 4089 0026 0B46     	 mov r3,r1
 4090 0028 5B00     	 lsls r3,r3,#1
 4091 002a 0B44     	 add r3,r3,r1
 4092 002c 9B00     	 lsls r3,r3,#2
 4093 002e 1946     	 mov r1,r3
 4094 0030 054B     	 ldr r3,.L270
 4095 0032 0B44     	 add r3,r3,r1
 4096 0034 1968     	 ldr r1,[r3]
 4097 0036 BB68     	 ldr r3,[r7,#8]
 4098 0038 0B43     	 orrs r3,r3,r1
 4099 003a 1360     	 str r3,[r2]
1035:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4100              	 .loc 3 1035 0
 4101 003c 1437     	 adds r7,r7,#20
 4102              	.LCFI385:
 4103              	 .cfi_def_cfa_offset 4
 4104 003e BD46     	 mov sp,r7
 4105              	.LCFI386:
 4106              	 .cfi_def_cfa_register 13
 4107              	 
 4108 0040 5DF8047B 	 ldr r7,[sp],#4
 4109              	.LCFI387:
 4110              	 .cfi_restore 7
 4111              	 .cfi_def_cfa_offset 0
 4112 0044 7047     	 bx lr
 4113              	.L271:
 4114 0046 00BF     	 .align 2
 4115              	.L270:
 4116 0048 44460050 	 .word 1342195268
 4117              	 .cfi_endproc
 4118              	.LFE219:
 4120              	 .section .text.XMC_SCU_CLOCK_UngatePeripheralClock,"ax",%progbits
 4121              	 .align 2
 4122              	 .global XMC_SCU_CLOCK_UngatePeripheralClock
 4123              	 .thumb
 4124              	 .thumb_func
 4126              	XMC_SCU_CLOCK_UngatePeripheralClock:
 4127              	.LFB220:
1036:../Libraries/XMCLib/src/xmc4_scu.c **** 
1037:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to ungate a given module clock */
1038:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
1039:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4128              	 .loc 3 1039 0
 4129              	 .cfi_startproc
 4130              	 
 4131              	 
 4132              	 
 4133 0000 80B4     	 push {r7}
 4134              	.LCFI388:
 4135              	 .cfi_def_cfa_offset 4
 4136              	 .cfi_offset 7,-4
 4137 0002 85B0     	 sub sp,sp,#20
 4138              	.LCFI389:
 4139              	 .cfi_def_cfa_offset 24
 4140 0004 00AF     	 add r7,sp,#0
 4141              	.LCFI390:
 4142              	 .cfi_def_cfa_register 7
 4143 0006 7860     	 str r0,[r7,#4]
1040:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t index = (uint32_t)((peripheral & 0xf0000000UL) >> 28UL);
 4144              	 .loc 3 1040 0
 4145 0008 7B68     	 ldr r3,[r7,#4]
 4146 000a 1B0F     	 lsrs r3,r3,#28
 4147 000c FB60     	 str r3,[r7,#12]
1041:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 4148              	 .loc 3 1041 0
 4149 000e 7B68     	 ldr r3,[r7,#4]
 4150 0010 23F07043 	 bic r3,r3,#-268435456
 4151 0014 BB60     	 str r3,[r7,#8]
1042:../Libraries/XMCLib/src/xmc4_scu.c **** 
1043:../Libraries/XMCLib/src/xmc4_scu.c ****   *(uint32_t *)(&(SCU_CLK->CGATCLR0) + (index * 3U)) |= (uint32_t)mask;
 4152              	 .loc 3 1043 0
 4153 0016 FA68     	 ldr r2,[r7,#12]
 4154 0018 1346     	 mov r3,r2
 4155 001a 5B00     	 lsls r3,r3,#1
 4156 001c 1344     	 add r3,r3,r2
 4157 001e 9B00     	 lsls r3,r3,#2
 4158 0020 094A     	 ldr r2,.L273
 4159 0022 1A44     	 add r2,r2,r3
 4160 0024 F968     	 ldr r1,[r7,#12]
 4161 0026 0B46     	 mov r3,r1
 4162 0028 5B00     	 lsls r3,r3,#1
 4163 002a 0B44     	 add r3,r3,r1
 4164 002c 9B00     	 lsls r3,r3,#2
 4165 002e 1946     	 mov r1,r3
 4166 0030 054B     	 ldr r3,.L273
 4167 0032 0B44     	 add r3,r3,r1
 4168 0034 1968     	 ldr r1,[r3]
 4169 0036 BB68     	 ldr r3,[r7,#8]
 4170 0038 0B43     	 orrs r3,r3,r1
 4171 003a 1360     	 str r3,[r2]
1044:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4172              	 .loc 3 1044 0
 4173 003c 1437     	 adds r7,r7,#20
 4174              	.LCFI391:
 4175              	 .cfi_def_cfa_offset 4
 4176 003e BD46     	 mov sp,r7
 4177              	.LCFI392:
 4178              	 .cfi_def_cfa_register 13
 4179              	 
 4180 0040 5DF8047B 	 ldr r7,[sp],#4
 4181              	.LCFI393:
 4182              	 .cfi_restore 7
 4183              	 .cfi_def_cfa_offset 0
 4184 0044 7047     	 bx lr
 4185              	.L274:
 4186 0046 00BF     	 .align 2
 4187              	.L273:
 4188 0048 48460050 	 .word 1342195272
 4189              	 .cfi_endproc
 4190              	.LFE220:
 4192              	 .section .text.XMC_SCU_CLOCK_IsPeripheralClockGated,"ax",%progbits
 4193              	 .align 2
 4194              	 .global XMC_SCU_CLOCK_IsPeripheralClockGated
 4195              	 .thumb
 4196              	 .thumb_func
 4198              	XMC_SCU_CLOCK_IsPeripheralClockGated:
 4199              	.LFB221:
1045:../Libraries/XMCLib/src/xmc4_scu.c **** 
1046:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to ungate a given module clock */
1047:../Libraries/XMCLib/src/xmc4_scu.c **** bool XMC_SCU_CLOCK_IsPeripheralClockGated(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
1048:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4200              	 .loc 3 1048 0
 4201              	 .cfi_startproc
 4202              	 
 4203              	 
 4204              	 
 4205 0000 80B4     	 push {r7}
 4206              	.LCFI394:
 4207              	 .cfi_def_cfa_offset 4
 4208              	 .cfi_offset 7,-4
 4209 0002 85B0     	 sub sp,sp,#20
 4210              	.LCFI395:
 4211              	 .cfi_def_cfa_offset 24
 4212 0004 00AF     	 add r7,sp,#0
 4213              	.LCFI396:
 4214              	 .cfi_def_cfa_register 7
 4215 0006 7860     	 str r0,[r7,#4]
1049:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t index = ((peripheral & 0xf0000000UL) >> 28UL);
 4216              	 .loc 3 1049 0
 4217 0008 7B68     	 ldr r3,[r7,#4]
 4218 000a 1B0F     	 lsrs r3,r3,#28
 4219 000c FB60     	 str r3,[r7,#12]
1050:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 4220              	 .loc 3 1050 0
 4221 000e 7B68     	 ldr r3,[r7,#4]
 4222 0010 23F07043 	 bic r3,r3,#-268435456
 4223 0014 BB60     	 str r3,[r7,#8]
1051:../Libraries/XMCLib/src/xmc4_scu.c **** 
1052:../Libraries/XMCLib/src/xmc4_scu.c ****   return ((*(uint32_t *)(&(SCU_CLK->CGATSTAT0) + (index * 3U)) & mask) != 0U);
 4224              	 .loc 3 1052 0
 4225 0016 FA68     	 ldr r2,[r7,#12]
 4226 0018 1346     	 mov r3,r2
 4227 001a 5B00     	 lsls r3,r3,#1
 4228 001c 1344     	 add r3,r3,r2
 4229 001e 9B00     	 lsls r3,r3,#2
 4230 0020 1A46     	 mov r2,r3
 4231 0022 084B     	 ldr r3,.L277
 4232 0024 1344     	 add r3,r3,r2
 4233 0026 1A68     	 ldr r2,[r3]
 4234 0028 BB68     	 ldr r3,[r7,#8]
 4235 002a 1340     	 ands r3,r3,r2
 4236 002c 002B     	 cmp r3,#0
 4237 002e 14BF     	 ite ne
 4238 0030 0123     	 movne r3,#1
 4239 0032 0023     	 moveq r3,#0
 4240 0034 DBB2     	 uxtb r3,r3
1053:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4241              	 .loc 3 1053 0
 4242 0036 1846     	 mov r0,r3
 4243 0038 1437     	 adds r7,r7,#20
 4244              	.LCFI397:
 4245              	 .cfi_def_cfa_offset 4
 4246 003a BD46     	 mov sp,r7
 4247              	.LCFI398:
 4248              	 .cfi_def_cfa_register 13
 4249              	 
 4250 003c 5DF8047B 	 ldr r7,[sp],#4
 4251              	.LCFI399:
 4252              	 .cfi_restore 7
 4253              	 .cfi_def_cfa_offset 0
 4254 0040 7047     	 bx lr
 4255              	.L278:
 4256 0042 00BF     	 .align 2
 4257              	.L277:
 4258 0044 40460050 	 .word 1342195264
 4259              	 .cfi_endproc
 4260              	.LFE221:
 4262              	 .section .text.XMC_SCU_CLOCK_EnableUsbPll,"ax",%progbits
 4263              	 .align 2
 4264              	 .global XMC_SCU_CLOCK_EnableUsbPll
 4265              	 .thumb
 4266              	 .thumb_func
 4268              	XMC_SCU_CLOCK_EnableUsbPll:
 4269              	.LFB222:
1054:../Libraries/XMCLib/src/xmc4_scu.c **** #endif
1055:../Libraries/XMCLib/src/xmc4_scu.c **** 
1056:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to enable USB PLL for USB clock */
1057:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_EnableUsbPll(void)
1058:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4270              	 .loc 3 1058 0
 4271              	 .cfi_startproc
 4272              	 
 4273              	 
 4274              	 
 4275 0000 80B4     	 push {r7}
 4276              	.LCFI400:
 4277              	 .cfi_def_cfa_offset 4
 4278              	 .cfi_offset 7,-4
 4279 0002 00AF     	 add r7,sp,#0
 4280              	.LCFI401:
 4281              	 .cfi_def_cfa_register 7
1059:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->USBPLLCON &= (uint32_t)~(SCU_PLL_USBPLLCON_VCOPWD_Msk | SCU_PLL_USBPLLCON_PLLPWD_Msk);
 4282              	 .loc 3 1059 0
 4283 0004 054A     	 ldr r2,.L280
 4284 0006 054B     	 ldr r3,.L280
 4285 0008 5B69     	 ldr r3,[r3,#20]
 4286 000a 23F48033 	 bic r3,r3,#65536
 4287 000e 23F00203 	 bic r3,r3,#2
 4288 0012 5361     	 str r3,[r2,#20]
1060:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4289              	 .loc 3 1060 0
 4290 0014 BD46     	 mov sp,r7
 4291              	.LCFI402:
 4292              	 .cfi_def_cfa_register 13
 4293              	 
 4294 0016 5DF8047B 	 ldr r7,[sp],#4
 4295              	.LCFI403:
 4296              	 .cfi_restore 7
 4297              	 .cfi_def_cfa_offset 0
 4298 001a 7047     	 bx lr
 4299              	.L281:
 4300              	 .align 2
 4301              	.L280:
 4302 001c 10470050 	 .word 1342195472
 4303              	 .cfi_endproc
 4304              	.LFE222:
 4306              	 .section .text.XMC_SCU_CLOCK_DisableUsbPll,"ax",%progbits
 4307              	 .align 2
 4308              	 .global XMC_SCU_CLOCK_DisableUsbPll
 4309              	 .thumb
 4310              	 .thumb_func
 4312              	XMC_SCU_CLOCK_DisableUsbPll:
 4313              	.LFB223:
1061:../Libraries/XMCLib/src/xmc4_scu.c **** 
1062:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to disable USB PLL for USB clock */
1063:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_DisableUsbPll(void)
1064:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4314              	 .loc 3 1064 0
 4315              	 .cfi_startproc
 4316              	 
 4317              	 
 4318              	 
 4319 0000 80B4     	 push {r7}
 4320              	.LCFI404:
 4321              	 .cfi_def_cfa_offset 4
 4322              	 .cfi_offset 7,-4
 4323 0002 00AF     	 add r7,sp,#0
 4324              	.LCFI405:
 4325              	 .cfi_def_cfa_register 7
1065:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->USBPLLCON |= (uint32_t)(SCU_PLL_USBPLLCON_VCOPWD_Msk | SCU_PLL_USBPLLCON_PLLPWD_Msk);
 4326              	 .loc 3 1065 0
 4327 0004 054A     	 ldr r2,.L283
 4328 0006 054B     	 ldr r3,.L283
 4329 0008 5B69     	 ldr r3,[r3,#20]
 4330 000a 43F48033 	 orr r3,r3,#65536
 4331 000e 43F00203 	 orr r3,r3,#2
 4332 0012 5361     	 str r3,[r2,#20]
1066:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4333              	 .loc 3 1066 0
 4334 0014 BD46     	 mov sp,r7
 4335              	.LCFI406:
 4336              	 .cfi_def_cfa_register 13
 4337              	 
 4338 0016 5DF8047B 	 ldr r7,[sp],#4
 4339              	.LCFI407:
 4340              	 .cfi_restore 7
 4341              	 .cfi_def_cfa_offset 0
 4342 001a 7047     	 bx lr
 4343              	.L284:
 4344              	 .align 2
 4345              	.L283:
 4346 001c 10470050 	 .word 1342195472
 4347              	 .cfi_endproc
 4348              	.LFE223:
 4350              	 .section .text.XMC_SCU_CLOCK_StartUsbPll,"ax",%progbits
 4351              	 .align 2
 4352              	 .global XMC_SCU_CLOCK_StartUsbPll
 4353              	 .thumb
 4354              	 .thumb_func
 4356              	XMC_SCU_CLOCK_StartUsbPll:
 4357              	.LFB224:
1067:../Libraries/XMCLib/src/xmc4_scu.c **** 
1068:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to configure USB PLL */
1069:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_StartUsbPll(uint32_t pdiv, uint32_t ndiv)
1070:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4358              	 .loc 3 1070 0
 4359              	 .cfi_startproc
 4360              	 
 4361              	 
 4362              	 
 4363 0000 80B4     	 push {r7}
 4364              	.LCFI408:
 4365              	 .cfi_def_cfa_offset 4
 4366              	 .cfi_offset 7,-4
 4367 0002 83B0     	 sub sp,sp,#12
 4368              	.LCFI409:
 4369              	 .cfi_def_cfa_offset 16
 4370 0004 00AF     	 add r7,sp,#0
 4371              	.LCFI410:
 4372              	 .cfi_def_cfa_register 7
 4373 0006 7860     	 str r0,[r7,#4]
 4374 0008 3960     	 str r1,[r7]
1071:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Go to bypass the USB PLL */
1072:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;
 4375              	 .loc 3 1072 0
 4376 000a 194A     	 ldr r2,.L287
 4377 000c 184B     	 ldr r3,.L287
 4378 000e 5B69     	 ldr r3,[r3,#20]
 4379 0010 43F00103 	 orr r3,r3,#1
 4380 0014 5361     	 str r3,[r2,#20]
1073:../Libraries/XMCLib/src/xmc4_scu.c **** 
1074:../Libraries/XMCLib/src/xmc4_scu.c ****   /* disconnect Oscillator from USB PLL */
1075:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 4381              	 .loc 3 1075 0
 4382 0016 164A     	 ldr r2,.L287
 4383 0018 154B     	 ldr r3,.L287
 4384 001a 5B69     	 ldr r3,[r3,#20]
 4385 001c 43F01003 	 orr r3,r3,#16
 4386 0020 5361     	 str r3,[r2,#20]
1076:../Libraries/XMCLib/src/xmc4_scu.c **** 
1077:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Setup Divider settings for USB PLL */
1078:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 4387              	 .loc 3 1078 0
 4388 0022 1349     	 ldr r1,.L287
 4389 0024 3B68     	 ldr r3,[r7]
 4390 0026 013B     	 subs r3,r3,#1
 4391 0028 1A02     	 lsls r2,r3,#8
1079:../Libraries/XMCLib/src/xmc4_scu.c ****                        (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));
 4392              	 .loc 3 1079 0
 4393 002a 7B68     	 ldr r3,[r7,#4]
 4394 002c 013B     	 subs r3,r3,#1
 4395 002e 1B06     	 lsls r3,r3,#24
1078:../Libraries/XMCLib/src/xmc4_scu.c ****                        (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));
 4396              	 .loc 3 1078 0
 4397 0030 1343     	 orrs r3,r3,r2
 4398 0032 4B61     	 str r3,[r1,#20]
1080:../Libraries/XMCLib/src/xmc4_scu.c **** 
1081:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Set OSCDISCDIS */
1082:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 4399              	 .loc 3 1082 0
 4400 0034 0E4A     	 ldr r2,.L287
 4401 0036 0E4B     	 ldr r3,.L287
 4402 0038 5B69     	 ldr r3,[r3,#20]
 4403 003a 43F04003 	 orr r3,r3,#64
 4404 003e 5361     	 str r3,[r2,#20]
1083:../Libraries/XMCLib/src/xmc4_scu.c **** 
1084:../Libraries/XMCLib/src/xmc4_scu.c ****   /* connect Oscillator to USB PLL */
1085:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->USBPLLCON &= (uint32_t)~SCU_PLL_USBPLLCON_FINDIS_Msk;
 4405              	 .loc 3 1085 0
 4406 0040 0B4A     	 ldr r2,.L287
 4407 0042 0B4B     	 ldr r3,.L287
 4408 0044 5B69     	 ldr r3,[r3,#20]
 4409 0046 23F01003 	 bic r3,r3,#16
 4410 004a 5361     	 str r3,[r2,#20]
1086:../Libraries/XMCLib/src/xmc4_scu.c **** 
1087:../Libraries/XMCLib/src/xmc4_scu.c ****   /* restart PLL Lock detection */
1088:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_RESLD_Msk;
 4411              	 .loc 3 1088 0
 4412 004c 084A     	 ldr r2,.L287
 4413 004e 084B     	 ldr r3,.L287
 4414 0050 5B69     	 ldr r3,[r3,#20]
 4415 0052 43F48023 	 orr r3,r3,#262144
 4416 0056 5361     	 str r3,[r2,#20]
1089:../Libraries/XMCLib/src/xmc4_scu.c **** 
1090:../Libraries/XMCLib/src/xmc4_scu.c ****   while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) == 0U)
 4417              	 .loc 3 1090 0
 4418 0058 00BF     	 nop
 4419              	.L286:
 4420              	 .loc 3 1090 0 is_stmt 0 discriminator 1
 4421 005a 054B     	 ldr r3,.L287
 4422 005c 1B69     	 ldr r3,[r3,#16]
 4423 005e 03F00403 	 and r3,r3,#4
 4424 0062 002B     	 cmp r3,#0
 4425 0064 F9D0     	 beq .L286
1091:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1092:../Libraries/XMCLib/src/xmc4_scu.c ****     /* wait for PLL Lock */
1093:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1094:../Libraries/XMCLib/src/xmc4_scu.c **** 
1095:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4426              	 .loc 3 1095 0 is_stmt 1
 4427 0066 0C37     	 adds r7,r7,#12
 4428              	.LCFI411:
 4429              	 .cfi_def_cfa_offset 4
 4430 0068 BD46     	 mov sp,r7
 4431              	.LCFI412:
 4432              	 .cfi_def_cfa_register 13
 4433              	 
 4434 006a 5DF8047B 	 ldr r7,[sp],#4
 4435              	.LCFI413:
 4436              	 .cfi_restore 7
 4437              	 .cfi_def_cfa_offset 0
 4438 006e 7047     	 bx lr
 4439              	.L288:
 4440              	 .align 2
 4441              	.L287:
 4442 0070 10470050 	 .word 1342195472
 4443              	 .cfi_endproc
 4444              	.LFE224:
 4446              	 .section .text.XMC_SCU_CLOCK_StopUsbPll,"ax",%progbits
 4447              	 .align 2
 4448              	 .global XMC_SCU_CLOCK_StopUsbPll
 4449              	 .thumb
 4450              	 .thumb_func
 4452              	XMC_SCU_CLOCK_StopUsbPll:
 4453              	.LFB225:
1096:../Libraries/XMCLib/src/xmc4_scu.c **** 
1097:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to disable USB PLL operation */
1098:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_StopUsbPll(void)
1099:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4454              	 .loc 3 1099 0
 4455              	 .cfi_startproc
 4456              	 
 4457              	 
 4458              	 
 4459 0000 80B4     	 push {r7}
 4460              	.LCFI414:
 4461              	 .cfi_def_cfa_offset 4
 4462              	 .cfi_offset 7,-4
 4463 0002 00AF     	 add r7,sp,#0
 4464              	.LCFI415:
 4465              	 .cfi_def_cfa_register 7
1100:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->USBPLLCON = (uint32_t)(SCU_PLL_USBPLLCON_VCOPWD_Msk | SCU_PLL_USBPLLCON_PLLPWD_Msk |
 4466              	 .loc 3 1100 0
 4467 0004 034B     	 ldr r3,.L290
 4468 0006 044A     	 ldr r2,.L290+4
 4469 0008 5A61     	 str r2,[r3,#20]
1101:../Libraries/XMCLib/src/xmc4_scu.c ****                                   SCU_PLL_USBPLLCON_VCOBYP_Msk);
1102:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4470              	 .loc 3 1102 0
 4471 000a BD46     	 mov sp,r7
 4472              	.LCFI416:
 4473              	 .cfi_def_cfa_register 13
 4474              	 
 4475 000c 5DF8047B 	 ldr r7,[sp],#4
 4476              	.LCFI417:
 4477              	 .cfi_restore 7
 4478              	 .cfi_def_cfa_offset 0
 4479 0010 7047     	 bx lr
 4480              	.L291:
 4481 0012 00BF     	 .align 2
 4482              	.L290:
 4483 0014 10470050 	 .word 1342195472
 4484 0018 03000100 	 .word 65539
 4485              	 .cfi_endproc
 4486              	.LFE225:
 4488              	 .section .text.XMC_SCU_CLOCK_SetBackupClockCalibrationMode,"ax",%progbits
 4489              	 .align 2
 4490              	 .global XMC_SCU_CLOCK_SetBackupClockCalibrationMode
 4491              	 .thumb
 4492              	 .thumb_func
 4494              	XMC_SCU_CLOCK_SetBackupClockCalibrationMode:
 4495              	.LFB226:
1103:../Libraries/XMCLib/src/xmc4_scu.c **** 
1104:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to onfigure the calibration mode for internal oscillator */
1105:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
1106:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4496              	 .loc 3 1106 0
 4497              	 .cfi_startproc
 4498              	 
 4499              	 
 4500 0000 80B5     	 push {r7,lr}
 4501              	.LCFI418:
 4502              	 .cfi_def_cfa_offset 8
 4503              	 .cfi_offset 7,-8
 4504              	 .cfi_offset 14,-4
 4505 0002 82B0     	 sub sp,sp,#8
 4506              	.LCFI419:
 4507              	 .cfi_def_cfa_offset 16
 4508 0004 00AF     	 add r7,sp,#0
 4509              	.LCFI420:
 4510              	 .cfi_def_cfa_register 7
 4511 0006 0346     	 mov r3,r0
 4512 0008 FB71     	 strb r3,[r7,#7]
1107:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Enable factory calibration based trimming */
1108:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 4513              	 .loc 3 1108 0
 4514 000a 0F4A     	 ldr r2,.L294
 4515 000c 0E4B     	 ldr r3,.L294
 4516 000e 5B68     	 ldr r3,[r3,#4]
 4517 0010 43F48013 	 orr r3,r3,#1048576
 4518 0014 5360     	 str r3,[r2,#4]
1109:../Libraries/XMCLib/src/xmc4_scu.c **** 
1110:../Libraries/XMCLib/src/xmc4_scu.c ****   if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
 4519              	 .loc 3 1110 0
 4520 0016 FB79     	 ldrb r3,[r7,#7]
 4521 0018 012B     	 cmp r3,#1
 4522 001a 0ED1     	 bne .L293
1111:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1112:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Disable factory calibration based trimming */
1113:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
 4523              	 .loc 3 1113 0
 4524 001c 0A4A     	 ldr r2,.L294
 4525 001e 0A4B     	 ldr r3,.L294
 4526 0020 5B68     	 ldr r3,[r3,#4]
 4527 0022 23F48013 	 bic r3,r3,#1048576
 4528 0026 5360     	 str r3,[r2,#4]
1114:../Libraries/XMCLib/src/xmc4_scu.c ****     XMC_SCU_lDelay(100UL);
 4529              	 .loc 3 1114 0
 4530 0028 6420     	 movs r0,#100
 4531 002a FFF7FEFF 	 bl XMC_SCU_lDelay
1115:../Libraries/XMCLib/src/xmc4_scu.c **** 
1116:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Enable automatic calibration */
1117:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_AOTREN_Msk;
 4532              	 .loc 3 1117 0
 4533 002e 064A     	 ldr r2,.L294
 4534 0030 054B     	 ldr r3,.L294
 4535 0032 5B68     	 ldr r3,[r3,#4]
 4536 0034 43F40023 	 orr r3,r3,#524288
 4537 0038 5360     	 str r3,[r2,#4]
 4538              	.L293:
1118:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1119:../Libraries/XMCLib/src/xmc4_scu.c **** 
1120:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_lDelay(100UL);
 4539              	 .loc 3 1120 0
 4540 003a 6420     	 movs r0,#100
 4541 003c FFF7FEFF 	 bl XMC_SCU_lDelay
1121:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4542              	 .loc 3 1121 0
 4543 0040 0837     	 adds r7,r7,#8
 4544              	.LCFI421:
 4545              	 .cfi_def_cfa_offset 8
 4546 0042 BD46     	 mov sp,r7
 4547              	.LCFI422:
 4548              	 .cfi_def_cfa_register 13
 4549              	 
 4550 0044 80BD     	 pop {r7,pc}
 4551              	.L295:
 4552 0046 00BF     	 .align 2
 4553              	.L294:
 4554 0048 10470050 	 .word 1342195472
 4555              	 .cfi_endproc
 4556              	.LFE226:
 4558              	 .section .text.XMC_SCU_POWER_EnableUsb,"ax",%progbits
 4559              	 .align 2
 4560              	 .global XMC_SCU_POWER_EnableUsb
 4561              	 .thumb
 4562              	 .thumb_func
 4564              	XMC_SCU_POWER_EnableUsb:
 4565              	.LFB227:
1122:../Libraries/XMCLib/src/xmc4_scu.c **** 
1123:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to enable USB Phy and comparator */
1124:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_POWER_EnableUsb(void)
1125:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4566              	 .loc 3 1125 0
 4567              	 .cfi_startproc
 4568              	 
 4569              	 
 4570              	 
 4571 0000 80B4     	 push {r7}
 4572              	.LCFI423:
 4573              	 .cfi_def_cfa_offset 4
 4574              	 .cfi_offset 7,-4
 4575 0002 00AF     	 add r7,sp,#0
 4576              	.LCFI424:
 4577              	 .cfi_def_cfa_register 7
1126:../Libraries/XMCLib/src/xmc4_scu.c **** #if defined(USB_OTG_SUPPORTED)
1127:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_POWER->PWRSET |= (uint32_t)(SCU_POWER_PWRSET_USBOTGEN_Msk | SCU_POWER_PWRSET_USBPHYPDQ_Msk);
 4578              	 .loc 3 1127 0
 4579 0004 044A     	 ldr r2,.L297
 4580 0006 044B     	 ldr r3,.L297
 4581 0008 5B68     	 ldr r3,[r3,#4]
 4582 000a 43F44033 	 orr r3,r3,#196608
 4583 000e 5360     	 str r3,[r2,#4]
1128:../Libraries/XMCLib/src/xmc4_scu.c **** #else
1129:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_POWER->PWRSET |= (uint32_t)SCU_POWER_PWRSET_USBPHYPDQ_Msk;
1130:../Libraries/XMCLib/src/xmc4_scu.c **** #endif
1131:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4584              	 .loc 3 1131 0
 4585 0010 BD46     	 mov sp,r7
 4586              	.LCFI425:
 4587              	 .cfi_def_cfa_register 13
 4588              	 
 4589 0012 5DF8047B 	 ldr r7,[sp],#4
 4590              	.LCFI426:
 4591              	 .cfi_restore 7
 4592              	 .cfi_def_cfa_offset 0
 4593 0016 7047     	 bx lr
 4594              	.L298:
 4595              	 .align 2
 4596              	.L297:
 4597 0018 00420050 	 .word 1342194176
 4598              	 .cfi_endproc
 4599              	.LFE227:
 4601              	 .section .text.XMC_SCU_POWER_DisableUsb,"ax",%progbits
 4602              	 .align 2
 4603              	 .global XMC_SCU_POWER_DisableUsb
 4604              	 .thumb
 4605              	 .thumb_func
 4607              	XMC_SCU_POWER_DisableUsb:
 4608              	.LFB228:
1132:../Libraries/XMCLib/src/xmc4_scu.c **** 
1133:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to power down USB Phy and comparator */
1134:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_POWER_DisableUsb(void)
1135:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4609              	 .loc 3 1135 0
 4610              	 .cfi_startproc
 4611              	 
 4612              	 
 4613              	 
 4614 0000 80B4     	 push {r7}
 4615              	.LCFI427:
 4616              	 .cfi_def_cfa_offset 4
 4617              	 .cfi_offset 7,-4
 4618 0002 00AF     	 add r7,sp,#0
 4619              	.LCFI428:
 4620              	 .cfi_def_cfa_register 7
1136:../Libraries/XMCLib/src/xmc4_scu.c **** #if defined(USB_OTG_SUPPORTED)
1137:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_POWER->PWRCLR |= (uint32_t)(SCU_POWER_PWRCLR_USBOTGEN_Msk | SCU_POWER_PWRSET_USBPHYPDQ_Msk);
 4621              	 .loc 3 1137 0
 4622 0004 044A     	 ldr r2,.L300
 4623 0006 044B     	 ldr r3,.L300
 4624 0008 9B68     	 ldr r3,[r3,#8]
 4625 000a 43F44033 	 orr r3,r3,#196608
 4626 000e 9360     	 str r3,[r2,#8]
1138:../Libraries/XMCLib/src/xmc4_scu.c **** #else
1139:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_POWER->PWRCLR |= (uint32_t)SCU_POWER_PWRCLR_USBPHYPDQ_Msk;
1140:../Libraries/XMCLib/src/xmc4_scu.c **** #endif    
1141:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4627              	 .loc 3 1141 0
 4628 0010 BD46     	 mov sp,r7
 4629              	.LCFI429:
 4630              	 .cfi_def_cfa_register 13
 4631              	 
 4632 0012 5DF8047B 	 ldr r7,[sp],#4
 4633              	.LCFI430:
 4634              	 .cfi_restore 7
 4635              	 .cfi_def_cfa_offset 0
 4636 0016 7047     	 bx lr
 4637              	.L301:
 4638              	 .align 2
 4639              	.L300:
 4640 0018 00420050 	 .word 1342194176
 4641              	 .cfi_endproc
 4642              	.LFE228:
 4644              	 .section .text.XMC_SCU_CLOCK_IsUsbPllLocked,"ax",%progbits
 4645              	 .align 2
 4646              	 .global XMC_SCU_CLOCK_IsUsbPllLocked
 4647              	 .thumb
 4648              	 .thumb_func
 4650              	XMC_SCU_CLOCK_IsUsbPllLocked:
 4651              	.LFB229:
1142:../Libraries/XMCLib/src/xmc4_scu.c **** 
1143:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to check USB PLL is locked or not */
1144:../Libraries/XMCLib/src/xmc4_scu.c **** bool XMC_SCU_CLOCK_IsUsbPllLocked(void)
1145:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4652              	 .loc 3 1145 0
 4653              	 .cfi_startproc
 4654              	 
 4655              	 
 4656              	 
 4657 0000 80B4     	 push {r7}
 4658              	.LCFI431:
 4659              	 .cfi_def_cfa_offset 4
 4660              	 .cfi_offset 7,-4
 4661 0002 00AF     	 add r7,sp,#0
 4662              	.LCFI432:
 4663              	 .cfi_def_cfa_register 7
1146:../Libraries/XMCLib/src/xmc4_scu.c ****   return (bool)((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) != 0UL);
 4664              	 .loc 3 1146 0
 4665 0004 064B     	 ldr r3,.L304
 4666 0006 1B69     	 ldr r3,[r3,#16]
 4667 0008 03F00403 	 and r3,r3,#4
 4668 000c 002B     	 cmp r3,#0
 4669 000e 14BF     	 ite ne
 4670 0010 0123     	 movne r3,#1
 4671 0012 0023     	 moveq r3,#0
 4672 0014 DBB2     	 uxtb r3,r3
1147:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4673              	 .loc 3 1147 0
 4674 0016 1846     	 mov r0,r3
 4675 0018 BD46     	 mov sp,r7
 4676              	.LCFI433:
 4677              	 .cfi_def_cfa_register 13
 4678              	 
 4679 001a 5DF8047B 	 ldr r7,[sp],#4
 4680              	.LCFI434:
 4681              	 .cfi_restore 7
 4682              	 .cfi_def_cfa_offset 0
 4683 001e 7047     	 bx lr
 4684              	.L305:
 4685              	 .align 2
 4686              	.L304:
 4687 0020 10470050 	 .word 1342195472
 4688              	 .cfi_endproc
 4689              	.LFE229:
 4691              	 .section .text.XMC_SCU_HIB_EnableHibernateDomain,"ax",%progbits
 4692              	 .align 2
 4693              	 .global XMC_SCU_HIB_EnableHibernateDomain
 4694              	 .thumb
 4695              	 .thumb_func
 4697              	XMC_SCU_HIB_EnableHibernateDomain:
 4698              	.LFB230:
1148:../Libraries/XMCLib/src/xmc4_scu.c **** 
1149:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to power up the hibernation domain */
1150:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_HIB_EnableHibernateDomain(void)
1151:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4699              	 .loc 3 1151 0
 4700              	 .cfi_startproc
 4701              	 
 4702              	 
 4703 0000 80B5     	 push {r7,lr}
 4704              	.LCFI435:
 4705              	 .cfi_def_cfa_offset 8
 4706              	 .cfi_offset 7,-8
 4707              	 .cfi_offset 14,-4
 4708 0002 00AF     	 add r7,sp,#0
 4709              	.LCFI436:
 4710              	 .cfi_def_cfa_register 7
1152:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Power up HIB domain if and only if it is currently powered down */
1153:../Libraries/XMCLib/src/xmc4_scu.c ****   if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 4711              	 .loc 3 1153 0
 4712 0004 114B     	 ldr r3,.L310
 4713 0006 1B68     	 ldr r3,[r3]
 4714 0008 03F00103 	 and r3,r3,#1
 4715 000c 002B     	 cmp r3,#0
 4716 000e 0CD1     	 bne .L307
1154:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1155:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_POWER->PWRSET |= (uint32_t)SCU_POWER_PWRSET_HIB_Msk;
 4717              	 .loc 3 1155 0
 4718 0010 0E4A     	 ldr r2,.L310
 4719 0012 0E4B     	 ldr r3,.L310
 4720 0014 5B68     	 ldr r3,[r3,#4]
 4721 0016 43F00103 	 orr r3,r3,#1
 4722 001a 5360     	 str r3,[r2,#4]
1156:../Libraries/XMCLib/src/xmc4_scu.c ****     
1157:../Libraries/XMCLib/src/xmc4_scu.c ****     while((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 4723              	 .loc 3 1157 0
 4724 001c 00BF     	 nop
 4725              	.L308:
 4726              	 .loc 3 1157 0 is_stmt 0 discriminator 1
 4727 001e 0B4B     	 ldr r3,.L310
 4728 0020 1B68     	 ldr r3,[r3]
 4729 0022 03F00103 	 and r3,r3,#1
 4730 0026 002B     	 cmp r3,#0
 4731 0028 F9D0     	 beq .L308
 4732              	.L307:
1158:../Libraries/XMCLib/src/xmc4_scu.c ****     {
1159:../Libraries/XMCLib/src/xmc4_scu.c ****       /* wait until HIB domain is enabled */
1160:../Libraries/XMCLib/src/xmc4_scu.c ****     }    
1161:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1162:../Libraries/XMCLib/src/xmc4_scu.c ****   
1163:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Remove the reset only if HIB domain were in a state of reset */
1164:../Libraries/XMCLib/src/xmc4_scu.c ****   if((SCU_RESET->RSTSTAT) & SCU_RESET_RSTSTAT_HIBRS_Msk)
 4733              	 .loc 3 1164 0 is_stmt 1
 4734 002a 094B     	 ldr r3,.L310+4
 4735 002c 1B68     	 ldr r3,[r3]
 4736 002e 03F40073 	 and r3,r3,#512
 4737 0032 002B     	 cmp r3,#0
 4738 0034 08D0     	 beq .L306
1165:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1166:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_RESET->RSTCLR |= (uint32_t)SCU_RESET_RSTCLR_HIBRS_Msk;
 4739              	 .loc 3 1166 0
 4740 0036 064A     	 ldr r2,.L310+4
 4741 0038 054B     	 ldr r3,.L310+4
 4742 003a 9B68     	 ldr r3,[r3,#8]
 4743 003c 43F40073 	 orr r3,r3,#512
 4744 0040 9360     	 str r3,[r2,#8]
1167:../Libraries/XMCLib/src/xmc4_scu.c ****     XMC_SCU_lDelay(150U);
 4745              	 .loc 3 1167 0
 4746 0042 9620     	 movs r0,#150
 4747 0044 FFF7FEFF 	 bl XMC_SCU_lDelay
 4748              	.L306:
1168:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1169:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4749              	 .loc 3 1169 0
 4750 0048 80BD     	 pop {r7,pc}
 4751              	.L311:
 4752 004a 00BF     	 .align 2
 4753              	.L310:
 4754 004c 00420050 	 .word 1342194176
 4755 0050 00440050 	 .word 1342194688
 4756              	 .cfi_endproc
 4757              	.LFE230:
 4759              	 .section .text.XMC_SCU_HIB_DisableHibernateDomain,"ax",%progbits
 4760              	 .align 2
 4761              	 .global XMC_SCU_HIB_DisableHibernateDomain
 4762              	 .thumb
 4763              	 .thumb_func
 4765              	XMC_SCU_HIB_DisableHibernateDomain:
 4766              	.LFB231:
1170:../Libraries/XMCLib/src/xmc4_scu.c **** 
1171:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to power down the hibernation domain */
1172:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_HIB_DisableHibernateDomain(void)
1173:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4767              	 .loc 3 1173 0
 4768              	 .cfi_startproc
 4769              	 
 4770              	 
 4771              	 
 4772 0000 80B4     	 push {r7}
 4773              	.LCFI437:
 4774              	 .cfi_def_cfa_offset 4
 4775              	 .cfi_offset 7,-4
 4776 0002 00AF     	 add r7,sp,#0
 4777              	.LCFI438:
 4778              	 .cfi_def_cfa_register 7
1174:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Disable hibernate domain */   
1175:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_POWER->PWRCLR |= (uint32_t)SCU_POWER_PWRCLR_HIB_Msk;
 4779              	 .loc 3 1175 0
 4780 0004 074A     	 ldr r2,.L313
 4781 0006 074B     	 ldr r3,.L313
 4782 0008 9B68     	 ldr r3,[r3,#8]
 4783 000a 43F00103 	 orr r3,r3,#1
 4784 000e 9360     	 str r3,[r2,#8]
1176:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Reset of hibernate domain reset */  
1177:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_RESET->RSTSET |= (uint32_t)SCU_RESET_RSTSET_HIBRS_Msk;
 4785              	 .loc 3 1177 0
 4786 0010 054A     	 ldr r2,.L313+4
 4787 0012 054B     	 ldr r3,.L313+4
 4788 0014 5B68     	 ldr r3,[r3,#4]
 4789 0016 43F40073 	 orr r3,r3,#512
 4790 001a 5360     	 str r3,[r2,#4]
1178:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4791              	 .loc 3 1178 0
 4792 001c BD46     	 mov sp,r7
 4793              	.LCFI439:
 4794              	 .cfi_def_cfa_register 13
 4795              	 
 4796 001e 5DF8047B 	 ldr r7,[sp],#4
 4797              	.LCFI440:
 4798              	 .cfi_restore 7
 4799              	 .cfi_def_cfa_offset 0
 4800 0022 7047     	 bx lr
 4801              	.L314:
 4802              	 .align 2
 4803              	.L313:
 4804 0024 00420050 	 .word 1342194176
 4805 0028 00440050 	 .word 1342194688
 4806              	 .cfi_endproc
 4807              	.LFE231:
 4809              	 .section .text.XMC_SCU_HIB_IsHibernateDomainEnabled,"ax",%progbits
 4810              	 .align 2
 4811              	 .global XMC_SCU_HIB_IsHibernateDomainEnabled
 4812              	 .thumb
 4813              	 .thumb_func
 4815              	XMC_SCU_HIB_IsHibernateDomainEnabled:
 4816              	.LFB232:
1179:../Libraries/XMCLib/src/xmc4_scu.c **** 
1180:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to check the hibernation domain is enabled or not */
1181:../Libraries/XMCLib/src/xmc4_scu.c **** bool XMC_SCU_HIB_IsHibernateDomainEnabled(void)
1182:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4817              	 .loc 3 1182 0
 4818              	 .cfi_startproc
 4819              	 
 4820              	 
 4821              	 
 4822 0000 80B4     	 push {r7}
 4823              	.LCFI441:
 4824              	 .cfi_def_cfa_offset 4
 4825              	 .cfi_offset 7,-4
 4826 0002 00AF     	 add r7,sp,#0
 4827              	.LCFI442:
 4828              	 .cfi_def_cfa_register 7
1183:../Libraries/XMCLib/src/xmc4_scu.c ****   return ((bool)(SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) && 
 4829              	 .loc 3 1183 0
 4830 0004 0B4B     	 ldr r3,.L319
 4831 0006 1B68     	 ldr r3,[r3]
 4832 0008 03F00103 	 and r3,r3,#1
 4833 000c 002B     	 cmp r3,#0
 4834 000e 07D0     	 beq .L316
1184:../Libraries/XMCLib/src/xmc4_scu.c ****           !(bool)(SCU_RESET->RSTSTAT & SCU_RESET_RSTSTAT_HIBRS_Msk));
 4835              	 .loc 3 1184 0 discriminator 1
 4836 0010 094B     	 ldr r3,.L319+4
 4837 0012 1B68     	 ldr r3,[r3]
 4838 0014 03F40073 	 and r3,r3,#512
1183:../Libraries/XMCLib/src/xmc4_scu.c ****   return ((bool)(SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) && 
 4839              	 .loc 3 1183 0 discriminator 1
 4840 0018 002B     	 cmp r3,#0
 4841 001a 01D1     	 bne .L316
1183:../Libraries/XMCLib/src/xmc4_scu.c ****   return ((bool)(SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) && 
 4842              	 .loc 3 1183 0 is_stmt 0 discriminator 3
 4843 001c 0123     	 movs r3,#1
 4844 001e 00E0     	 b .L317
 4845              	.L316:
1183:../Libraries/XMCLib/src/xmc4_scu.c ****   return ((bool)(SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) && 
 4846              	 .loc 3 1183 0 discriminator 4
 4847 0020 0023     	 movs r3,#0
 4848              	.L317:
1183:../Libraries/XMCLib/src/xmc4_scu.c ****   return ((bool)(SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) && 
 4849              	 .loc 3 1183 0 discriminator 6
 4850 0022 03F00103 	 and r3,r3,#1
 4851 0026 DBB2     	 uxtb r3,r3
1185:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4852              	 .loc 3 1185 0 is_stmt 1 discriminator 6
 4853 0028 1846     	 mov r0,r3
 4854 002a BD46     	 mov sp,r7
 4855              	.LCFI443:
 4856              	 .cfi_def_cfa_register 13
 4857              	 
 4858 002c 5DF8047B 	 ldr r7,[sp],#4
 4859              	.LCFI444:
 4860              	 .cfi_restore 7
 4861              	 .cfi_def_cfa_offset 0
 4862 0030 7047     	 bx lr
 4863              	.L320:
 4864 0032 00BF     	 .align 2
 4865              	.L319:
 4866 0034 00420050 	 .word 1342194176
 4867 0038 00440050 	 .word 1342194688
 4868              	 .cfi_endproc
 4869              	.LFE232:
 4871              	 .section .text.XMC_SCU_HIB_EnableInternalSlowClock,"ax",%progbits
 4872              	 .align 2
 4873              	 .global XMC_SCU_HIB_EnableInternalSlowClock
 4874              	 .thumb
 4875              	 .thumb_func
 4877              	XMC_SCU_HIB_EnableInternalSlowClock:
 4878              	.LFB233:
1186:../Libraries/XMCLib/src/xmc4_scu.c **** 
1187:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to enable internal slow clock - fOSI (32.768kHz) in hibernate domain */
1188:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_HIB_EnableInternalSlowClock(void)
1189:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4879              	 .loc 3 1189 0
 4880              	 .cfi_startproc
 4881              	 
 4882              	 
 4883              	 
 4884 0000 80B4     	 push {r7}
 4885              	.LCFI445:
 4886              	 .cfi_def_cfa_offset 4
 4887              	 .cfi_offset 7,-4
 4888 0002 00AF     	 add r7,sp,#0
 4889              	.LCFI446:
 4890              	 .cfi_def_cfa_register 7
1190:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_HIBERNATE->OSCSICTRL &= (uint32_t)~(SCU_HIBERNATE_OSCSICTRL_PWD_Msk);
 4891              	 .loc 3 1190 0
 4892 0004 084A     	 ldr r2,.L323
 4893 0006 084B     	 ldr r3,.L323
 4894 0008 5B69     	 ldr r3,[r3,#20]
 4895 000a 23F00103 	 bic r3,r3,#1
 4896 000e 5361     	 str r3,[r2,#20]
1191:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Wait until the update of OSCSICTRL register in hibernate domain is completed */
1192:../Libraries/XMCLib/src/xmc4_scu.c ****   while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_OSCSICTRL_Msk)
 4897              	 .loc 3 1192 0
 4898 0010 00BF     	 nop
 4899              	.L322:
 4900              	 .loc 3 1192 0 is_stmt 0 discriminator 1
 4901 0012 064B     	 ldr r3,.L323+4
 4902 0014 D3F8C430 	 ldr r3,[r3,#196]
 4903 0018 03F02003 	 and r3,r3,#32
 4904 001c 002B     	 cmp r3,#0
 4905 001e F8D1     	 bne .L322
1193:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1194:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1195:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4906              	 .loc 3 1195 0 is_stmt 1
 4907 0020 BD46     	 mov sp,r7
 4908              	.LCFI447:
 4909              	 .cfi_def_cfa_register 13
 4910              	 
 4911 0022 5DF8047B 	 ldr r7,[sp],#4
 4912              	.LCFI448:
 4913              	 .cfi_restore 7
 4914              	 .cfi_def_cfa_offset 0
 4915 0026 7047     	 bx lr
 4916              	.L324:
 4917              	 .align 2
 4918              	.L323:
 4919 0028 00430050 	 .word 1342194432
 4920 002c 00400050 	 .word 1342193664
 4921              	 .cfi_endproc
 4922              	.LFE233:
 4924              	 .section .text.XMC_SCU_HIB_DisableInternalSlowClock,"ax",%progbits
 4925              	 .align 2
 4926              	 .global XMC_SCU_HIB_DisableInternalSlowClock
 4927              	 .thumb
 4928              	 .thumb_func
 4930              	XMC_SCU_HIB_DisableInternalSlowClock:
 4931              	.LFB234:
1196:../Libraries/XMCLib/src/xmc4_scu.c **** 
1197:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to disable internal slow clock - fOSI (32.768kHz) in hibernate domain */
1198:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_HIB_DisableInternalSlowClock(void)
1199:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4932              	 .loc 3 1199 0
 4933              	 .cfi_startproc
 4934              	 
 4935              	 
 4936              	 
 4937 0000 80B4     	 push {r7}
 4938              	.LCFI449:
 4939              	 .cfi_def_cfa_offset 4
 4940              	 .cfi_offset 7,-4
 4941 0002 00AF     	 add r7,sp,#0
 4942              	.LCFI450:
 4943              	 .cfi_def_cfa_register 7
1200:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_HIBERNATE->OSCSICTRL |= (uint32_t)SCU_HIBERNATE_OSCSICTRL_PWD_Msk;
 4944              	 .loc 3 1200 0
 4945 0004 084A     	 ldr r2,.L327
 4946 0006 084B     	 ldr r3,.L327
 4947 0008 5B69     	 ldr r3,[r3,#20]
 4948 000a 43F00103 	 orr r3,r3,#1
 4949 000e 5361     	 str r3,[r2,#20]
1201:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Wait until the update of OSCSICTRL register in hibernate domain is completed */
1202:../Libraries/XMCLib/src/xmc4_scu.c ****   while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_OSCSICTRL_Msk)
 4950              	 .loc 3 1202 0
 4951 0010 00BF     	 nop
 4952              	.L326:
 4953              	 .loc 3 1202 0 is_stmt 0 discriminator 1
 4954 0012 064B     	 ldr r3,.L327+4
 4955 0014 D3F8C430 	 ldr r3,[r3,#196]
 4956 0018 03F02003 	 and r3,r3,#32
 4957 001c 002B     	 cmp r3,#0
 4958 001e F8D1     	 bne .L326
1203:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1204:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1205:../Libraries/XMCLib/src/xmc4_scu.c **** }
 4959              	 .loc 3 1205 0 is_stmt 1
 4960 0020 BD46     	 mov sp,r7
 4961              	.LCFI451:
 4962              	 .cfi_def_cfa_register 13
 4963              	 
 4964 0022 5DF8047B 	 ldr r7,[sp],#4
 4965              	.LCFI452:
 4966              	 .cfi_restore 7
 4967              	 .cfi_def_cfa_offset 0
 4968 0026 7047     	 bx lr
 4969              	.L328:
 4970              	 .align 2
 4971              	.L327:
 4972 0028 00430050 	 .word 1342194432
 4973 002c 00400050 	 .word 1342193664
 4974              	 .cfi_endproc
 4975              	.LFE234:
 4977              	 .section .text.XMC_SCU_CLOCK_EnableLowPowerOscillator,"ax",%progbits
 4978              	 .align 2
 4979              	 .global XMC_SCU_CLOCK_EnableLowPowerOscillator
 4980              	 .thumb
 4981              	 .thumb_func
 4983              	XMC_SCU_CLOCK_EnableLowPowerOscillator:
 4984              	.LFB235:
1206:../Libraries/XMCLib/src/xmc4_scu.c **** 
1207:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to configure the 32khz Ultra Low Power oscillator */
1208:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_EnableLowPowerOscillator(void)
1209:../Libraries/XMCLib/src/xmc4_scu.c **** {
 4985              	 .loc 3 1209 0
 4986              	 .cfi_startproc
 4987              	 
 4988              	 
 4989 0000 80B5     	 push {r7,lr}
 4990              	.LCFI453:
 4991              	 .cfi_def_cfa_offset 8
 4992              	 .cfi_offset 7,-8
 4993              	 .cfi_offset 14,-4
 4994 0002 00AF     	 add r7,sp,#0
 4995              	.LCFI454:
 4996              	 .cfi_def_cfa_register 7
1210:../Libraries/XMCLib/src/xmc4_scu.c ****   while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_OSCULCTRL_Msk)
 4997              	 .loc 3 1210 0
 4998 0004 00BF     	 nop
 4999              	.L330:
 5000              	 .loc 3 1210 0 is_stmt 0 discriminator 1
 5001 0006 194B     	 ldr r3,.L334
 5002 0008 D3F8C430 	 ldr r3,[r3,#196]
 5003 000c 03F08003 	 and r3,r3,#128
 5004 0010 002B     	 cmp r3,#0
 5005 0012 F8D1     	 bne .L330
1211:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1212:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Wait until the update of OSCULCTRL register in hibernate domain is completed */
1213:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1214:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_HIBERNATE->OSCULCTRL &= ~SCU_HIBERNATE_OSCULCTRL_MODE_Msk;
 5006              	 .loc 3 1214 0 is_stmt 1
 5007 0014 164A     	 ldr r2,.L334+4
 5008 0016 164B     	 ldr r3,.L334+4
 5009 0018 DB69     	 ldr r3,[r3,#28]
 5010 001a 23F03003 	 bic r3,r3,#48
 5011 001e D361     	 str r3,[r2,#28]
1215:../Libraries/XMCLib/src/xmc4_scu.c **** 
1216:../Libraries/XMCLib/src/xmc4_scu.c ****   /* Check if the input clock is OK using OSCULP Oscillator Watchdog*/
1217:../Libraries/XMCLib/src/xmc4_scu.c ****   while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 5012              	 .loc 3 1217 0
 5013 0020 00BF     	 nop
 5014              	.L331:
 5015              	 .loc 3 1217 0 is_stmt 0 discriminator 1
 5016 0022 124B     	 ldr r3,.L334
 5017 0024 D3F8C430 	 ldr r3,[r3,#196]
 5018 0028 03F00803 	 and r3,r3,#8
 5019 002c 002B     	 cmp r3,#0
 5020 002e F8D1     	 bne .L331
1218:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1219:../Libraries/XMCLib/src/xmc4_scu.c ****     /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
1220:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1221:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_HIBERNATE->HDCR |= (uint32_t)SCU_HIBERNATE_HDCR_ULPWDGEN_Msk;
 5021              	 .loc 3 1221 0 is_stmt 1
 5022 0030 0F4A     	 ldr r2,.L334+4
 5023 0032 0F4B     	 ldr r3,.L334+4
 5024 0034 DB68     	 ldr r3,[r3,#12]
 5025 0036 43F00803 	 orr r3,r3,#8
 5026 003a D360     	 str r3,[r2,#12]
 5027              	.L333:
1222:../Libraries/XMCLib/src/xmc4_scu.c **** 
1223:../Libraries/XMCLib/src/xmc4_scu.c ****   /* wait till clock is stable */
1224:../Libraries/XMCLib/src/xmc4_scu.c ****   do
1225:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1226:../Libraries/XMCLib/src/xmc4_scu.c ****     while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDCLR_Msk)
 5028              	 .loc 3 1226 0
 5029 003c 00BF     	 nop
 5030              	.L332:
 5031              	 .loc 3 1226 0 is_stmt 0 discriminator 1
 5032 003e 0B4B     	 ldr r3,.L334
 5033 0040 D3F8C430 	 ldr r3,[r3,#196]
 5034 0044 03F00203 	 and r3,r3,#2
 5035 0048 002B     	 cmp r3,#0
 5036 004a F8D1     	 bne .L332
1227:../Libraries/XMCLib/src/xmc4_scu.c ****     {
1228:../Libraries/XMCLib/src/xmc4_scu.c ****       /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
1229:../Libraries/XMCLib/src/xmc4_scu.c ****     }
1230:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_HIBERNATE->HDCLR |= (uint32_t)SCU_HIBERNATE_HDCLR_ULPWDG_Msk;
 5037              	 .loc 3 1230 0 is_stmt 1
 5038 004c 084A     	 ldr r2,.L334+4
 5039 004e 084B     	 ldr r3,.L334+4
 5040 0050 5B68     	 ldr r3,[r3,#4]
 5041 0052 43F00803 	 orr r3,r3,#8
 5042 0056 5360     	 str r3,[r2,#4]
1231:../Libraries/XMCLib/src/xmc4_scu.c **** 
1232:../Libraries/XMCLib/src/xmc4_scu.c ****     XMC_SCU_lDelay(50U);
 5043              	 .loc 3 1232 0
 5044 0058 3220     	 movs r0,#50
 5045 005a FFF7FEFF 	 bl XMC_SCU_lDelay
1233:../Libraries/XMCLib/src/xmc4_scu.c **** 
1234:../Libraries/XMCLib/src/xmc4_scu.c ****   } while ((SCU_HIBERNATE->HDSTAT & SCU_HIBERNATE_HDSTAT_ULPWDG_Msk) != 0UL);
 5046              	 .loc 3 1234 0
 5047 005e 044B     	 ldr r3,.L334+4
 5048 0060 1B68     	 ldr r3,[r3]
 5049 0062 03F00803 	 and r3,r3,#8
 5050 0066 002B     	 cmp r3,#0
 5051 0068 E8D1     	 bne .L333
1235:../Libraries/XMCLib/src/xmc4_scu.c **** 
1236:../Libraries/XMCLib/src/xmc4_scu.c **** }
 5052              	 .loc 3 1236 0
 5053 006a 80BD     	 pop {r7,pc}
 5054              	.L335:
 5055              	 .align 2
 5056              	.L334:
 5057 006c 00400050 	 .word 1342193664
 5058 0070 00430050 	 .word 1342194432
 5059              	 .cfi_endproc
 5060              	.LFE235:
 5062              	 .section .text.XMC_SCU_CLOCK_DisableLowPowerOscillator,"ax",%progbits
 5063              	 .align 2
 5064              	 .global XMC_SCU_CLOCK_DisableLowPowerOscillator
 5065              	 .thumb
 5066              	 .thumb_func
 5068              	XMC_SCU_CLOCK_DisableLowPowerOscillator:
 5069              	.LFB236:
1237:../Libraries/XMCLib/src/xmc4_scu.c **** 
1238:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to configure the 32khz Ultra Low Power oscillator */
1239:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_DisableLowPowerOscillator(void)
1240:../Libraries/XMCLib/src/xmc4_scu.c **** {
 5070              	 .loc 3 1240 0
 5071              	 .cfi_startproc
 5072              	 
 5073              	 
 5074              	 
 5075 0000 80B4     	 push {r7}
 5076              	.LCFI455:
 5077              	 .cfi_def_cfa_offset 4
 5078              	 .cfi_offset 7,-4
 5079 0002 00AF     	 add r7,sp,#0
 5080              	.LCFI456:
 5081              	 .cfi_def_cfa_register 7
1241:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_HIBERNATE->OSCULCTRL |= (uint32_t)SCU_HIBERNATE_OSCULCTRL_MODE_Msk;
 5082              	 .loc 3 1241 0
 5083 0004 084A     	 ldr r2,.L338
 5084 0006 084B     	 ldr r3,.L338
 5085 0008 DB69     	 ldr r3,[r3,#28]
 5086 000a 43F03003 	 orr r3,r3,#48
 5087 000e D361     	 str r3,[r2,#28]
1242:../Libraries/XMCLib/src/xmc4_scu.c **** 
1243:../Libraries/XMCLib/src/xmc4_scu.c ****   while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_OSCULCTRL_Msk)
 5088              	 .loc 3 1243 0
 5089 0010 00BF     	 nop
 5090              	.L337:
 5091              	 .loc 3 1243 0 is_stmt 0 discriminator 1
 5092 0012 064B     	 ldr r3,.L338+4
 5093 0014 D3F8C430 	 ldr r3,[r3,#196]
 5094 0018 03F08003 	 and r3,r3,#128
 5095 001c 002B     	 cmp r3,#0
 5096 001e F8D1     	 bne .L337
1244:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1245:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Wait until the update of OSCULCTRL register in hibernate domain is completed */
1246:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1247:../Libraries/XMCLib/src/xmc4_scu.c **** }
 5097              	 .loc 3 1247 0 is_stmt 1
 5098 0020 BD46     	 mov sp,r7
 5099              	.LCFI457:
 5100              	 .cfi_def_cfa_register 13
 5101              	 
 5102 0022 5DF8047B 	 ldr r7,[sp],#4
 5103              	.LCFI458:
 5104              	 .cfi_restore 7
 5105              	 .cfi_def_cfa_offset 0
 5106 0026 7047     	 bx lr
 5107              	.L339:
 5108              	 .align 2
 5109              	.L338:
 5110 0028 00430050 	 .word 1342194432
 5111 002c 00400050 	 .word 1342193664
 5112              	 .cfi_endproc
 5113              	.LFE236:
 5115              	 .section .text.XMC_SCU_CLOCK_EnableHighPerformanceOscillator,"ax",%progbits
 5116              	 .align 2
 5117              	 .global XMC_SCU_CLOCK_EnableHighPerformanceOscillator
 5118              	 .thumb
 5119              	 .thumb_func
 5121              	XMC_SCU_CLOCK_EnableHighPerformanceOscillator:
 5122              	.LFB237:
1248:../Libraries/XMCLib/src/xmc4_scu.c **** 
1249:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to enable High Precision High Speed oscillator */
1250:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
1251:../Libraries/XMCLib/src/xmc4_scu.c **** {
 5123              	 .loc 3 1251 0
 5124              	 .cfi_startproc
 5125              	 
 5126              	 
 5127 0000 B0B5     	 push {r4,r5,r7,lr}
 5128              	.LCFI459:
 5129              	 .cfi_def_cfa_offset 16
 5130              	 .cfi_offset 4,-16
 5131              	 .cfi_offset 5,-12
 5132              	 .cfi_offset 7,-8
 5133              	 .cfi_offset 14,-4
 5134 0002 00AF     	 add r7,sp,#0
 5135              	.LCFI460:
 5136              	 .cfi_def_cfa_register 7
1252:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;
 5137              	 .loc 3 1252 0
 5138 0004 134A     	 ldr r2,.L342
 5139 0006 134B     	 ldr r3,.L342
 5140 0008 5B68     	 ldr r3,[r3,#4]
 5141 000a 23F48033 	 bic r3,r3,#65536
 5142 000e 5360     	 str r3,[r2,#4]
1253:../Libraries/XMCLib/src/xmc4_scu.c **** 
1254:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCH
 5143              	 .loc 3 1254 0
 5144 0010 114D     	 ldr r5,.L342+4
 5145 0012 114B     	 ldr r3,.L342+4
 5146 0014 5B68     	 ldr r3,[r3,#4]
 5147 0016 23F47024 	 bic r4,r3,#983040
 5148 001a 24F03004 	 bic r4,r4,#48
1255:../Libraries/XMCLib/src/xmc4_scu.c ****                                   (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OS
 5149              	 .loc 3 1255 0
 5150 001e FFF7FEFF 	 bl OSCHP_GetFrequency
 5151 0022 0246     	 mov r2,r0
 5152 0024 0D4B     	 ldr r3,.L342+8
 5153 0026 A3FB0223 	 umull r2,r3,r3,r2
 5154 002a 1B0D     	 lsrs r3,r3,#20
 5155 002c 013B     	 subs r3,r3,#1
 5156 002e 1B04     	 lsls r3,r3,#16
1254:../Libraries/XMCLib/src/xmc4_scu.c ****                                   (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OS
 5157              	 .loc 3 1254 0
 5158 0030 2343     	 orrs r3,r3,r4
 5159 0032 6B60     	 str r3,[r5,#4]
1256:../Libraries/XMCLib/src/xmc4_scu.c **** 
1257:../Libraries/XMCLib/src/xmc4_scu.c ****   /* restart OSC Watchdog */
1258:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_OSCRES_Msk;
 5160              	 .loc 3 1258 0
 5161 0034 074A     	 ldr r2,.L342
 5162 0036 074B     	 ldr r3,.L342
 5163 0038 5B68     	 ldr r3,[r3,#4]
 5164 003a 23F40033 	 bic r3,r3,#131072
 5165 003e 5360     	 str r3,[r2,#4]
1259:../Libraries/XMCLib/src/xmc4_scu.c **** 
1260:../Libraries/XMCLib/src/xmc4_scu.c ****   while ((SCU_PLL->PLLSTAT & XMC_SCU_PLL_PLLSTAT_OSC_USABLE) != XMC_SCU_PLL_PLLSTAT_OSC_USABLE)
 5166              	 .loc 3 1260 0
 5167 0040 00BF     	 nop
 5168              	.L341:
 5169              	 .loc 3 1260 0 is_stmt 0 discriminator 1
 5170 0042 044B     	 ldr r3,.L342
 5171 0044 1B68     	 ldr r3,[r3]
 5172 0046 03F46073 	 and r3,r3,#896
 5173 004a B3F5607F 	 cmp r3,#896
 5174 004e F8D1     	 bne .L341
1261:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1262:../Libraries/XMCLib/src/xmc4_scu.c ****       /* wait till OSC_HP output frequency is usable */
1263:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1264:../Libraries/XMCLib/src/xmc4_scu.c **** }
 5175              	 .loc 3 1264 0 is_stmt 1
 5176 0050 B0BD     	 pop {r4,r5,r7,pc}
 5177              	.L343:
 5178 0052 00BF     	 .align 2
 5179              	.L342:
 5180 0054 10470050 	 .word 1342195472
 5181 0058 00470050 	 .word 1342195456
 5182 005c 6BCA5F6B 	 .word 1801439851
 5183              	 .cfi_endproc
 5184              	.LFE237:
 5186              	 .section .text.XMC_SCU_CLOCK_DisableHighPerformanceOscillator,"ax",%progbits
 5187              	 .align 2
 5188              	 .global XMC_SCU_CLOCK_DisableHighPerformanceOscillator
 5189              	 .thumb
 5190              	 .thumb_func
 5192              	XMC_SCU_CLOCK_DisableHighPerformanceOscillator:
 5193              	.LFB238:
1265:../Libraries/XMCLib/src/xmc4_scu.c **** 
1266:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to disable High Precision High Speed oscillator */
1267:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_DisableHighPerformanceOscillator(void)
1268:../Libraries/XMCLib/src/xmc4_scu.c **** {
 5194              	 .loc 3 1268 0
 5195              	 .cfi_startproc
 5196              	 
 5197              	 
 5198              	 
 5199 0000 80B4     	 push {r7}
 5200              	.LCFI461:
 5201              	 .cfi_def_cfa_offset 4
 5202              	 .cfi_offset 7,-4
 5203 0002 00AF     	 add r7,sp,#0
 5204              	.LCFI462:
 5205              	 .cfi_def_cfa_register 7
1269:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_OSC->OSCHPCTRL |= (uint32_t)SCU_OSC_OSCHPCTRL_MODE_Msk;
 5206              	 .loc 3 1269 0
 5207 0004 044A     	 ldr r2,.L345
 5208 0006 044B     	 ldr r3,.L345
 5209 0008 5B68     	 ldr r3,[r3,#4]
 5210 000a 43F03003 	 orr r3,r3,#48
 5211 000e 5360     	 str r3,[r2,#4]
1270:../Libraries/XMCLib/src/xmc4_scu.c **** }
 5212              	 .loc 3 1270 0
 5213 0010 BD46     	 mov sp,r7
 5214              	.LCFI463:
 5215              	 .cfi_def_cfa_register 13
 5216              	 
 5217 0012 5DF8047B 	 ldr r7,[sp],#4
 5218              	.LCFI464:
 5219              	 .cfi_restore 7
 5220              	 .cfi_def_cfa_offset 0
 5221 0016 7047     	 bx lr
 5222              	.L346:
 5223              	 .align 2
 5224              	.L345:
 5225 0018 00470050 	 .word 1342195456
 5226              	 .cfi_endproc
 5227              	.LFE238:
 5229              	 .section .text.XMC_SCU_CLOCK_EnableSystemPll,"ax",%progbits
 5230              	 .align 2
 5231              	 .global XMC_SCU_CLOCK_EnableSystemPll
 5232              	 .thumb
 5233              	 .thumb_func
 5235              	XMC_SCU_CLOCK_EnableSystemPll:
 5236              	.LFB239:
1271:../Libraries/XMCLib/src/xmc4_scu.c **** 
1272:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to enable main PLL */
1273:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_EnableSystemPll(void)
1274:../Libraries/XMCLib/src/xmc4_scu.c **** {
 5237              	 .loc 3 1274 0
 5238              	 .cfi_startproc
 5239              	 
 5240              	 
 5241              	 
 5242 0000 80B4     	 push {r7}
 5243              	.LCFI465:
 5244              	 .cfi_def_cfa_offset 4
 5245              	 .cfi_offset 7,-4
 5246 0002 00AF     	 add r7,sp,#0
 5247              	.LCFI466:
 5248              	 .cfi_def_cfa_register 7
1275:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 5249              	 .loc 3 1275 0
 5250 0004 054A     	 ldr r2,.L348
 5251 0006 054B     	 ldr r3,.L348
 5252 0008 5B68     	 ldr r3,[r3,#4]
 5253 000a 23F48033 	 bic r3,r3,#65536
 5254 000e 23F00203 	 bic r3,r3,#2
 5255 0012 5360     	 str r3,[r2,#4]
1276:../Libraries/XMCLib/src/xmc4_scu.c **** }
 5256              	 .loc 3 1276 0
 5257 0014 BD46     	 mov sp,r7
 5258              	.LCFI467:
 5259              	 .cfi_def_cfa_register 13
 5260              	 
 5261 0016 5DF8047B 	 ldr r7,[sp],#4
 5262              	.LCFI468:
 5263              	 .cfi_restore 7
 5264              	 .cfi_def_cfa_offset 0
 5265 001a 7047     	 bx lr
 5266              	.L349:
 5267              	 .align 2
 5268              	.L348:
 5269 001c 10470050 	 .word 1342195472
 5270              	 .cfi_endproc
 5271              	.LFE239:
 5273              	 .section .text.XMC_SCU_CLOCK_DisableSystemPll,"ax",%progbits
 5274              	 .align 2
 5275              	 .global XMC_SCU_CLOCK_DisableSystemPll
 5276              	 .thumb
 5277              	 .thumb_func
 5279              	XMC_SCU_CLOCK_DisableSystemPll:
 5280              	.LFB240:
1277:../Libraries/XMCLib/src/xmc4_scu.c **** 
1278:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to disable main PLL */
1279:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_DisableSystemPll(void)
1280:../Libraries/XMCLib/src/xmc4_scu.c **** {
 5281              	 .loc 3 1280 0
 5282              	 .cfi_startproc
 5283              	 
 5284              	 
 5285              	 
 5286 0000 80B4     	 push {r7}
 5287              	.LCFI469:
 5288              	 .cfi_def_cfa_offset 4
 5289              	 .cfi_offset 7,-4
 5290 0002 00AF     	 add r7,sp,#0
 5291              	.LCFI470:
 5292              	 .cfi_def_cfa_register 7
1281:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->PLLCON0 |= (uint32_t)(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 5293              	 .loc 3 1281 0
 5294 0004 054A     	 ldr r2,.L351
 5295 0006 054B     	 ldr r3,.L351
 5296 0008 5B68     	 ldr r3,[r3,#4]
 5297 000a 43F48033 	 orr r3,r3,#65536
 5298 000e 43F00203 	 orr r3,r3,#2
 5299 0012 5360     	 str r3,[r2,#4]
1282:../Libraries/XMCLib/src/xmc4_scu.c **** }
 5300              	 .loc 3 1282 0
 5301 0014 BD46     	 mov sp,r7
 5302              	.LCFI471:
 5303              	 .cfi_def_cfa_register 13
 5304              	 
 5305 0016 5DF8047B 	 ldr r7,[sp],#4
 5306              	.LCFI472:
 5307              	 .cfi_restore 7
 5308              	 .cfi_def_cfa_offset 0
 5309 001a 7047     	 bx lr
 5310              	.L352:
 5311              	 .align 2
 5312              	.L351:
 5313 001c 10470050 	 .word 1342195472
 5314              	 .cfi_endproc
 5315              	.LFE240:
 5317              	 .section .text.XMC_SCU_CLOCK_StartSystemPll,"ax",%progbits
 5318              	 .align 2
 5319              	 .global XMC_SCU_CLOCK_StartSystemPll
 5320              	 .thumb
 5321              	 .thumb_func
 5323              	XMC_SCU_CLOCK_StartSystemPll:
 5324              	.LFB241:
1283:../Libraries/XMCLib/src/xmc4_scu.c **** 
1284:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to configure main PLL */
1285:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_StartSystemPll(XMC_SCU_CLOCK_SYSPLLCLKSRC_t source,
1286:../Libraries/XMCLib/src/xmc4_scu.c ****                                   XMC_SCU_CLOCK_SYSPLL_MODE_t mode,
1287:../Libraries/XMCLib/src/xmc4_scu.c ****                                   uint32_t pdiv,
1288:../Libraries/XMCLib/src/xmc4_scu.c ****                                   uint32_t ndiv,
1289:../Libraries/XMCLib/src/xmc4_scu.c ****                                   uint32_t kdiv)
1290:../Libraries/XMCLib/src/xmc4_scu.c **** {
 5325              	 .loc 3 1290 0
 5326              	 .cfi_startproc
 5327              	 
 5328              	 
 5329 0000 80B5     	 push {r7,lr}
 5330              	.LCFI473:
 5331              	 .cfi_def_cfa_offset 8
 5332              	 .cfi_offset 7,-8
 5333              	 .cfi_offset 14,-4
 5334 0002 86B0     	 sub sp,sp,#24
 5335              	.LCFI474:
 5336              	 .cfi_def_cfa_offset 32
 5337 0004 00AF     	 add r7,sp,#0
 5338              	.LCFI475:
 5339              	 .cfi_def_cfa_register 7
 5340 0006 BA60     	 str r2,[r7,#8]
 5341 0008 7B60     	 str r3,[r7,#4]
 5342 000a 0346     	 mov r3,r0
 5343 000c FB81     	 strh r3,[r7,#14]
 5344 000e 0B46     	 mov r3,r1
 5345 0010 7B73     	 strb r3,[r7,#13]
1291:../Libraries/XMCLib/src/xmc4_scu.c **** 
1292:../Libraries/XMCLib/src/xmc4_scu.c ****   float vco_frequency;
1293:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t kdiv_temp;
1294:../Libraries/XMCLib/src/xmc4_scu.c **** 
1295:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_CLOCK_SetSystemPllClockSource(source);
 5346              	 .loc 3 1295 0
 5347 0012 FB89     	 ldrh r3,[r7,#14]
 5348 0014 1846     	 mov r0,r3
 5349 0016 FFF7FEFF 	 bl XMC_SCU_CLOCK_SetSystemPllClockSource
1296:../Libraries/XMCLib/src/xmc4_scu.c **** 
1297:../Libraries/XMCLib/src/xmc4_scu.c ****   if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 5350              	 .loc 3 1297 0
 5351 001a 7B7B     	 ldrb r3,[r7,#13]
 5352 001c 012B     	 cmp r3,#1
 5353 001e 40F09980 	 bne .L354
1298:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1299:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Calculate initial step to be close to fOFI */
1300:../Libraries/XMCLib/src/xmc4_scu.c ****     if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP)
 5354              	 .loc 3 1300 0
 5355 0022 FB89     	 ldrh r3,[r7,#14]
 5356 0024 002B     	 cmp r3,#0
 5357 0026 08D1     	 bne .L355
1301:../Libraries/XMCLib/src/xmc4_scu.c ****     {
1302:../Libraries/XMCLib/src/xmc4_scu.c ****       vco_frequency = (float)OSCHP_GetFrequency();
 5358              	 .loc 3 1302 0
 5359 0028 FFF7FEFF 	 bl OSCHP_GetFrequency
 5360 002c 07EE900A 	 fmsr s15,r0
 5361 0030 F8EE677A 	 fuitos s15,s15
 5362 0034 C7ED057A 	 fsts s15,[r7,#20]
 5363 0038 01E0     	 b .L356
 5364              	.L355:
1303:../Libraries/XMCLib/src/xmc4_scu.c ****     }
1304:../Libraries/XMCLib/src/xmc4_scu.c ****     else
1305:../Libraries/XMCLib/src/xmc4_scu.c ****     {
1306:../Libraries/XMCLib/src/xmc4_scu.c ****       vco_frequency = (float)OFI_FREQUENCY;
 5365              	 .loc 3 1306 0
 5366 003a 534B     	 ldr r3,.L363
 5367 003c 7B61     	 str r3,[r7,#20]
 5368              	.L356:
1307:../Libraries/XMCLib/src/xmc4_scu.c ****     }
1308:../Libraries/XMCLib/src/xmc4_scu.c ****     vco_frequency = (float)((vco_frequency * (float)ndiv) / (float)pdiv);
 5369              	 .loc 3 1308 0
 5370 003e 7B68     	 ldr r3,[r7,#4]
 5371 0040 07EE903A 	 fmsr s15,r3
 5372 0044 B8EE677A 	 fuitos s14,s15
 5373 0048 D7ED057A 	 flds s15,[r7,#20]
 5374 004c 27EE277A 	 fmuls s14,s14,s15
 5375 0050 BB68     	 ldr r3,[r7,#8]
 5376 0052 07EE903A 	 fmsr s15,r3
 5377 0056 F8EE677A 	 fuitos s15,s15
 5378 005a C7EE277A 	 fdivs s15,s14,s15
 5379 005e C7ED057A 	 fsts s15,[r7,#20]
1309:../Libraries/XMCLib/src/xmc4_scu.c ****     kdiv_temp = (uint32_t)((uint32_t)vco_frequency / OFI_FREQUENCY);
 5380              	 .loc 3 1309 0
 5381 0062 D7ED057A 	 flds s15,[r7,#20]
 5382 0066 FCEEE77A 	 ftouizs s15,s15
 5383 006a 17EE902A 	 fmrs r2,s15
 5384 006e 474B     	 ldr r3,.L363+4
 5385 0070 A3FB0223 	 umull r2,r3,r3,r2
 5386 0074 5B0D     	 lsrs r3,r3,#21
 5387 0076 3B61     	 str r3,[r7,#16]
1310:../Libraries/XMCLib/src/xmc4_scu.c **** 
1311:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Switch to prescaler mode */
1312:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 5388              	 .loc 3 1312 0
 5389 0078 454A     	 ldr r2,.L363+8
 5390 007a 454B     	 ldr r3,.L363+8
 5391 007c 5B68     	 ldr r3,[r3,#4]
 5392 007e 43F00103 	 orr r3,r3,#1
 5393 0082 5360     	 str r3,[r2,#4]
1313:../Libraries/XMCLib/src/xmc4_scu.c **** 
1314:../Libraries/XMCLib/src/xmc4_scu.c ****     /* disconnect Oscillator from PLL */
1315:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;
 5394              	 .loc 3 1315 0
 5395 0084 424A     	 ldr r2,.L363+8
 5396 0086 424B     	 ldr r3,.L363+8
 5397 0088 5B68     	 ldr r3,[r3,#4]
 5398 008a 43F01003 	 orr r3,r3,#16
 5399 008e 5360     	 str r3,[r2,#4]
1316:../Libraries/XMCLib/src/xmc4_scu.c **** 
1317:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Setup divider settings for main PLL */
1318:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_
 5400              	 .loc 3 1318 0
 5401 0090 3F49     	 ldr r1,.L363+8
 5402 0092 3F4B     	 ldr r3,.L363+8
 5403 0094 9A68     	 ldr r2,[r3,#8]
 5404 0096 3F4B     	 ldr r3,.L363+12
 5405 0098 1340     	 ands r3,r3,r2
1319:../Libraries/XMCLib/src/xmc4_scu.c ****                                    SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_ND
 5406              	 .loc 3 1319 0
 5407 009a 7A68     	 ldr r2,[r7,#4]
 5408 009c 013A     	 subs r2,r2,#1
 5409 009e 1202     	 lsls r2,r2,#8
 5410 00a0 1A43     	 orrs r2,r2,r3
1320:../Libraries/XMCLib/src/xmc4_scu.c ****                                    ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
 5411              	 .loc 3 1320 0
 5412 00a2 3B69     	 ldr r3,[r7,#16]
 5413 00a4 013B     	 subs r3,r3,#1
 5414 00a6 1B04     	 lsls r3,r3,#16
1319:../Libraries/XMCLib/src/xmc4_scu.c ****                                    SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_ND
 5415              	 .loc 3 1319 0
 5416 00a8 1A43     	 orrs r2,r2,r3
1321:../Libraries/XMCLib/src/xmc4_scu.c ****                                    ((pdiv - 1UL)<< SCU_PLL_PLLCON1_PDIV_Pos));
 5417              	 .loc 3 1321 0
 5418 00aa BB68     	 ldr r3,[r7,#8]
 5419 00ac 013B     	 subs r3,r3,#1
 5420 00ae 1B06     	 lsls r3,r3,#24
1318:../Libraries/XMCLib/src/xmc4_scu.c ****                                    SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_ND
 5421              	 .loc 3 1318 0
 5422 00b0 1343     	 orrs r3,r3,r2
 5423 00b2 8B60     	 str r3,[r1,#8]
1322:../Libraries/XMCLib/src/xmc4_scu.c **** 
1323:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Set OSCDISCDIS, OSC clock remains connected to the VCO in case of loss of lock */
1324:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 5424              	 .loc 3 1324 0
 5425 00b4 364A     	 ldr r2,.L363+8
 5426 00b6 364B     	 ldr r3,.L363+8
 5427 00b8 5B68     	 ldr r3,[r3,#4]
 5428 00ba 43F04003 	 orr r3,r3,#64
 5429 00be 5360     	 str r3,[r2,#4]
1325:../Libraries/XMCLib/src/xmc4_scu.c **** 
1326:../Libraries/XMCLib/src/xmc4_scu.c ****     /* connect Oscillator to PLL */
1327:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FINDIS_Msk;
 5430              	 .loc 3 1327 0
 5431 00c0 334A     	 ldr r2,.L363+8
 5432 00c2 334B     	 ldr r3,.L363+8
 5433 00c4 5B68     	 ldr r3,[r3,#4]
 5434 00c6 23F01003 	 bic r3,r3,#16
 5435 00ca 5360     	 str r3,[r2,#4]
1328:../Libraries/XMCLib/src/xmc4_scu.c **** 
1329:../Libraries/XMCLib/src/xmc4_scu.c ****     /* restart PLL Lock detection */
1330:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_RESLD_Msk;
 5436              	 .loc 3 1330 0
 5437 00cc 304A     	 ldr r2,.L363+8
 5438 00ce 304B     	 ldr r3,.L363+8
 5439 00d0 5B68     	 ldr r3,[r3,#4]
 5440 00d2 43F48023 	 orr r3,r3,#262144
 5441 00d6 5360     	 str r3,[r2,#4]
1331:../Libraries/XMCLib/src/xmc4_scu.c ****     while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk) == 0U)
 5442              	 .loc 3 1331 0
 5443 00d8 00BF     	 nop
 5444              	.L357:
 5445              	 .loc 3 1331 0 is_stmt 0 discriminator 1
 5446 00da 2D4B     	 ldr r3,.L363+8
 5447 00dc 1B68     	 ldr r3,[r3]
 5448 00de 03F00403 	 and r3,r3,#4
 5449 00e2 002B     	 cmp r3,#0
 5450 00e4 F9D0     	 beq .L357
1332:../Libraries/XMCLib/src/xmc4_scu.c ****     {
1333:../Libraries/XMCLib/src/xmc4_scu.c ****       /* wait for PLL Lock */
1334:../Libraries/XMCLib/src/xmc4_scu.c ****     }
1335:../Libraries/XMCLib/src/xmc4_scu.c **** 
1336:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Switch to normal mode */
1337:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_VCOBYP_Msk;
 5451              	 .loc 3 1337 0 is_stmt 1
 5452 00e6 2A4A     	 ldr r2,.L363+8
 5453 00e8 294B     	 ldr r3,.L363+8
 5454 00ea 5B68     	 ldr r3,[r3,#4]
 5455 00ec 23F00103 	 bic r3,r3,#1
 5456 00f0 5360     	 str r3,[r2,#4]
1338:../Libraries/XMCLib/src/xmc4_scu.c ****     while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) != 0U)
 5457              	 .loc 3 1338 0
 5458 00f2 00BF     	 nop
 5459              	.L358:
 5460              	 .loc 3 1338 0 is_stmt 0 discriminator 1
 5461 00f4 264B     	 ldr r3,.L363+8
 5462 00f6 1B68     	 ldr r3,[r3]
 5463 00f8 03F00103 	 and r3,r3,#1
 5464 00fc 002B     	 cmp r3,#0
 5465 00fe F9D1     	 bne .L358
1339:../Libraries/XMCLib/src/xmc4_scu.c ****     {
1340:../Libraries/XMCLib/src/xmc4_scu.c ****       /* wait for normal mode */
1341:../Libraries/XMCLib/src/xmc4_scu.c ****     }
1342:../Libraries/XMCLib/src/xmc4_scu.c **** 
1343:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Ramp up PLL frequency in steps */
1344:../Libraries/XMCLib/src/xmc4_scu.c ****     kdiv_temp = (uint32_t)((uint32_t)vco_frequency / 60000000UL);
 5466              	 .loc 3 1344 0 is_stmt 1
 5467 0100 D7ED057A 	 flds s15,[r7,#20]
 5468 0104 FCEEE77A 	 ftouizs s15,s15
 5469 0108 17EE903A 	 fmrs r3,s15
 5470 010c 1B0A     	 lsrs r3,r3,#8
 5471 010e 224A     	 ldr r2,.L363+16
 5472 0110 A2FB0323 	 umull r2,r3,r2,r3
 5473 0114 9B0A     	 lsrs r3,r3,#10
 5474 0116 3B61     	 str r3,[r7,#16]
1345:../Libraries/XMCLib/src/xmc4_scu.c ****     if (kdiv < kdiv_temp)
 5475              	 .loc 3 1345 0
 5476 0118 3A6A     	 ldr r2,[r7,#32]
 5477 011a 3B69     	 ldr r3,[r7,#16]
 5478 011c 9A42     	 cmp r2,r3
 5479 011e 02D2     	 bcs .L359
1346:../Libraries/XMCLib/src/xmc4_scu.c ****     {
1347:../Libraries/XMCLib/src/xmc4_scu.c ****       XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv_temp);
 5480              	 .loc 3 1347 0
 5481 0120 3869     	 ldr r0,[r7,#16]
 5482 0122 FFF7FEFF 	 bl XMC_SCU_CLOCK_StepSystemPllFrequency
 5483              	.L359:
1348:../Libraries/XMCLib/src/xmc4_scu.c ****     }
1349:../Libraries/XMCLib/src/xmc4_scu.c **** 
1350:../Libraries/XMCLib/src/xmc4_scu.c ****     kdiv_temp = (uint32_t)((uint32_t)vco_frequency / 90000000UL);
 5484              	 .loc 3 1350 0
 5485 0126 D7ED057A 	 flds s15,[r7,#20]
 5486 012a FCEEE77A 	 ftouizs s15,s15
 5487 012e 17EE903A 	 fmrs r3,s15
 5488 0132 DB09     	 lsrs r3,r3,#7
 5489 0134 194A     	 ldr r2,.L363+20
 5490 0136 A2FB0323 	 umull r2,r3,r2,r3
 5491 013a DB0A     	 lsrs r3,r3,#11
 5492 013c 3B61     	 str r3,[r7,#16]
1351:../Libraries/XMCLib/src/xmc4_scu.c ****     if (kdiv < kdiv_temp)
 5493              	 .loc 3 1351 0
 5494 013e 3A6A     	 ldr r2,[r7,#32]
 5495 0140 3B69     	 ldr r3,[r7,#16]
 5496 0142 9A42     	 cmp r2,r3
 5497 0144 02D2     	 bcs .L360
1352:../Libraries/XMCLib/src/xmc4_scu.c ****     {
1353:../Libraries/XMCLib/src/xmc4_scu.c ****       XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv_temp);
 5498              	 .loc 3 1353 0
 5499 0146 3869     	 ldr r0,[r7,#16]
 5500 0148 FFF7FEFF 	 bl XMC_SCU_CLOCK_StepSystemPllFrequency
 5501              	.L360:
1354:../Libraries/XMCLib/src/xmc4_scu.c ****     }
1355:../Libraries/XMCLib/src/xmc4_scu.c **** 
1356:../Libraries/XMCLib/src/xmc4_scu.c ****     XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv);
 5502              	 .loc 3 1356 0
 5503 014c 386A     	 ldr r0,[r7,#32]
 5504 014e FFF7FEFF 	 bl XMC_SCU_CLOCK_StepSystemPllFrequency
 5505 0152 15E0     	 b .L353
 5506              	.L354:
1357:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1358:../Libraries/XMCLib/src/xmc4_scu.c ****   else
1359:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1360:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 5507              	 .loc 3 1360 0
 5508 0154 0E49     	 ldr r1,.L363+8
 5509 0156 0E4B     	 ldr r3,.L363+8
 5510 0158 9B68     	 ldr r3,[r3,#8]
 5511 015a 23F07F02 	 bic r2,r3,#127
1361:../Libraries/XMCLib/src/xmc4_scu.c ****                        ((kdiv -1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));
 5512              	 .loc 3 1361 0
 5513 015e 3B6A     	 ldr r3,[r7,#32]
 5514 0160 013B     	 subs r3,r3,#1
1360:../Libraries/XMCLib/src/xmc4_scu.c ****                        ((kdiv -1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));
 5515              	 .loc 3 1360 0
 5516 0162 1343     	 orrs r3,r3,r2
 5517 0164 8B60     	 str r3,[r1,#8]
1362:../Libraries/XMCLib/src/xmc4_scu.c **** 
1363:../Libraries/XMCLib/src/xmc4_scu.c ****     /* Switch to prescaler mode */
1364:../Libraries/XMCLib/src/xmc4_scu.c ****     SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 5518              	 .loc 3 1364 0
 5519 0166 0A4A     	 ldr r2,.L363+8
 5520 0168 094B     	 ldr r3,.L363+8
 5521 016a 5B68     	 ldr r3,[r3,#4]
 5522 016c 43F00103 	 orr r3,r3,#1
 5523 0170 5360     	 str r3,[r2,#4]
1365:../Libraries/XMCLib/src/xmc4_scu.c **** 
1366:../Libraries/XMCLib/src/xmc4_scu.c ****     while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
 5524              	 .loc 3 1366 0
 5525 0172 00BF     	 nop
 5526              	.L362:
 5527              	 .loc 3 1366 0 is_stmt 0 discriminator 1
 5528 0174 064B     	 ldr r3,.L363+8
 5529 0176 1B68     	 ldr r3,[r3]
 5530 0178 03F00103 	 and r3,r3,#1
 5531 017c 002B     	 cmp r3,#0
 5532 017e F9D0     	 beq .L362
 5533              	.L353:
1367:../Libraries/XMCLib/src/xmc4_scu.c ****     {
1368:../Libraries/XMCLib/src/xmc4_scu.c ****       /* wait for prescaler mode */
1369:../Libraries/XMCLib/src/xmc4_scu.c ****     }
1370:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1371:../Libraries/XMCLib/src/xmc4_scu.c **** }
 5534              	 .loc 3 1371 0 is_stmt 1
 5535 0180 1837     	 adds r7,r7,#24
 5536              	.LCFI476:
 5537              	 .cfi_def_cfa_offset 8
 5538 0182 BD46     	 mov sp,r7
 5539              	.LCFI477:
 5540              	 .cfi_def_cfa_register 13
 5541              	 
 5542 0184 80BD     	 pop {r7,pc}
 5543              	.L364:
 5544 0186 00BF     	 .align 2
 5545              	.L363:
 5546 0188 001BB74B 	 .word 1270291200
 5547 018c 819F5E16 	 .word 375299969
 5548 0190 10470050 	 .word 1342195472
 5549 0194 FF8080F0 	 .word -260013825
 5550 0198 C7541E01 	 .word 18764999
 5551 019c 2FE3BE00 	 .word 12509999
 5552              	 .cfi_endproc
 5553              	.LFE241:
 5555              	 .section .text.XMC_SCU_CLOCK_StopSystemPll,"ax",%progbits
 5556              	 .align 2
 5557              	 .global XMC_SCU_CLOCK_StopSystemPll
 5558              	 .thumb
 5559              	 .thumb_func
 5561              	XMC_SCU_CLOCK_StopSystemPll:
 5562              	.LFB242:
1372:../Libraries/XMCLib/src/xmc4_scu.c **** 
1373:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to stop main PLL operation */
1374:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_StopSystemPll(void)
1375:../Libraries/XMCLib/src/xmc4_scu.c **** {
 5563              	 .loc 3 1375 0
 5564              	 .cfi_startproc
 5565              	 
 5566              	 
 5567              	 
 5568 0000 80B4     	 push {r7}
 5569              	.LCFI478:
 5570              	 .cfi_def_cfa_offset 4
 5571              	 .cfi_offset 7,-4
 5572 0002 00AF     	 add r7,sp,#0
 5573              	.LCFI479:
 5574              	 .cfi_def_cfa_register 7
1376:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_PLLPWD_Msk;
 5575              	 .loc 3 1376 0
 5576 0004 044A     	 ldr r2,.L366
 5577 0006 044B     	 ldr r3,.L366
 5578 0008 5B68     	 ldr r3,[r3,#4]
 5579 000a 43F48033 	 orr r3,r3,#65536
 5580 000e 5360     	 str r3,[r2,#4]
1377:../Libraries/XMCLib/src/xmc4_scu.c **** }
 5581              	 .loc 3 1377 0
 5582 0010 BD46     	 mov sp,r7
 5583              	.LCFI480:
 5584              	 .cfi_def_cfa_register 13
 5585              	 
 5586 0012 5DF8047B 	 ldr r7,[sp],#4
 5587              	.LCFI481:
 5588              	 .cfi_restore 7
 5589              	 .cfi_def_cfa_offset 0
 5590 0016 7047     	 bx lr
 5591              	.L367:
 5592              	 .align 2
 5593              	.L366:
 5594 0018 10470050 	 .word 1342195472
 5595              	 .cfi_endproc
 5596              	.LFE242:
 5598              	 .section .text.XMC_SCU_CLOCK_StepSystemPllFrequency,"ax",%progbits
 5599              	 .align 2
 5600              	 .global XMC_SCU_CLOCK_StepSystemPllFrequency
 5601              	 .thumb
 5602              	 .thumb_func
 5604              	XMC_SCU_CLOCK_StepSystemPllFrequency:
 5605              	.LFB243:
1378:../Libraries/XMCLib/src/xmc4_scu.c **** 
1379:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to step up/down the main PLL frequency */
1380:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
1381:../Libraries/XMCLib/src/xmc4_scu.c **** {
 5606              	 .loc 3 1381 0
 5607              	 .cfi_startproc
 5608              	 
 5609              	 
 5610 0000 80B5     	 push {r7,lr}
 5611              	.LCFI482:
 5612              	 .cfi_def_cfa_offset 8
 5613              	 .cfi_offset 7,-8
 5614              	 .cfi_offset 14,-4
 5615 0002 82B0     	 sub sp,sp,#8
 5616              	.LCFI483:
 5617              	 .cfi_def_cfa_offset 16
 5618 0004 00AF     	 add r7,sp,#0
 5619              	.LCFI484:
 5620              	 .cfi_def_cfa_register 7
 5621 0006 7860     	 str r0,[r7,#4]
1382:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 5622              	 .loc 3 1382 0
 5623 0008 0749     	 ldr r1,.L369
 5624 000a 074B     	 ldr r3,.L369
 5625 000c 9B68     	 ldr r3,[r3,#8]
 5626 000e 23F4FE02 	 bic r2,r3,#8323072
1383:../Libraries/XMCLib/src/xmc4_scu.c ****                      ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 5627              	 .loc 3 1383 0
 5628 0012 7B68     	 ldr r3,[r7,#4]
 5629 0014 013B     	 subs r3,r3,#1
 5630 0016 1B04     	 lsls r3,r3,#16
1382:../Libraries/XMCLib/src/xmc4_scu.c ****   SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 5631              	 .loc 3 1382 0
 5632 0018 1343     	 orrs r3,r3,r2
 5633 001a 8B60     	 str r3,[r1,#8]
1384:../Libraries/XMCLib/src/xmc4_scu.c **** 
1385:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_lDelay(50U);
 5634              	 .loc 3 1385 0
 5635 001c 3220     	 movs r0,#50
 5636 001e FFF7FEFF 	 bl XMC_SCU_lDelay
1386:../Libraries/XMCLib/src/xmc4_scu.c **** }
 5637              	 .loc 3 1386 0
 5638 0022 0837     	 adds r7,r7,#8
 5639              	.LCFI485:
 5640              	 .cfi_def_cfa_offset 8
 5641 0024 BD46     	 mov sp,r7
 5642              	.LCFI486:
 5643              	 .cfi_def_cfa_register 13
 5644              	 
 5645 0026 80BD     	 pop {r7,pc}
 5646              	.L370:
 5647              	 .align 2
 5648              	.L369:
 5649 0028 10470050 	 .word 1342195472
 5650              	 .cfi_endproc
 5651              	.LFE243:
 5653              	 .section .text.XMC_SCU_CLOCK_IsSystemPllLocked,"ax",%progbits
 5654              	 .align 2
 5655              	 .global XMC_SCU_CLOCK_IsSystemPllLocked
 5656              	 .thumb
 5657              	 .thumb_func
 5659              	XMC_SCU_CLOCK_IsSystemPllLocked:
 5660              	.LFB244:
1387:../Libraries/XMCLib/src/xmc4_scu.c **** 
1388:../Libraries/XMCLib/src/xmc4_scu.c **** /* API to check main PLL is locked or not */
1389:../Libraries/XMCLib/src/xmc4_scu.c **** bool XMC_SCU_CLOCK_IsSystemPllLocked(void)
1390:../Libraries/XMCLib/src/xmc4_scu.c **** {
 5661              	 .loc 3 1390 0
 5662              	 .cfi_startproc
 5663              	 
 5664              	 
 5665              	 
 5666 0000 80B4     	 push {r7}
 5667              	.LCFI487:
 5668              	 .cfi_def_cfa_offset 4
 5669              	 .cfi_offset 7,-4
 5670 0002 00AF     	 add r7,sp,#0
 5671              	.LCFI488:
 5672              	 .cfi_def_cfa_register 7
1391:../Libraries/XMCLib/src/xmc4_scu.c ****   return (bool)((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk) != 0UL);
 5673              	 .loc 3 1391 0
 5674 0004 064B     	 ldr r3,.L373
 5675 0006 1B68     	 ldr r3,[r3]
 5676 0008 03F00403 	 and r3,r3,#4
 5677 000c 002B     	 cmp r3,#0
 5678 000e 14BF     	 ite ne
 5679 0010 0123     	 movne r3,#1
 5680 0012 0023     	 moveq r3,#0
 5681 0014 DBB2     	 uxtb r3,r3
1392:../Libraries/XMCLib/src/xmc4_scu.c **** }
 5682              	 .loc 3 1392 0
 5683 0016 1846     	 mov r0,r3
 5684 0018 BD46     	 mov sp,r7
 5685              	.LCFI489:
 5686              	 .cfi_def_cfa_register 13
 5687              	 
 5688 001a 5DF8047B 	 ldr r7,[sp],#4
 5689              	.LCFI490:
 5690              	 .cfi_restore 7
 5691              	 .cfi_def_cfa_offset 0
 5692 001e 7047     	 bx lr
 5693              	.L374:
 5694              	 .align 2
 5695              	.L373:
 5696 0020 10470050 	 .word 1342195472
 5697              	 .cfi_endproc
 5698              	.LFE244:
 5700              	 .section .text.XMC_SCU_INTERRUPT_SetEventHandler,"ax",%progbits
 5701              	 .align 2
 5702              	 .global XMC_SCU_INTERRUPT_SetEventHandler
 5703              	 .thumb
 5704              	 .thumb_func
 5706              	XMC_SCU_INTERRUPT_SetEventHandler:
 5707              	.LFB245:
1393:../Libraries/XMCLib/src/xmc4_scu.c **** 
1394:../Libraries/XMCLib/src/xmc4_scu.c **** /*
1395:../Libraries/XMCLib/src/xmc4_scu.c ****  * API to assign the event handler function to be executed on occurrence of the selected event.
1396:../Libraries/XMCLib/src/xmc4_scu.c ****  */
1397:../Libraries/XMCLib/src/xmc4_scu.c **** XMC_SCU_STATUS_t XMC_SCU_INTERRUPT_SetEventHandler(const XMC_SCU_INTERRUPT_EVENT_t event,
1398:../Libraries/XMCLib/src/xmc4_scu.c ****                                                    const XMC_SCU_INTERRUPT_EVENT_HANDLER_t handler)
1399:../Libraries/XMCLib/src/xmc4_scu.c **** {
 5708              	 .loc 3 1399 0
 5709              	 .cfi_startproc
 5710              	 
 5711              	 
 5712              	 
 5713 0000 80B4     	 push {r7}
 5714              	.LCFI491:
 5715              	 .cfi_def_cfa_offset 4
 5716              	 .cfi_offset 7,-4
 5717 0002 85B0     	 sub sp,sp,#20
 5718              	.LCFI492:
 5719              	 .cfi_def_cfa_offset 24
 5720 0004 00AF     	 add r7,sp,#0
 5721              	.LCFI493:
 5722              	 .cfi_def_cfa_register 7
 5723 0006 7860     	 str r0,[r7,#4]
 5724 0008 3960     	 str r1,[r7]
1400:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t index;
1401:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_STATUS_t status;
1402:../Libraries/XMCLib/src/xmc4_scu.c ****   
1403:../Libraries/XMCLib/src/xmc4_scu.c ****   index = 0U;
 5725              	 .loc 3 1403 0
 5726 000a 0023     	 movs r3,#0
 5727 000c FB60     	 str r3,[r7,#12]
1404:../Libraries/XMCLib/src/xmc4_scu.c ****   while (((event & ((XMC_SCU_INTERRUPT_EVENT_t)1 << index)) == 0U) && (index < XMC_SCU_INTERRUPT_EV
 5728              	 .loc 3 1404 0
 5729 000e 02E0     	 b .L376
 5730              	.L378:
1405:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1406:../Libraries/XMCLib/src/xmc4_scu.c ****     index++;
 5731              	 .loc 3 1406 0
 5732 0010 FB68     	 ldr r3,[r7,#12]
 5733 0012 0133     	 adds r3,r3,#1
 5734 0014 FB60     	 str r3,[r7,#12]
 5735              	.L376:
1404:../Libraries/XMCLib/src/xmc4_scu.c ****   while (((event & ((XMC_SCU_INTERRUPT_EVENT_t)1 << index)) == 0U) && (index < XMC_SCU_INTERRUPT_EV
 5736              	 .loc 3 1404 0
 5737 0016 FB68     	 ldr r3,[r7,#12]
 5738 0018 7A68     	 ldr r2,[r7,#4]
 5739 001a 22FA03F3 	 lsr r3,r2,r3
 5740 001e 03F00103 	 and r3,r3,#1
 5741 0022 002B     	 cmp r3,#0
 5742 0024 02D1     	 bne .L377
1404:../Libraries/XMCLib/src/xmc4_scu.c ****   while (((event & ((XMC_SCU_INTERRUPT_EVENT_t)1 << index)) == 0U) && (index < XMC_SCU_INTERRUPT_EV
 5743              	 .loc 3 1404 0 is_stmt 0 discriminator 1
 5744 0026 FB68     	 ldr r3,[r7,#12]
 5745 0028 1F2B     	 cmp r3,#31
 5746 002a F1D9     	 bls .L378
 5747              	.L377:
1407:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1408:../Libraries/XMCLib/src/xmc4_scu.c ****   
1409:../Libraries/XMCLib/src/xmc4_scu.c ****   if (index == XMC_SCU_INTERRUPT_EVENT_MAX)
 5748              	 .loc 3 1409 0 is_stmt 1
 5749 002c FB68     	 ldr r3,[r7,#12]
 5750 002e 202B     	 cmp r3,#32
 5751 0030 02D1     	 bne .L379
1410:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1411:../Libraries/XMCLib/src/xmc4_scu.c ****     status = XMC_SCU_STATUS_ERROR;
 5752              	 .loc 3 1411 0
 5753 0032 0123     	 movs r3,#1
 5754 0034 FB72     	 strb r3,[r7,#11]
 5755 0036 06E0     	 b .L380
 5756              	.L379:
1412:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1413:../Libraries/XMCLib/src/xmc4_scu.c ****   else
1414:../Libraries/XMCLib/src/xmc4_scu.c ****   {
1415:../Libraries/XMCLib/src/xmc4_scu.c ****     event_handler_list[index] = handler;
 5757              	 .loc 3 1415 0
 5758 0038 0649     	 ldr r1,.L382
 5759 003a FB68     	 ldr r3,[r7,#12]
 5760 003c 3A68     	 ldr r2,[r7]
 5761 003e 41F82320 	 str r2,[r1,r3,lsl#2]
1416:../Libraries/XMCLib/src/xmc4_scu.c ****     status = XMC_SCU_STATUS_OK;      
 5762              	 .loc 3 1416 0
 5763 0042 0023     	 movs r3,#0
 5764 0044 FB72     	 strb r3,[r7,#11]
 5765              	.L380:
1417:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1418:../Libraries/XMCLib/src/xmc4_scu.c ****   
1419:../Libraries/XMCLib/src/xmc4_scu.c ****   return (status);
 5766              	 .loc 3 1419 0
 5767 0046 FB7A     	 ldrb r3,[r7,#11]
1420:../Libraries/XMCLib/src/xmc4_scu.c **** }
 5768              	 .loc 3 1420 0
 5769 0048 1846     	 mov r0,r3
 5770 004a 1437     	 adds r7,r7,#20
 5771              	.LCFI494:
 5772              	 .cfi_def_cfa_offset 4
 5773 004c BD46     	 mov sp,r7
 5774              	.LCFI495:
 5775              	 .cfi_def_cfa_register 13
 5776              	 
 5777 004e 5DF8047B 	 ldr r7,[sp],#4
 5778              	.LCFI496:
 5779              	 .cfi_restore 7
 5780              	 .cfi_def_cfa_offset 0
 5781 0052 7047     	 bx lr
 5782              	.L383:
 5783              	 .align 2
 5784              	.L382:
 5785 0054 00000000 	 .word event_handler_list
 5786              	 .cfi_endproc
 5787              	.LFE245:
 5789              	 .section .text.XMC_SCU_IRQHandler,"ax",%progbits
 5790              	 .align 2
 5791              	 .global XMC_SCU_IRQHandler
 5792              	 .thumb
 5793              	 .thumb_func
 5795              	XMC_SCU_IRQHandler:
 5796              	.LFB246:
1421:../Libraries/XMCLib/src/xmc4_scu.c **** 
1422:../Libraries/XMCLib/src/xmc4_scu.c **** /*
1423:../Libraries/XMCLib/src/xmc4_scu.c ****  * API to execute callback functions for multiple events.
1424:../Libraries/XMCLib/src/xmc4_scu.c ****  */
1425:../Libraries/XMCLib/src/xmc4_scu.c **** void XMC_SCU_IRQHandler(uint32_t sr_num)
1426:../Libraries/XMCLib/src/xmc4_scu.c **** {
 5797              	 .loc 3 1426 0
 5798              	 .cfi_startproc
 5799              	 
 5800              	 
 5801 0000 80B5     	 push {r7,lr}
 5802              	.LCFI497:
 5803              	 .cfi_def_cfa_offset 8
 5804              	 .cfi_offset 7,-8
 5805              	 .cfi_offset 14,-4
 5806 0002 86B0     	 sub sp,sp,#24
 5807              	.LCFI498:
 5808              	 .cfi_def_cfa_offset 32
 5809 0004 00AF     	 add r7,sp,#0
 5810              	.LCFI499:
 5811              	 .cfi_def_cfa_register 7
 5812 0006 7860     	 str r0,[r7,#4]
1427:../Libraries/XMCLib/src/xmc4_scu.c ****   uint32_t index;
1428:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_INTERRUPT_EVENT_t event;
1429:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_SCU_INTERRUPT_EVENT_HANDLER_t event_handler;
1430:../Libraries/XMCLib/src/xmc4_scu.c ****   
1431:../Libraries/XMCLib/src/xmc4_scu.c ****   XMC_UNUSED_ARG(sr_num);
1432:../Libraries/XMCLib/src/xmc4_scu.c ****   
1433:../Libraries/XMCLib/src/xmc4_scu.c ****   index = 0U;
 5813              	 .loc 3 1433 0
 5814 0008 0023     	 movs r3,#0
 5815 000a 7B61     	 str r3,[r7,#20]
1434:../Libraries/XMCLib/src/xmc4_scu.c ****   event = XMC_SCU_INTERUPT_GetEventStatus();
 5816              	 .loc 3 1434 0
 5817 000c FFF7FEFF 	 bl XMC_SCU_INTERUPT_GetEventStatus
 5818 0010 3861     	 str r0,[r7,#16]
1435:../Libraries/XMCLib/src/xmc4_scu.c ****   while (index < XMC_SCU_INTERRUPT_EVENT_MAX)
 5819              	 .loc 3 1435 0
 5820 0012 1CE0     	 b .L385
 5821              	.L389:
1436:../Libraries/XMCLib/src/xmc4_scu.c ****   {    
1437:../Libraries/XMCLib/src/xmc4_scu.c ****     if ((event & ((XMC_SCU_INTERRUPT_EVENT_t)1 << index)) != 0U)
 5822              	 .loc 3 1437 0
 5823 0014 7B69     	 ldr r3,[r7,#20]
 5824 0016 3A69     	 ldr r2,[r7,#16]
 5825 0018 22FA03F3 	 lsr r3,r2,r3
 5826 001c 03F00103 	 and r3,r3,#1
 5827 0020 002B     	 cmp r3,#0
 5828 0022 11D0     	 beq .L386
1438:../Libraries/XMCLib/src/xmc4_scu.c ****     {
1439:../Libraries/XMCLib/src/xmc4_scu.c ****       event_handler = event_handler_list[index];
 5829              	 .loc 3 1439 0
 5830 0024 0D4A     	 ldr r2,.L390
 5831 0026 7B69     	 ldr r3,[r7,#20]
 5832 0028 52F82330 	 ldr r3,[r2,r3,lsl#2]
 5833 002c FB60     	 str r3,[r7,#12]
1440:../Libraries/XMCLib/src/xmc4_scu.c ****       if (event_handler != NULL)
 5834              	 .loc 3 1440 0
 5835 002e FB68     	 ldr r3,[r7,#12]
 5836 0030 002B     	 cmp r3,#0
 5837 0032 01D0     	 beq .L387
1441:../Libraries/XMCLib/src/xmc4_scu.c ****       {
1442:../Libraries/XMCLib/src/xmc4_scu.c ****           (event_handler)();
 5838              	 .loc 3 1442 0
 5839 0034 FB68     	 ldr r3,[r7,#12]
 5840 0036 9847     	 blx r3
 5841              	.L387:
1443:../Libraries/XMCLib/src/xmc4_scu.c ****       }
1444:../Libraries/XMCLib/src/xmc4_scu.c ****       
1445:../Libraries/XMCLib/src/xmc4_scu.c ****       XMC_SCU_INTERRUPT_ClearEventStatus((uint32_t)(1UL << index));
 5842              	 .loc 3 1445 0
 5843 0038 7B69     	 ldr r3,[r7,#20]
 5844 003a 0122     	 movs r2,#1
 5845 003c 02FA03F3 	 lsl r3,r2,r3
 5846 0040 1846     	 mov r0,r3
 5847 0042 FFF7FEFF 	 bl XMC_SCU_INTERRUPT_ClearEventStatus
1446:../Libraries/XMCLib/src/xmc4_scu.c ****       
1447:../Libraries/XMCLib/src/xmc4_scu.c ****       break;
 5848              	 .loc 3 1447 0
 5849 0046 05E0     	 b .L384
 5850              	.L386:
1448:../Libraries/XMCLib/src/xmc4_scu.c ****     }   
1449:../Libraries/XMCLib/src/xmc4_scu.c ****     index++;    
 5851              	 .loc 3 1449 0
 5852 0048 7B69     	 ldr r3,[r7,#20]
 5853 004a 0133     	 adds r3,r3,#1
 5854 004c 7B61     	 str r3,[r7,#20]
 5855              	.L385:
1435:../Libraries/XMCLib/src/xmc4_scu.c ****   {    
 5856              	 .loc 3 1435 0
 5857 004e 7B69     	 ldr r3,[r7,#20]
 5858 0050 1F2B     	 cmp r3,#31
 5859 0052 DFD9     	 bls .L389
 5860              	.L384:
1450:../Libraries/XMCLib/src/xmc4_scu.c ****   }
1451:../Libraries/XMCLib/src/xmc4_scu.c **** }
 5861              	 .loc 3 1451 0
 5862 0054 1837     	 adds r7,r7,#24
 5863              	.LCFI500:
 5864              	 .cfi_def_cfa_offset 8
 5865 0056 BD46     	 mov sp,r7
 5866              	.LCFI501:
 5867              	 .cfi_def_cfa_register 13
 5868              	 
 5869 0058 80BD     	 pop {r7,pc}
 5870              	.L391:
 5871 005a 00BF     	 .align 2
 5872              	.L390:
 5873 005c 00000000 	 .word event_handler_list
 5874              	 .cfi_endproc
 5875              	.LFE246:
 5877              	 .text
 5878              	.Letext0:
 5879              	 .file 5 "e:\\davev4\\dave-4.1.4\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 5880              	 .file 6 "e:\\davev4\\dave-4.1.4\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 5881              	 .file 7 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode/Libraries/CMSIS/Infineon/XMC4700_series/Include/XMC4700.h"
 5882              	 .file 8 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode/Libraries/CMSIS/Include/core_cm4.h"
 5883              	 .file 9 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode/Libraries/CMSIS/Infineon/XMC4700_series/Include/system_XMC4700.h"
DEFINED SYMBOLS
                            *ABS*:00000000 xmc4_scu.c
    {standard input}:20     .text.XMC_SCU_CLOCK_GetUsbClockSource:00000000 $t
    {standard input}:24     .text.XMC_SCU_CLOCK_GetUsbClockSource:00000000 XMC_SCU_CLOCK_GetUsbClockSource
    {standard input}:57     .text.XMC_SCU_CLOCK_GetUsbClockSource:00000018 $d
    {standard input}:62     .text.XMC_SCU_CLOCK_GetWdtClockSource:00000000 $t
    {standard input}:66     .text.XMC_SCU_CLOCK_GetWdtClockSource:00000000 XMC_SCU_CLOCK_GetWdtClockSource
    {standard input}:98     .text.XMC_SCU_CLOCK_GetWdtClockSource:00000018 $d
    {standard input}:103    .text.XMC_SCU_CLOCK_GetExternalOutputClockSource:00000000 $t
    {standard input}:107    .text.XMC_SCU_CLOCK_GetExternalOutputClockSource:00000000 XMC_SCU_CLOCK_GetExternalOutputClockSource
    {standard input}:141    .text.XMC_SCU_CLOCK_GetExternalOutputClockSource:0000001c $d
    {standard input}:146    .text.XMC_SCU_CLOCK_GetSystemClockFrequency:00000000 $t
    {standard input}:150    .text.XMC_SCU_CLOCK_GetSystemClockFrequency:00000000 XMC_SCU_CLOCK_GetSystemClockFrequency
    {standard input}:185    .text.XMC_SCU_CLOCK_GetSystemClockFrequency:00000020 $d
    {standard input}:191    .text.XMC_SCU_CLOCK_GetCpuClockFrequency:00000000 $t
    {standard input}:195    .text.XMC_SCU_CLOCK_GetCpuClockFrequency:00000000 XMC_SCU_CLOCK_GetCpuClockFrequency
    {standard input}:227    .text.XMC_SCU_CLOCK_GetCpuClockFrequency:00000014 $d
                            *COM*:00000080 event_handler_list
    {standard input}:233    .text.XMC_SCU_lDelay:00000000 $t
    {standard input}:237    .text.XMC_SCU_lDelay:00000000 XMC_SCU_lDelay
    {standard input}:304    .text.XMC_SCU_lDelay:0000003c $d
    {standard input}:310    .text.XMC_SCU_INTERRUPT_EnableEvent:00000000 $t
    {standard input}:315    .text.XMC_SCU_INTERRUPT_EnableEvent:00000000 XMC_SCU_INTERRUPT_EnableEvent
    {standard input}:356    .text.XMC_SCU_INTERRUPT_EnableEvent:00000020 $d
    {standard input}:361    .text.XMC_SCU_INTERRUPT_DisableEvent:00000000 $t
    {standard input}:366    .text.XMC_SCU_INTERRUPT_DisableEvent:00000000 XMC_SCU_INTERRUPT_DisableEvent
    {standard input}:408    .text.XMC_SCU_INTERRUPT_DisableEvent:00000020 $d
    {standard input}:413    .text.XMC_SCU_INTERRUPT_TriggerEvent:00000000 $t
    {standard input}:418    .text.XMC_SCU_INTERRUPT_TriggerEvent:00000000 XMC_SCU_INTERRUPT_TriggerEvent
    {standard input}:459    .text.XMC_SCU_INTERRUPT_TriggerEvent:00000020 $d
    {standard input}:464    .text.XMC_SCU_INTERUPT_GetEventStatus:00000000 $t
    {standard input}:469    .text.XMC_SCU_INTERUPT_GetEventStatus:00000000 XMC_SCU_INTERUPT_GetEventStatus
    {standard input}:500    .text.XMC_SCU_INTERUPT_GetEventStatus:00000014 $d
    {standard input}:505    .text.XMC_SCU_INTERRUPT_ClearEventStatus:00000000 $t
    {standard input}:510    .text.XMC_SCU_INTERRUPT_ClearEventStatus:00000000 XMC_SCU_INTERRUPT_ClearEventStatus
    {standard input}:551    .text.XMC_SCU_INTERRUPT_ClearEventStatus:00000020 $d
    {standard input}:556    .text.XMC_SCU_GetBootMode:00000000 $t
    {standard input}:561    .text.XMC_SCU_GetBootMode:00000000 XMC_SCU_GetBootMode
    {standard input}:593    .text.XMC_SCU_GetBootMode:00000018 $d
    {standard input}:598    .text.XMC_SCU_SetBootMode:00000000 $t
    {standard input}:603    .text.XMC_SCU_SetBootMode:00000000 XMC_SCU_SetBootMode
    {standard input}:642    .text.XMC_SCU_SetBootMode:0000001c $d
    {standard input}:647    .text.XMC_SCU_ReadGPR:00000000 $t
    {standard input}:652    .text.XMC_SCU_ReadGPR:00000000 XMC_SCU_ReadGPR
    {standard input}:694    .text.XMC_SCU_ReadGPR:00000020 $d
    {standard input}:699    .text.XMC_SCU_WriteGPR:00000000 $t
    {standard input}:704    .text.XMC_SCU_WriteGPR:00000000 XMC_SCU_WriteGPR
    {standard input}:747    .text.XMC_SCU_WriteGPR:00000024 $d
    {standard input}:752    .text.XMC_SCU_EnableOutOfRangeComparator:00000000 $t
    {standard input}:757    .text.XMC_SCU_EnableOutOfRangeComparator:00000000 XMC_SCU_EnableOutOfRangeComparator
    {standard input}:805    .text.XMC_SCU_EnableOutOfRangeComparator:00000034 $d
    {standard input}:810    .text.XMC_SCU_DisableOutOfRangeComparator:00000000 $t
    {standard input}:815    .text.XMC_SCU_DisableOutOfRangeComparator:00000000 XMC_SCU_DisableOutOfRangeComparator
    {standard input}:864    .text.XMC_SCU_DisableOutOfRangeComparator:00000034 $d
    {standard input}:869    .text.XMC_SCU_CalibrateTemperatureSensor:00000000 $t
    {standard input}:874    .text.XMC_SCU_CalibrateTemperatureSensor:00000000 XMC_SCU_CalibrateTemperatureSensor
    {standard input}:922    .text.XMC_SCU_CalibrateTemperatureSensor:00000028 $d
    {standard input}:927    .text.XMC_SCU_EnableTemperatureSensor:00000000 $t
    {standard input}:932    .text.XMC_SCU_EnableTemperatureSensor:00000000 XMC_SCU_EnableTemperatureSensor
    {standard input}:965    .text.XMC_SCU_EnableTemperatureSensor:0000001c $d
    {standard input}:970    .text.XMC_SCU_DisableTemperatureSensor:00000000 $t
    {standard input}:975    .text.XMC_SCU_DisableTemperatureSensor:00000000 XMC_SCU_DisableTemperatureSensor
    {standard input}:1008   .text.XMC_SCU_DisableTemperatureSensor:0000001c $d
    {standard input}:1013   .text.XMC_SCU_IsTemperatureSensorEnabled:00000000 $t
    {standard input}:1018   .text.XMC_SCU_IsTemperatureSensorEnabled:00000000 XMC_SCU_IsTemperatureSensorEnabled
    {standard input}:1055   .text.XMC_SCU_IsTemperatureSensorEnabled:00000024 $d
    {standard input}:1060   .text.XMC_SCU_IsTemperatureSensorReady:00000000 $t
    {standard input}:1065   .text.XMC_SCU_IsTemperatureSensorReady:00000000 XMC_SCU_IsTemperatureSensorReady
    {standard input}:1102   .text.XMC_SCU_IsTemperatureSensorReady:00000024 $d
    {standard input}:1107   .text.XMC_SCU_StartTemperatureMeasurement:00000000 $t
    {standard input}:1112   .text.XMC_SCU_StartTemperatureMeasurement:00000000 XMC_SCU_StartTemperatureMeasurement
    {standard input}:1243   .text.XMC_SCU_IsTemperatureSensorBusy:00000000 XMC_SCU_IsTemperatureSensorBusy
    {standard input}:1173   .text.XMC_SCU_StartTemperatureMeasurement:00000048 $d
    {standard input}:1178   .text.XMC_SCU_GetTemperatureMeasurement:00000000 $t
    {standard input}:1183   .text.XMC_SCU_GetTemperatureMeasurement:00000000 XMC_SCU_GetTemperatureMeasurement
    {standard input}:1233   .text.XMC_SCU_GetTemperatureMeasurement:00000034 $d
    {standard input}:1238   .text.XMC_SCU_IsTemperatureSensorBusy:00000000 $t
    {standard input}:1280   .text.XMC_SCU_IsTemperatureSensorBusy:00000024 $d
    {standard input}:1285   .text.XMC_SCU_WriteToRetentionMemory:00000000 $t
    {standard input}:1290   .text.XMC_SCU_WriteToRetentionMemory:00000000 XMC_SCU_WriteToRetentionMemory
    {standard input}:1351   .text.XMC_SCU_WriteToRetentionMemory:00000048 $d
    {standard input}:1356   .text.XMC_SCU_ReadFromRetentionMemory:00000000 $t
    {standard input}:1361   .text.XMC_SCU_ReadFromRetentionMemory:00000000 XMC_SCU_ReadFromRetentionMemory
    {standard input}:1421   .text.XMC_SCU_ReadFromRetentionMemory:00000044 $d
    {standard input}:1426   .text.XMC_SCU_CLOCK_Init:00000000 $t
    {standard input}:1431   .text.XMC_SCU_CLOCK_Init:00000000 XMC_SCU_CLOCK_Init
    {standard input}:3051   .text.XMC_SCU_CLOCK_SetSystemClockSource:00000000 XMC_SCU_CLOCK_SetSystemClockSource
    {standard input}:4697   .text.XMC_SCU_HIB_EnableHibernateDomain:00000000 XMC_SCU_HIB_EnableHibernateDomain
    {standard input}:4983   .text.XMC_SCU_CLOCK_EnableLowPowerOscillator:00000000 XMC_SCU_CLOCK_EnableLowPowerOscillator
    {standard input}:3393   .text.XMC_SCU_HIB_SetStandbyClockSource:00000000 XMC_SCU_HIB_SetStandbyClockSource
    {standard input}:4494   .text.XMC_SCU_CLOCK_SetBackupClockCalibrationMode:00000000 XMC_SCU_CLOCK_SetBackupClockCalibrationMode
    {standard input}:3458   .text.XMC_SCU_CLOCK_SetSystemClockDivider:00000000 XMC_SCU_CLOCK_SetSystemClockDivider
    {standard input}:3568   .text.XMC_SCU_CLOCK_SetCpuClockDivider:00000000 XMC_SCU_CLOCK_SetCpuClockDivider
    {standard input}:3513   .text.XMC_SCU_CLOCK_SetCcuClockDivider:00000000 XMC_SCU_CLOCK_SetCcuClockDivider
    {standard input}:3623   .text.XMC_SCU_CLOCK_SetPeripheralClockDivider:00000000 XMC_SCU_CLOCK_SetPeripheralClockDivider
    {standard input}:5121   .text.XMC_SCU_CLOCK_EnableHighPerformanceOscillator:00000000 XMC_SCU_CLOCK_EnableHighPerformanceOscillator
    {standard input}:5279   .text.XMC_SCU_CLOCK_DisableSystemPll:00000000 XMC_SCU_CLOCK_DisableSystemPll
    {standard input}:5235   .text.XMC_SCU_CLOCK_EnableSystemPll:00000000 XMC_SCU_CLOCK_EnableSystemPll
    {standard input}:5323   .text.XMC_SCU_CLOCK_StartSystemPll:00000000 XMC_SCU_CLOCK_StartSystemPll
    {standard input}:1563   .text.XMC_SCU_TRAP_Enable:00000000 $t
    {standard input}:1568   .text.XMC_SCU_TRAP_Enable:00000000 XMC_SCU_TRAP_Enable
    {standard input}:1610   .text.XMC_SCU_TRAP_Enable:00000020 $d
    {standard input}:1615   .text.XMC_SCU_TRAP_Disable:00000000 $t
    {standard input}:1620   .text.XMC_SCU_TRAP_Disable:00000000 XMC_SCU_TRAP_Disable
    {standard input}:1661   .text.XMC_SCU_TRAP_Disable:00000020 $d
    {standard input}:1666   .text.XMC_SCU_TRAP_GetStatus:00000000 $t
    {standard input}:1671   .text.XMC_SCU_TRAP_GetStatus:00000000 XMC_SCU_TRAP_GetStatus
    {standard input}:1702   .text.XMC_SCU_TRAP_GetStatus:00000014 $d
    {standard input}:1707   .text.XMC_SCU_TRAP_Trigger:00000000 $t
    {standard input}:1712   .text.XMC_SCU_TRAP_Trigger:00000000 XMC_SCU_TRAP_Trigger
    {standard input}:1753   .text.XMC_SCU_TRAP_Trigger:00000020 $d
    {standard input}:1758   .text.XMC_SCU_TRAP_ClearStatus:00000000 $t
    {standard input}:1763   .text.XMC_SCU_TRAP_ClearStatus:00000000 XMC_SCU_TRAP_ClearStatus
    {standard input}:1804   .text.XMC_SCU_TRAP_ClearStatus:00000020 $d
    {standard input}:1809   .text.XMC_SCU_PARITY_ClearStatus:00000000 $t
    {standard input}:1814   .text.XMC_SCU_PARITY_ClearStatus:00000000 XMC_SCU_PARITY_ClearStatus
    {standard input}:1855   .text.XMC_SCU_PARITY_ClearStatus:00000020 $d
    {standard input}:1860   .text.XMC_SCU_PARITY_GetStatus:00000000 $t
    {standard input}:1865   .text.XMC_SCU_PARITY_GetStatus:00000000 XMC_SCU_PARITY_GetStatus
    {standard input}:1896   .text.XMC_SCU_PARITY_GetStatus:00000014 $d
    {standard input}:1901   .text.XMC_SCU_PARITY_Enable:00000000 $t
    {standard input}:1906   .text.XMC_SCU_PARITY_Enable:00000000 XMC_SCU_PARITY_Enable
    {standard input}:1947   .text.XMC_SCU_PARITY_Enable:00000020 $d
    {standard input}:1952   .text.XMC_SCU_PARITY_Disable:00000000 $t
    {standard input}:1957   .text.XMC_SCU_PARITY_Disable:00000000 XMC_SCU_PARITY_Disable
    {standard input}:1999   .text.XMC_SCU_PARITY_Disable:00000020 $d
    {standard input}:2004   .text.XMC_SCU_PARITY_EnableTrapGeneration:00000000 $t
    {standard input}:2009   .text.XMC_SCU_PARITY_EnableTrapGeneration:00000000 XMC_SCU_PARITY_EnableTrapGeneration
    {standard input}:2050   .text.XMC_SCU_PARITY_EnableTrapGeneration:00000020 $d
    {standard input}:2055   .text.XMC_SCU_PARITY_DisableTrapGeneration:00000000 $t
    {standard input}:2060   .text.XMC_SCU_PARITY_DisableTrapGeneration:00000000 XMC_SCU_PARITY_DisableTrapGeneration
    {standard input}:2102   .text.XMC_SCU_PARITY_DisableTrapGeneration:00000020 $d
    {standard input}:2107   .text.XMC_SCU_INTERRUPT_EnableNmiRequest:00000000 $t
    {standard input}:2112   .text.XMC_SCU_INTERRUPT_EnableNmiRequest:00000000 XMC_SCU_INTERRUPT_EnableNmiRequest
    {standard input}:2153   .text.XMC_SCU_INTERRUPT_EnableNmiRequest:00000020 $d
    {standard input}:2158   .text.XMC_SCU_INTERRUPT_DisableNmiRequest:00000000 $t
    {standard input}:2163   .text.XMC_SCU_INTERRUPT_DisableNmiRequest:00000000 XMC_SCU_INTERRUPT_DisableNmiRequest
    {standard input}:2205   .text.XMC_SCU_INTERRUPT_DisableNmiRequest:00000020 $d
    {standard input}:2210   .text.XMC_SCU_RESET_AssertPeripheralReset:00000000 $t
    {standard input}:2215   .text.XMC_SCU_RESET_AssertPeripheralReset:00000000 XMC_SCU_RESET_AssertPeripheralReset
    {standard input}:2277   .text.XMC_SCU_RESET_AssertPeripheralReset:00000048 $d
    {standard input}:2282   .text.XMC_SCU_RESET_DeassertPeripheralReset:00000000 $t
    {standard input}:2287   .text.XMC_SCU_RESET_DeassertPeripheralReset:00000000 XMC_SCU_RESET_DeassertPeripheralReset
    {standard input}:2349   .text.XMC_SCU_RESET_DeassertPeripheralReset:00000048 $d
    {standard input}:2354   .text.XMC_SCU_RESET_IsPeripheralResetAsserted:00000000 $t
    {standard input}:2359   .text.XMC_SCU_RESET_IsPeripheralResetAsserted:00000000 XMC_SCU_RESET_IsPeripheralResetAsserted
    {standard input}:2419   .text.XMC_SCU_RESET_IsPeripheralResetAsserted:00000044 $d
    {standard input}:2424   .text.XMC_SCU_CLOCK_GetSystemPllClockFrequency:00000000 $t
    {standard input}:2429   .text.XMC_SCU_CLOCK_GetSystemPllClockFrequency:00000000 XMC_SCU_CLOCK_GetSystemPllClockFrequency
    {standard input}:2522   .text.XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency:00000000 XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency
    {standard input}:2512   .text.XMC_SCU_CLOCK_GetSystemPllClockFrequency:00000078 $d
    {standard input}:2517   .text.XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency:00000000 $t
    {standard input}:2569   .text.XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency:00000028 $d
    {standard input}:2575   .text.XMC_SCU_CLOCK_GetUsbPllClockFrequency:00000000 $t
    {standard input}:2580   .text.XMC_SCU_CLOCK_GetUsbPllClockFrequency:00000000 XMC_SCU_CLOCK_GetUsbPllClockFrequency
    {standard input}:2644   .text.XMC_SCU_CLOCK_GetUsbPllClockFrequency:00000050 $d
    {standard input}:2649   .text.XMC_SCU_CLOCK_GetCcuClockFrequency:00000000 $t
    {standard input}:2654   .text.XMC_SCU_CLOCK_GetCcuClockFrequency:00000000 XMC_SCU_CLOCK_GetCcuClockFrequency
    {standard input}:2696   .text.XMC_SCU_CLOCK_GetCcuClockFrequency:00000028 $d
    {standard input}:2701   .text.XMC_SCU_CLOCK_GetUsbClockFrequency:00000000 $t
    {standard input}:2706   .text.XMC_SCU_CLOCK_GetUsbClockFrequency:00000000 XMC_SCU_CLOCK_GetUsbClockFrequency
    {standard input}:2768   .text.XMC_SCU_CLOCK_GetUsbClockFrequency:00000044 $d
    {standard input}:2773   .text.XMC_SCU_CLOCK_GetEbuClockFrequency:00000000 $t
    {standard input}:2778   .text.XMC_SCU_CLOCK_GetEbuClockFrequency:00000000 XMC_SCU_CLOCK_GetEbuClockFrequency
    {standard input}:2820   .text.XMC_SCU_CLOCK_GetEbuClockFrequency:00000024 $d
    {standard input}:2825   .text.XMC_SCU_CLOCK_GetWdtClockFrequency:00000000 $t
    {standard input}:2830   .text.XMC_SCU_CLOCK_GetWdtClockFrequency:00000000 XMC_SCU_CLOCK_GetWdtClockFrequency
    {standard input}:2901   .text.XMC_SCU_CLOCK_GetWdtClockFrequency:00000050 $d
    {standard input}:2907   .text.XMC_SCU_CLOCK_GetExternalOutputClockFrequency:00000000 $t
    {standard input}:2912   .text.XMC_SCU_CLOCK_GetExternalOutputClockFrequency:00000000 XMC_SCU_CLOCK_GetExternalOutputClockFrequency
    {standard input}:3001   .text.XMC_SCU_CLOCK_GetExternalOutputClockFrequency:0000006c $d
    {standard input}:3007   .text.XMC_SCU_CLOCK_GetPeripheralClockFrequency:00000000 $t
    {standard input}:3012   .text.XMC_SCU_CLOCK_GetPeripheralClockFrequency:00000000 XMC_SCU_CLOCK_GetPeripheralClockFrequency
    {standard input}:3041   .text.XMC_SCU_CLOCK_GetPeripheralClockFrequency:0000001c $d
    {standard input}:3046   .text.XMC_SCU_CLOCK_SetSystemClockSource:00000000 $t
    {standard input}:3093   .text.XMC_SCU_CLOCK_SetSystemClockSource:00000024 $d
    {standard input}:3098   .text.XMC_SCU_CLOCK_SetUsbClockSource:00000000 $t
    {standard input}:3103   .text.XMC_SCU_CLOCK_SetUsbClockSource:00000000 XMC_SCU_CLOCK_SetUsbClockSource
    {standard input}:3145   .text.XMC_SCU_CLOCK_SetUsbClockSource:00000024 $d
    {standard input}:3150   .text.XMC_SCU_CLOCK_SetWdtClockSource:00000000 $t
    {standard input}:3155   .text.XMC_SCU_CLOCK_SetWdtClockSource:00000000 XMC_SCU_CLOCK_SetWdtClockSource
    {standard input}:3197   .text.XMC_SCU_CLOCK_SetWdtClockSource:00000024 $d
    {standard input}:3202   .text.XMC_SCU_CLOCK_SetExternalOutputClockSource:00000000 $t
    {standard input}:3207   .text.XMC_SCU_CLOCK_SetExternalOutputClockSource:00000000 XMC_SCU_CLOCK_SetExternalOutputClockSource
    {standard input}:3252   .text.XMC_SCU_CLOCK_SetExternalOutputClockSource:00000024 $d
    {standard input}:3257   .text.XMC_SCU_CLOCK_SetSystemPllClockSource:00000000 $t
    {standard input}:3262   .text.XMC_SCU_CLOCK_SetSystemPllClockSource:00000000 XMC_SCU_CLOCK_SetSystemPllClockSource
    {standard input}:3318   .text.XMC_SCU_CLOCK_SetSystemPllClockSource:0000003c $d
    {standard input}:3323   .text.XMC_SCU_HIB_SetRtcClockSource:00000000 $t
    {standard input}:3328   .text.XMC_SCU_HIB_SetRtcClockSource:00000000 XMC_SCU_HIB_SetRtcClockSource
    {standard input}:3382   .text.XMC_SCU_HIB_SetRtcClockSource:00000034 $d
    {standard input}:3388   .text.XMC_SCU_HIB_SetStandbyClockSource:00000000 $t
    {standard input}:3447   .text.XMC_SCU_HIB_SetStandbyClockSource:00000034 $d
    {standard input}:3453   .text.XMC_SCU_CLOCK_SetSystemClockDivider:00000000 $t
    {standard input}:3503   .text.XMC_SCU_CLOCK_SetSystemClockDivider:00000024 $d
    {standard input}:3508   .text.XMC_SCU_CLOCK_SetCcuClockDivider:00000000 $t
    {standard input}:3558   .text.XMC_SCU_CLOCK_SetCcuClockDivider:00000024 $d
    {standard input}:3563   .text.XMC_SCU_CLOCK_SetCpuClockDivider:00000000 $t
    {standard input}:3613   .text.XMC_SCU_CLOCK_SetCpuClockDivider:00000024 $d
    {standard input}:3618   .text.XMC_SCU_CLOCK_SetPeripheralClockDivider:00000000 $t
    {standard input}:3668   .text.XMC_SCU_CLOCK_SetPeripheralClockDivider:00000024 $d
    {standard input}:3673   .text.XMC_SCU_CLOCK_SetUsbClockDivider:00000000 $t
    {standard input}:3678   .text.XMC_SCU_CLOCK_SetUsbClockDivider:00000000 XMC_SCU_CLOCK_SetUsbClockDivider
    {standard input}:3723   .text.XMC_SCU_CLOCK_SetUsbClockDivider:00000024 $d
    {standard input}:3728   .text.XMC_SCU_CLOCK_SetEbuClockDivider:00000000 $t
    {standard input}:3733   .text.XMC_SCU_CLOCK_SetEbuClockDivider:00000000 XMC_SCU_CLOCK_SetEbuClockDivider
    {standard input}:3778   .text.XMC_SCU_CLOCK_SetEbuClockDivider:00000024 $d
    {standard input}:3783   .text.XMC_SCU_CLOCK_SetWdtClockDivider:00000000 $t
    {standard input}:3788   .text.XMC_SCU_CLOCK_SetWdtClockDivider:00000000 XMC_SCU_CLOCK_SetWdtClockDivider
    {standard input}:3833   .text.XMC_SCU_CLOCK_SetWdtClockDivider:00000024 $d
    {standard input}:3838   .text.XMC_SCU_CLOCK_SetExternalOutputClockDivider:00000000 $t
    {standard input}:3843   .text.XMC_SCU_CLOCK_SetExternalOutputClockDivider:00000000 XMC_SCU_CLOCK_SetExternalOutputClockDivider
    {standard input}:3890   .text.XMC_SCU_CLOCK_SetExternalOutputClockDivider:0000002c $d
    {standard input}:3895   .text.XMC_SCU_CLOCK_EnableClock:00000000 $t
    {standard input}:3900   .text.XMC_SCU_CLOCK_EnableClock:00000000 XMC_SCU_CLOCK_EnableClock
    {standard input}:3939   .text.XMC_SCU_CLOCK_EnableClock:0000001c $d
    {standard input}:3944   .text.XMC_SCU_CLOCK_DisableClock:00000000 $t
    {standard input}:3949   .text.XMC_SCU_CLOCK_DisableClock:00000000 XMC_SCU_CLOCK_DisableClock
    {standard input}:3988   .text.XMC_SCU_CLOCK_DisableClock:0000001c $d
    {standard input}:3993   .text.XMC_SCU_CLOCK_IsClockEnabled:00000000 $t
    {standard input}:3998   .text.XMC_SCU_CLOCK_IsClockEnabled:00000000 XMC_SCU_CLOCK_IsClockEnabled
    {standard input}:4044   .text.XMC_SCU_CLOCK_IsClockEnabled:00000028 $d
    {standard input}:4049   .text.XMC_SCU_CLOCK_GatePeripheralClock:00000000 $t
    {standard input}:4054   .text.XMC_SCU_CLOCK_GatePeripheralClock:00000000 XMC_SCU_CLOCK_GatePeripheralClock
    {standard input}:4116   .text.XMC_SCU_CLOCK_GatePeripheralClock:00000048 $d
    {standard input}:4121   .text.XMC_SCU_CLOCK_UngatePeripheralClock:00000000 $t
    {standard input}:4126   .text.XMC_SCU_CLOCK_UngatePeripheralClock:00000000 XMC_SCU_CLOCK_UngatePeripheralClock
    {standard input}:4188   .text.XMC_SCU_CLOCK_UngatePeripheralClock:00000048 $d
    {standard input}:4193   .text.XMC_SCU_CLOCK_IsPeripheralClockGated:00000000 $t
    {standard input}:4198   .text.XMC_SCU_CLOCK_IsPeripheralClockGated:00000000 XMC_SCU_CLOCK_IsPeripheralClockGated
    {standard input}:4258   .text.XMC_SCU_CLOCK_IsPeripheralClockGated:00000044 $d
    {standard input}:4263   .text.XMC_SCU_CLOCK_EnableUsbPll:00000000 $t
    {standard input}:4268   .text.XMC_SCU_CLOCK_EnableUsbPll:00000000 XMC_SCU_CLOCK_EnableUsbPll
    {standard input}:4302   .text.XMC_SCU_CLOCK_EnableUsbPll:0000001c $d
    {standard input}:4307   .text.XMC_SCU_CLOCK_DisableUsbPll:00000000 $t
    {standard input}:4312   .text.XMC_SCU_CLOCK_DisableUsbPll:00000000 XMC_SCU_CLOCK_DisableUsbPll
    {standard input}:4346   .text.XMC_SCU_CLOCK_DisableUsbPll:0000001c $d
    {standard input}:4351   .text.XMC_SCU_CLOCK_StartUsbPll:00000000 $t
    {standard input}:4356   .text.XMC_SCU_CLOCK_StartUsbPll:00000000 XMC_SCU_CLOCK_StartUsbPll
    {standard input}:4442   .text.XMC_SCU_CLOCK_StartUsbPll:00000070 $d
    {standard input}:4447   .text.XMC_SCU_CLOCK_StopUsbPll:00000000 $t
    {standard input}:4452   .text.XMC_SCU_CLOCK_StopUsbPll:00000000 XMC_SCU_CLOCK_StopUsbPll
    {standard input}:4483   .text.XMC_SCU_CLOCK_StopUsbPll:00000014 $d
    {standard input}:4489   .text.XMC_SCU_CLOCK_SetBackupClockCalibrationMode:00000000 $t
    {standard input}:4554   .text.XMC_SCU_CLOCK_SetBackupClockCalibrationMode:00000048 $d
    {standard input}:4559   .text.XMC_SCU_POWER_EnableUsb:00000000 $t
    {standard input}:4564   .text.XMC_SCU_POWER_EnableUsb:00000000 XMC_SCU_POWER_EnableUsb
    {standard input}:4597   .text.XMC_SCU_POWER_EnableUsb:00000018 $d
    {standard input}:4602   .text.XMC_SCU_POWER_DisableUsb:00000000 $t
    {standard input}:4607   .text.XMC_SCU_POWER_DisableUsb:00000000 XMC_SCU_POWER_DisableUsb
    {standard input}:4640   .text.XMC_SCU_POWER_DisableUsb:00000018 $d
    {standard input}:4645   .text.XMC_SCU_CLOCK_IsUsbPllLocked:00000000 $t
    {standard input}:4650   .text.XMC_SCU_CLOCK_IsUsbPllLocked:00000000 XMC_SCU_CLOCK_IsUsbPllLocked
    {standard input}:4687   .text.XMC_SCU_CLOCK_IsUsbPllLocked:00000020 $d
    {standard input}:4692   .text.XMC_SCU_HIB_EnableHibernateDomain:00000000 $t
    {standard input}:4754   .text.XMC_SCU_HIB_EnableHibernateDomain:0000004c $d
    {standard input}:4760   .text.XMC_SCU_HIB_DisableHibernateDomain:00000000 $t
    {standard input}:4765   .text.XMC_SCU_HIB_DisableHibernateDomain:00000000 XMC_SCU_HIB_DisableHibernateDomain
    {standard input}:4804   .text.XMC_SCU_HIB_DisableHibernateDomain:00000024 $d
    {standard input}:4810   .text.XMC_SCU_HIB_IsHibernateDomainEnabled:00000000 $t
    {standard input}:4815   .text.XMC_SCU_HIB_IsHibernateDomainEnabled:00000000 XMC_SCU_HIB_IsHibernateDomainEnabled
    {standard input}:4866   .text.XMC_SCU_HIB_IsHibernateDomainEnabled:00000034 $d
    {standard input}:4872   .text.XMC_SCU_HIB_EnableInternalSlowClock:00000000 $t
    {standard input}:4877   .text.XMC_SCU_HIB_EnableInternalSlowClock:00000000 XMC_SCU_HIB_EnableInternalSlowClock
    {standard input}:4919   .text.XMC_SCU_HIB_EnableInternalSlowClock:00000028 $d
    {standard input}:4925   .text.XMC_SCU_HIB_DisableInternalSlowClock:00000000 $t
    {standard input}:4930   .text.XMC_SCU_HIB_DisableInternalSlowClock:00000000 XMC_SCU_HIB_DisableInternalSlowClock
    {standard input}:4972   .text.XMC_SCU_HIB_DisableInternalSlowClock:00000028 $d
    {standard input}:4978   .text.XMC_SCU_CLOCK_EnableLowPowerOscillator:00000000 $t
    {standard input}:5057   .text.XMC_SCU_CLOCK_EnableLowPowerOscillator:0000006c $d
    {standard input}:5063   .text.XMC_SCU_CLOCK_DisableLowPowerOscillator:00000000 $t
    {standard input}:5068   .text.XMC_SCU_CLOCK_DisableLowPowerOscillator:00000000 XMC_SCU_CLOCK_DisableLowPowerOscillator
    {standard input}:5110   .text.XMC_SCU_CLOCK_DisableLowPowerOscillator:00000028 $d
    {standard input}:5116   .text.XMC_SCU_CLOCK_EnableHighPerformanceOscillator:00000000 $t
    {standard input}:5180   .text.XMC_SCU_CLOCK_EnableHighPerformanceOscillator:00000054 $d
    {standard input}:5187   .text.XMC_SCU_CLOCK_DisableHighPerformanceOscillator:00000000 $t
    {standard input}:5192   .text.XMC_SCU_CLOCK_DisableHighPerformanceOscillator:00000000 XMC_SCU_CLOCK_DisableHighPerformanceOscillator
    {standard input}:5225   .text.XMC_SCU_CLOCK_DisableHighPerformanceOscillator:00000018 $d
    {standard input}:5230   .text.XMC_SCU_CLOCK_EnableSystemPll:00000000 $t
    {standard input}:5269   .text.XMC_SCU_CLOCK_EnableSystemPll:0000001c $d
    {standard input}:5274   .text.XMC_SCU_CLOCK_DisableSystemPll:00000000 $t
    {standard input}:5313   .text.XMC_SCU_CLOCK_DisableSystemPll:0000001c $d
    {standard input}:5318   .text.XMC_SCU_CLOCK_StartSystemPll:00000000 $t
    {standard input}:5604   .text.XMC_SCU_CLOCK_StepSystemPllFrequency:00000000 XMC_SCU_CLOCK_StepSystemPllFrequency
    {standard input}:5546   .text.XMC_SCU_CLOCK_StartSystemPll:00000188 $d
    {standard input}:5556   .text.XMC_SCU_CLOCK_StopSystemPll:00000000 $t
    {standard input}:5561   .text.XMC_SCU_CLOCK_StopSystemPll:00000000 XMC_SCU_CLOCK_StopSystemPll
    {standard input}:5594   .text.XMC_SCU_CLOCK_StopSystemPll:00000018 $d
    {standard input}:5599   .text.XMC_SCU_CLOCK_StepSystemPllFrequency:00000000 $t
    {standard input}:5649   .text.XMC_SCU_CLOCK_StepSystemPllFrequency:00000028 $d
    {standard input}:5654   .text.XMC_SCU_CLOCK_IsSystemPllLocked:00000000 $t
    {standard input}:5659   .text.XMC_SCU_CLOCK_IsSystemPllLocked:00000000 XMC_SCU_CLOCK_IsSystemPllLocked
    {standard input}:5696   .text.XMC_SCU_CLOCK_IsSystemPllLocked:00000020 $d
    {standard input}:5701   .text.XMC_SCU_INTERRUPT_SetEventHandler:00000000 $t
    {standard input}:5706   .text.XMC_SCU_INTERRUPT_SetEventHandler:00000000 XMC_SCU_INTERRUPT_SetEventHandler
    {standard input}:5785   .text.XMC_SCU_INTERRUPT_SetEventHandler:00000054 $d
    {standard input}:5790   .text.XMC_SCU_IRQHandler:00000000 $t
    {standard input}:5795   .text.XMC_SCU_IRQHandler:00000000 XMC_SCU_IRQHandler
    {standard input}:5873   .text.XMC_SCU_IRQHandler:0000005c $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
SystemCoreClock
SystemCoreClockUpdate
OSCHP_GetFrequency
