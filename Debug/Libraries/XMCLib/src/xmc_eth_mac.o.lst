   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "xmc_eth_mac.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.XMC_ETH_MAC_Reset,"ax",%progbits
  20              	 .align 2
  21              	 .thumb
  22              	 .thumb_func
  24              	XMC_ETH_MAC_Reset:
  25              	.LFB128:
  26              	 .file 1 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Libraries\\XMCLib\\inc/xmc_eth_mac.h"
   1:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
   2:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
   3:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @file xmc_eth_mac.h
   4:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @date 2016-01-12
   5:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
   6:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @cond
   7:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  **************************************************************************************************
   8:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * XMClib v2.1.6 - XMC Peripheral Driver Library 
   9:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
  10:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  11:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * All rights reserved.                        
  12:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *                                             
  13:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  14:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * following conditions are met:   
  15:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *                                                                              
  16:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  17:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * disclaimer.                        
  18:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * 
  19:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  20:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  21:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * 
  22:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  23:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * products derived from this software without specific prior written permission.                  
  24:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *                                                                              
  25:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  26:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  27:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  28:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  29:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  30:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  31:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  32:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *                                                                              
  33:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  34:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  35:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  **************************************************************************************************
  36:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
  37:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Change History
  38:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * --------------
  39:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
  40:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * 2015-06-20:
  41:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *     - Initial <br>
  42:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
  43:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @endcond
  44:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
  45:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
  46:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
  47:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @addtogroup XMClib XMC Peripheral Library
  48:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @{
  49:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
  50:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
  51:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
  52:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @addtogroup ETH_MAC
  53:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @brief Ethernet Low level driver for XMC4000 microcontroller family.
  54:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
  55:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * The Ethernet MAC (ETH) is a major communication peripheral that supports 10/100
  56:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * MBit/s data transfer rates in compliance with the IEEE 802.3-2002 standard. The ETH
  57:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * may be used to implement internet connected applications using IPv4 and IPv6. The
  58:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * ETH also includes support for IEEE1588 time synchronisation to allow implementation
  59:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * of Real Time Ethernet protocols.
  60:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
  61:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * The XMC_ETH_MAC low level driver provides functions to configure and initialize
  62:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * the ETH_MAC hardware peripheral.
  63:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @{
  64:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
  65:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
  66:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #ifndef XMC_ETH_MAC_H
  67:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #define XMC_ETH_MAC_H
  68:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
  69:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**************************************************************************************************
  70:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * HEADER FILES
  71:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  **************************************************************************************************
  72:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
  73:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #include "xmc_common.h"
  74:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
  75:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #if defined (ETH0)
  76:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
  77:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #include "xmc_eth_mac_map.h"
  78:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
  79:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**************************************************************************************************
  80:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * MACROS
  81:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  **************************************************************************************************
  82:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
  83:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #define XMC_ETH_MAC_BUF_SIZE           (1518)     /**< ETH MAC buffer size */
  84:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #define XMC_ETH_MAC_PHY_MAX_RETRIES    (0xffffUL) /**< Maximum retries */
  85:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #define XMC_ETH_WAKEUP_REGISTER_LENGTH (8U)       /**< Remote wakeup frame reg length */
  86:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
  87:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**************************************************************************************************
  88:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * ENUMS
  89:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  **************************************************************************************************
  90:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
  91:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
  92:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Ethernet MAC status return values
  93:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
  94:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** typedef enum XMC_ETH_MAC_STATUS
  95:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
  96:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_STATUS_OK    = 0U, /**< Driver accepted application request */
  97:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_STATUS_BUSY  = 1U, /**< Driver is busy and cannot handle request */
  98:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_STATUS_ERROR = 2U  /**< Driver could not fulfil application request */
  99:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** } XMC_ETH_MAC_STATUS_t;
 100:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 101:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 102:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Transmission frame
 103:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 104:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** typedef enum XMC_ETH_MAC_TX_FRAME
 105:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
 106:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_TX_FRAME_FRAGMENT  = 0x1U, /**< Indicate frame fragment */
 107:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_TX_FRAME_EVENT     = 0x2U, /**< Generate event when frame is transmitted */
 108:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_TX_FRAME_TIMESTAMP = 0x4U  /**< Capture frame time stamp */
 109:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** } XMC_ETH_MAC_TX_FRAME_t;
 110:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 111:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 112:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * ETH MAC event
 113:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 114:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** typedef enum XMC_ETH_MAC_EVENT
 115:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
 116:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_PMT = ETH_INTERRUPT_MASK_PMTIM_Msk << 16,        /**< Power management event */
 117:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_TIMESTAMP = ETH_INTERRUPT_MASK_TSIM_Msk << 16,   /**< Time stamp event */
 118:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_EARLY_RECEIVE = ETH_STATUS_ERI_Msk,              /**< Early receive */
 119:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_BUS_ERROR = ETH_STATUS_FBI_Msk,                  /**< Bus error */
 120:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_EARLY_TRANSMIT = ETH_STATUS_ETI_Msk,             /**< Early transmit */
 121:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_RECEIVE_WATCHDOG_TIMEOUT = ETH_STATUS_RWT_Msk,   /**< Receive watchdog time-out
 122:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_RECEIVE_PROCESS_STOPPED = ETH_STATUS_RPS_Msk,    /**< Receive process stopped *
 123:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_RECEIVE_BUFFER_UNAVAILABLE = ETH_STATUS_RU_Msk,  /**< Receive buffer unavailabl
 124:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_RECEIVE = ETH_STATUS_RI_Msk,                     /**< Receive event */
 125:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_TRANSMIT_UNDERFLOW = ETH_STATUS_UNF_Msk,         /**< Transmit underflow */
 126:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_RECEIVE_OVERFLOW = ETH_STATUS_OVF_Msk,           /**< Receive overflow */
 127:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_TRANSMIT_JABBER_TIMEOUT = ETH_STATUS_TJT_Msk,    /**< Transmit jabber time-out 
 128:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_TRANSMIT_BUFFER_UNAVAILABLE = ETH_STATUS_TU_Msk, /**< Transmit buffer unavailab
 129:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_TRANSMIT_PROCESS_STOPPED = ETH_STATUS_TPS_Msk,   /**< Transmit process stopped 
 130:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_EVENT_TRANSMIT = ETH_STATUS_TI_Msk                     /**< Transmit event */
 131:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** } XMC_ETH_MAC_EVENT_t;
 132:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 133:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 134:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Link interface
 135:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 136:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** typedef enum XMC_ETH_LINK_INTERFACE
 137:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
 138:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_LINK_INTERFACE_MII, /**< Link interface: Media independent interface */
 139:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_LINK_INTERFACE_RMII /**< Link interface: Reduced media independent interface */
 140:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** } XMC_ETH_LINK_INTERFACE_t;
 141:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 142:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 143:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * ETH link status
 144:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 145:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** typedef enum XMC_ETH_LINK_STATUS
 146:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
 147:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_LINK_STATUS_DOWN, /**< Link status down */
 148:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_LINK_STATUS_UP    /**< Link status up */
 149:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** } XMC_ETH_LINK_STATUS_t;
 150:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 151:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 152:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * ETH link speed
 153:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 154:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** typedef enum XMC_ETH_LINK_SPEED
 155:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
 156:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_LINK_SPEED_10M  = 0UL << ETH_MAC_CONFIGURATION_FES_Pos, /**< Link speed: 10M */
 157:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_LINK_SPEED_100M = 1UL << ETH_MAC_CONFIGURATION_FES_Pos  /**< Link speed: 100M */
 158:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** } XMC_ETH_LINK_SPEED_t;
 159:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 160:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 161:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * ETH duplex settings (full/half?)
 162:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 163:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** typedef enum XMC_ETH_LINK_DUPLEX
 164:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
 165:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_LINK_DUPLEX_HALF = 0UL << ETH_MAC_CONFIGURATION_DM_Pos, /**< Half duplex */
 166:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_LINK_DUPLEX_FULL = 1UL << ETH_MAC_CONFIGURATION_DM_Pos  /**< Full duplex */
 167:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** } XMC_ETH_LINK_DUPLEX_t;
 168:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 169:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 170:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * MAC address filter
 171:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 172:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** typedef enum XMC_ETH_MAC_ADDR_FILTER
 173:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
 174:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_ADDR_FILTER_MASK_BYTE0 = 0x01000000UL, /**< Address filter mask: byte 0 */
 175:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_ADDR_FILTER_MASK_BYTE1 = 0x02000000UL, /**< Address filter mask: byte 1 */
 176:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_ADDR_FILTER_MASK_BYTE2 = 0x04000000UL, /**< Address filter mask: byte 2 */
 177:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_ADDR_FILTER_MASK_BYTE3 = 0x08000000UL, /**< Address filter mask: byte 3 */
 178:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_ADDR_FILTER_MASK_BYTE4 = 0x10000000UL, /**< Address filter mask: byte 4 */
 179:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_ADDR_FILTER_MASK_BYTE5 = 0x20000000UL, /**< Address filter mask: byte 5 */
 180:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_ADDR_FILTER_SA         = 0x40000000UL  /**< Address filter SA */
 181:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** } XMC_ETH_MAC_ADDR_FILTER_t;
 182:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 183:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 184:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Power management events that triggers a PMT interrupt
 185:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 186:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** typedef enum XMC_ETH_MAC_PMT_EVENT
 187:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
 188:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_PMT_EVENT_ON_WAKEUP_FRAME         = ETH_PMT_CONTROL_STATUS_RWKPKTEN_Msk,  /**< Wakeup
 189:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_PMT_EVENT_ON_MAGIC_PACKET         = ETH_PMT_CONTROL_STATUS_MGKPKTEN_Msk,  /**< Magic 
 190:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_PMT_EVENT_ON_UNICAST_FRAME_FILTER = ETH_PMT_CONTROL_STATUS_GLBLUCAST_Msk  /**< Unicas
 191:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** } XMC_ETH_MAC_PMT_EVENT_t;
 192:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 193:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 194:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 195:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * ETH MAC time-stamp configuration enable
 196:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 197:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** typedef enum XMC_ETH_MAC_TIMESTAMP_CONFIG
 198:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
 199:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_TIMESTAMP_CONFIG_FINE_UPDATE = ETH_TIMESTAMP_CONTROL_TSCFUPDT_Msk,             /**< F
 200:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_TIMESTAMP_CONFIG_ENABLE_ALL_FRAMES = ETH_TIMESTAMP_CONTROL_TSENALL_Msk,        /**< E
 201:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_TIMESTAMP_CONFIG_ENABLE_PTPV2 = ETH_TIMESTAMP_CONTROL_TSVER2ENA_Msk,           /**< P
 202:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_TIMESTAMP_CONFIG_ENABLE_PTP_OVER_ETHERNET = ETH_TIMESTAMP_CONTROL_TSIPENA_Msk, /**< P
 203:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_TIMESTAMP_CONFIG_ENABLE_PTP_OVER_IPV6 = ETH_TIMESTAMP_CONTROL_TSIPV6ENA_Msk,   /**< P
 204:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_TIMESTAMP_CONFIG_ENABLE_PTP_OVER_IPV4 = ETH_TIMESTAMP_CONTROL_TSIPV4ENA_Msk,   /**< P
 205:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_TIMESTAMP_CONFIG_ENABLE_MAC_ADDRESS_FILTER = ETH_TIMESTAMP_CONTROL_TSENMACADDR_Msk /*
 206:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** } XMC_ETH_MAC_TIMESTAMP_CONFIG_t;
 207:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 208:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**************************************************************************************************
 209:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * DATA STRUCTURES
 210:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  **************************************************************************************************
 211:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 212:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /* Anonymous structure/union guard start */
 213:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #if defined (__CC_ARM)
 214:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #pragma push
 215:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #pragma anon_unions
 216:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #elif defined (__TASKING__)
 217:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #pragma warning 586
 218:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #endif
 219:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 220:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 221:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * ETH MAC port control
 222:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 223:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** typedef union XMC_ETH_MAC_PORT_CTRL
 224:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
 225:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   struct
 226:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   {
 227:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****     uint32_t rxd0: 2;     /**< Receive data bit 0 (::XMC_ETH_MAC_PORT_CTRL_RXD0_t) */
 228:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****     uint32_t rxd1: 2;     /**< Receive data bit 1 (::XMC_ETH_MAC_PORT_CTRL_RXD1_t) */
 229:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****     uint32_t rxd2: 2;     /**< Receive data bit 2 (only MII) (::XMC_ETH_MAC_PORT_CTRL_RXD2_t) */
 230:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****     uint32_t rxd3: 2;     /**< Receive data bit 3 (only MII) (::XMC_ETH_MAC_PORT_CTRL_RXD3_t) */
 231:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****     uint32_t clk_rmii: 2; /**< RMII: Continuous 50 MHz reference clock.
 232:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****                                MII: Receive clock, 25 MHz for 100Mbit/s, 2.5 MHz for 10Mbit/s
 233:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****                                (::XMC_ETH_MAC_PORT_CTRL_CLK_RMII_t) */
 234:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****     uint32_t crs_dv: 2;   /**< RMII: carrier sense/RX_Data valid. MII: RX_Data valid (::XMC_ETH_MAC
 235:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****     uint32_t crs: 2;      /**< Carrier sense for only MII (::XMC_ETH_MAC_PORT_CTRL_CRS_t) */
 236:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****     uint32_t rxer: 2;     /**< Receive error (::XMC_ETH_MAC_PORT_CTRL_RXER_t) */
 237:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****     uint32_t col: 2;      /**< Collision Detect for only MII (::XMC_ETH_MAC_PORT_CTRL_COL_t) */
 238:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****     uint32_t clk_tx: 2;   /**< Transmit clock (only MII), 25 MHz for 100Mbit/s, 2.5 MHz for 10Mbit/
 239:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****     uint32_t: 2;          /**< Reserved bits */
 240:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****     uint32_t mdio: 2;     /**< Bidirectional, push-pull management data I/O line (::XMC_ETH_MAC_POR
 241:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****     uint32_t: 2;          /**< Reserved bits */
 242:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****     uint32_t mode: 1;     /**< RMII or MII (::XMC_ETH_MAC_PORT_CTRL_MODE_t) */
 243:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   };
 244:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 245:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint32_t raw;
 246:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** } XMC_ETH_MAC_PORT_CTRL_t;
 247:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 248:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 249:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * ETH MAC DMA descriptor
 250:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 251:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** typedef struct XMC_ETH_MAC_DMA_DESC
 252:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
 253:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint32_t status;                 /**< DMA descriptor status */
 254:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint32_t length;                 /**< Descriptor length */
 255:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint32_t buffer1;                /**< Buffer 1 */
 256:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint32_t buffer2;                /**< Buffer 2 */
 257:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint32_t extended_status;        /**< Extended status */
 258:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint32_t reserved;               /**< Reserved */
 259:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint32_t time_stamp_seconds;     /**< Time stamp low */
 260:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint32_t time_stamp_nanoseconds; /**< Time stamp high */
 261:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** } XMC_ETH_MAC_DMA_DESC_t;
 262:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 263:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 264:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * ETH MAC time
 265:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 266:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** typedef struct XMC_ETH_MAC_TIME
 267:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
 268:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   int32_t nanoseconds;
 269:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint32_t seconds;
 270:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** } XMC_ETH_MAC_TIME_t;
 271:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 272:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 273:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * ETH driver structure
 274:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 275:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** typedef struct XMC_ETH_MAC
 276:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
 277:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   ETH_GLOBAL_TypeDef *regs;        /**< ETH module 0 (now, we have a single ETH module) */
 278:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint64_t address;              /**< MAC address */
 279:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_DMA_DESC_t *rx_desc; /**< DMA descriptor: RX */
 280:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   XMC_ETH_MAC_DMA_DESC_t *tx_desc; /**< DMA descriptor: TX */
 281:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint8_t *rx_buf;                /**< RX buffer */
 282:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint8_t *tx_buf;                /**< TX buffer */
 283:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint8_t *frame_end;              /**< End of assembled frame fragments */
 284:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint8_t num_rx_buf;              /**< How many RX descriptors? */
 285:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint8_t num_tx_buf;              /**< How many TX descriptors? */
 286:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint8_t tx_index;                /**< Transmit descriptor index */
 287:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint8_t rx_index;                /**< Receive descriptor index */
 288:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   uint8_t tx_ts_index;             /**< Transmit time-stamp descriptor index */
 289:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** } XMC_ETH_MAC_t;
 290:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 291:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /* Anonymous structure/union guard end */
 292:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #if defined (__CC_ARM)
 293:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #pragma pop
 294:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #elif defined (__TASKING__)
 295:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #pragma warning restore
 296:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #endif
 297:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 298:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**************************************************************************************************
 299:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * API PROTOTYPES
 300:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  **************************************************************************************************
 301:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 302:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #ifdef __cplusplus
 303:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** extern "C" {
 304:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** #endif
 305:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 306:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 307:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param eth_mac A constant pointer to XMC_ETH_MAC_t, pointing to the ETH MAC base address
 308:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @return XMC_ETH_MAC_STATUS_t Initialization status
 309:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 310:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par<b>Description: </b><br>
 311:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Initialize the Ethernet MAC peripheral <br>
 312:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 313:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par
 314:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * The function sets the link speed, applies the duplex mode, sets auto-negotiation
 315:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * and loop-back settings.
 316:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 317:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** XMC_ETH_MAC_STATUS_t XMC_ETH_MAC_Init(XMC_ETH_MAC_t *const eth_mac);
 318:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 319:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 320:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param eth_mac A constant pointer to XMC_ETH_MAC_t, pointing to the ETH MAC base address
 321:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @return None
 322:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 323:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par<b>Description: </b><br>
 324:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Initialize the RX DMA descriptors <br>
 325:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 326:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par
 327:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * The function initializes the RX descriptors in a chained configuration. It sets
 328:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * up the status bit, control bit, buffer length and the buffer pointer.
 329:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 330:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** void XMC_ETH_MAC_InitRxDescriptors(XMC_ETH_MAC_t *const eth_mac);
 331:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 332:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 333:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param eth_mac A constant pointer to XMC_ETH_MAC_t, pointing to the ETH MAC base address
 334:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @return None
 335:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 336:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par<b>Description: </b><br>
 337:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Initialize the TX DMA descriptors <br>
 338:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 339:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par
 340:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * The function initializes the TX descriptors in a chained configuration. It sets
 341:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * up the status bit, control bit, buffer length and the buffer pointer.
 342:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 343:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** void XMC_ETH_MAC_InitTxDescriptors(XMC_ETH_MAC_t *const eth_mac);
 344:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  
 345:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 346:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param eth_mac A constant pointer to XMC_ETH_MAC_t, pointing to the ETH MAC base address
 347:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @return None
 348:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 349:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par<b>Description: </b><br>
 350:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Enable the Ethernet MAC peripheral <br>
 351:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 352:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par
 353:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * The function de-asserts the peripheral reset.
 354:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 355:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** void XMC_ETH_MAC_Enable(XMC_ETH_MAC_t *const eth_mac);
 356:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 357:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 358:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param eth_mac A constant pointer to XMC_ETH_MAC_t, pointing to the ETH MAC base address
 359:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @return None
 360:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 361:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par<b>Description: </b><br>
 362:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Disable the Ethernet MAC peripheral <br>
 363:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 364:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par
 365:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * The function asserts the peripheral reset.
 366:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 367:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** void XMC_ETH_MAC_Disable(XMC_ETH_MAC_t *const eth_mac);
 368:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 369:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 370:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param eth_mac A constant pointer to XMC_ETH_MAC_t, pointing to the ETH MAC base address
 371:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @return bool
 372:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 373:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par<b>Description: </b><br>
 374:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Check if the ETH MAC is enabled <br>
 375:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 376:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par
 377:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * The function checks if the ETH MAC is enabled or not. It returns "true" if the
 378:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * peripheral is enabled, "false" otherwise.
 379:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 380:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** bool XMC_ETH_MAC_IsEnabled(const XMC_ETH_MAC_t *const eth_mac);
 381:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 382:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 383:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param eth_mac A constant pointer to XMC_ETH_MAC_t, pointing to the ETH MAC base address
 384:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @return None
 385:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 386:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par<b>Description: </b><br>
 387:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Reset the ETH MAC peripheral <br>
 388:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 389:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par
 390:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * The function resets the ETH MAC peripheral. It blocks until reset.
 391:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 392:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** __STATIC_INLINE void XMC_ETH_MAC_Reset(XMC_ETH_MAC_t *const eth_mac)
 393:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
  27              	 .loc 1 393 0
  28              	 .cfi_startproc
  29              	 
  30              	 
  31              	 
  32 0000 80B4     	 push {r7}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 4
  35              	 .cfi_offset 7,-4
  36 0002 83B0     	 sub sp,sp,#12
  37              	.LCFI1:
  38              	 .cfi_def_cfa_offset 16
  39 0004 00AF     	 add r7,sp,#0
  40              	.LCFI2:
  41              	 .cfi_def_cfa_register 7
  42 0006 7860     	 str r0,[r7,#4]
 394:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   eth_mac->regs->BUS_MODE |= (uint32_t)ETH_BUS_MODE_SWR_Msk;
  43              	 .loc 1 394 0
  44 0008 7B68     	 ldr r3,[r7,#4]
  45 000a 1B68     	 ldr r3,[r3]
  46 000c 7A68     	 ldr r2,[r7,#4]
  47 000e 1268     	 ldr r2,[r2]
  48 0010 02F58052 	 add r2,r2,#4096
  49 0014 1268     	 ldr r2,[r2]
  50 0016 42F00102 	 orr r2,r2,#1
  51 001a 03F58053 	 add r3,r3,#4096
  52 001e 1A60     	 str r2,[r3]
 395:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   while ((eth_mac->regs->BUS_MODE & (uint32_t)ETH_BUS_MODE_SWR_Msk) != 0U)
  53              	 .loc 1 395 0
  54 0020 00BF     	 nop
  55              	.L2:
  56              	 .loc 1 395 0 is_stmt 0 discriminator 1
  57 0022 7B68     	 ldr r3,[r7,#4]
  58 0024 1B68     	 ldr r3,[r3]
  59 0026 03F58053 	 add r3,r3,#4096
  60 002a 1B68     	 ldr r3,[r3]
  61 002c 03F00103 	 and r3,r3,#1
  62 0030 002B     	 cmp r3,#0
  63 0032 F6D1     	 bne .L2
 396:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   {
 397:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   }
 398:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** }
  64              	 .loc 1 398 0 is_stmt 1
  65 0034 0C37     	 adds r7,r7,#12
  66              	.LCFI3:
  67              	 .cfi_def_cfa_offset 4
  68 0036 BD46     	 mov sp,r7
  69              	.LCFI4:
  70              	 .cfi_def_cfa_register 13
  71              	 
  72 0038 5DF8047B 	 ldr r7,[sp],#4
  73              	.LCFI5:
  74              	 .cfi_restore 7
  75              	 .cfi_def_cfa_offset 0
  76 003c 7047     	 bx lr
  77              	 .cfi_endproc
  78              	.LFE128:
  80 003e 00BF     	 .section .text.XMC_ETH_MAC_SetAddress,"ax",%progbits
  81              	 .align 2
  82              	 .thumb
  83              	 .thumb_func
  85              	XMC_ETH_MAC_SetAddress:
  86              	.LFB130:
 399:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 400:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 401:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param eth_mac A constant pointer to XMC_ETH_MAC_t, pointing to the ETH MAC base address
 402:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param phy_addr PHY address
 403:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param reg_addr Register address
 404:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param data The destination to which the read data needs to be copied to
 405:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @return XMC_ETH_MAC_STATUS_t ETH MAC status
 406:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 407:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par<b>Description: </b><br>
 408:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Read a PHY register <br>
 409:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 410:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par
 411:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * The function reads a PHY register. It essentially polls busy bit during max
 412:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * PHY_TIMEOUT time and reads the information into 'data' when not busy.
 413:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 414:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** XMC_ETH_MAC_STATUS_t XMC_ETH_MAC_ReadPhy(XMC_ETH_MAC_t *const eth_mac, uint8_t phy_addr, uint8_t re
 415:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 416:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 417:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param eth_mac A constant pointer to XMC_ETH_MAC_t, pointing to the ETH MAC base address
 418:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param phy_addr PHY address
 419:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param reg_addr Register address
 420:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param data The data to write
 421:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @return XMC_ETH_MAC_STATUS_t ETH MAC status
 422:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 423:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par<b>Description: </b><br>
 424:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Write a PHY register <br>
 425:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 426:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par
 427:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * The function reads a PHY register. It essentially writes the data and polls
 428:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * the busy bit until it is no longer busy.
 429:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 430:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** XMC_ETH_MAC_STATUS_t XMC_ETH_MAC_WritePhy(XMC_ETH_MAC_t *const eth_mac, uint8_t phy_addr, uint8_t r
 431:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 432:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 433:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param eth_mac A constant pointer to XMC_ETH_MAC_t, pointing to the ETH MAC base address
 434:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param port_ctrl Port control configuration
 435:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @return None
 436:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 437:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par<b>Description: </b><br>
 438:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Set port control configuration <br>
 439:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 440:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par
 441:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * The function sets the port control by writing the configuration into the
 442:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * CON register.
 443:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 444:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \note
 445:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * MII Mode is only available in:
 446:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * - XMC4500 LQFP144 and BGA144 packages
 447:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * - XMC4700 LQFP144 and BGA196 packages
 448:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * - XMC4800 LQFP144 and BGA196 packages
 449:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 450:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 451:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** __STATIC_INLINE void XMC_ETH_MAC_SetPortControl(XMC_ETH_MAC_t *const eth_mac, const XMC_ETH_MAC_POR
 452:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
 453:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   ETH0_CON->CON = (uint32_t)port_ctrl.raw;
 454:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** }
 455:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 456:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 457:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param eth_mac A constant pointer to XMC_ETH_MAC_t, pointing to the ETH MAC base address
 458:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @return XMC_ETH_MAC_STATUS_t ETH MAC status
 459:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 460:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par<b>Description: </b><br>
 461:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Set management clock divider <br>
 462:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 463:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par
 464:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * The function sets the management clock divider by writing to the GMII_ADDRESS
 465:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * register.
 466:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 467:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** XMC_ETH_MAC_STATUS_t XMC_ETH_MAC_SetManagmentClockDivider(XMC_ETH_MAC_t *const eth_mac);
 468:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** 
 469:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** /**
 470:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param eth_mac A constant pointer to XMC_ETH_MAC_t, pointing to the ETH MAC base address
 471:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @param addr The MAC address to set
 472:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * @return None
 473:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 474:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par<b>Description: </b><br>
 475:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * Set MAC address <br>
 476:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  *
 477:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * \par
 478:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * The function sets the MAC address by writing to the MAC_ADDRESS0_HIGH and
 479:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  * MAC_ADDRESS0_LOW registers.
 480:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****  */
 481:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** __STATIC_INLINE void XMC_ETH_MAC_SetAddress(XMC_ETH_MAC_t *const eth_mac, uint64_t addr)
 482:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** {
  87              	 .loc 1 482 0
  88              	 .cfi_startproc
  89              	 
  90              	 
  91              	 
  92 0000 B0B4     	 push {r4,r5,r7}
  93              	.LCFI6:
  94              	 .cfi_def_cfa_offset 12
  95              	 .cfi_offset 4,-12
  96              	 .cfi_offset 5,-8
  97              	 .cfi_offset 7,-4
  98 0002 85B0     	 sub sp,sp,#20
  99              	.LCFI7:
 100              	 .cfi_def_cfa_offset 32
 101 0004 00AF     	 add r7,sp,#0
 102              	.LCFI8:
 103              	 .cfi_def_cfa_register 7
 104 0006 F860     	 str r0,[r7,#12]
 105 0008 C7E90023 	 strd r2,[r7]
 483:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   eth_mac->regs->MAC_ADDRESS0_HIGH = (uint32_t)(addr >> 32);
 106              	 .loc 1 483 0
 107 000c FB68     	 ldr r3,[r7,#12]
 108 000e 1968     	 ldr r1,[r3]
 109 0010 D7E90023 	 ldrd r2,[r7]
 110 0014 1C00     	 movs r4,r3
 111 0016 0025     	 movs r5,#0
 112 0018 2346     	 mov r3,r4
 113 001a 0B64     	 str r3,[r1,#64]
 484:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h ****   eth_mac->regs->MAC_ADDRESS0_LOW = (uint32_t)addr;
 114              	 .loc 1 484 0
 115 001c FB68     	 ldr r3,[r7,#12]
 116 001e 1B68     	 ldr r3,[r3]
 117 0020 3A68     	 ldr r2,[r7]
 118 0022 5A64     	 str r2,[r3,#68]
 485:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_eth_mac.h **** }
 119              	 .loc 1 485 0
 120 0024 1437     	 adds r7,r7,#20
 121              	.LCFI9:
 122              	 .cfi_def_cfa_offset 12
 123 0026 BD46     	 mov sp,r7
 124              	.LCFI10:
 125              	 .cfi_def_cfa_register 13
 126              	 
 127 0028 B0BC     	 pop {r4,r5,r7}
 128              	.LCFI11:
 129              	 .cfi_restore 7
 130              	 .cfi_restore 5
 131              	 .cfi_restore 4
 132              	 .cfi_def_cfa_offset 0
 133 002a 7047     	 bx lr
 134              	 .cfi_endproc
 135              	.LFE130:
 137              	 .section .text.XMC_SCU_CLOCK_GetSystemClockFrequency,"ax",%progbits
 138              	 .align 2
 139              	 .thumb
 140              	 .thumb_func
 142              	XMC_SCU_CLOCK_GetSystemClockFrequency:
 143              	.LFB192:
 144              	 .file 2 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Libraries\\XMCLib\\inc/xmc4_scu.h"
   1:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
   2:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @file xmc4_scu.h
   3:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @date 2016-01-12
   4:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
   5:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @cond
   6:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   *************************************************************************************************
   7:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMClib v2.1.6 - XMC Peripheral Driver Library 
   8:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
   9:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  10:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * All rights reserved.                        
  11:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                                             
  12:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * following conditions are met:   
  14:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                                                                              
  15:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  16:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * disclaimer.                        
  17:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * 
  18:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  19:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  20:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * 
  21:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  22:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * products derived from this software without specific prior written permission.                  
  23:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                                                                              
  24:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  31:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                                                                              
  32:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  34:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  **************************************************************************************************
  35:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
  36:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Change History
  37:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * --------------
  38:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
  39:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * 2015-06-20:
  40:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *     - Initial version
  41:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *     - Documentation improved
  42:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
  43:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * 2015-11-30:
  44:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *     - Documentation improved <br>
  45:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *      
  46:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @endcond 
  47:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
  48:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
  49:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  50:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #ifndef XMC4_SCU_H
  51:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC4_SCU_H
  52:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  53:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**************************************************************************************************
  54:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * HEADER FILES
  55:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  **************************************************************************************************
  56:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  57:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #include "xmc_common.h"
  58:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  59:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if UC_FAMILY == XMC4
  60:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  61:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
  62:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @addtogroup XMClib XMC Peripheral Library
  63:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @{
  64:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
  65:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  
  66:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
  67:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @addtogroup SCU
  68:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @{
  69:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
  70:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  71:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**************************************************************************************************
  72:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * MACROS
  73:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  **************************************************************************************************
  74:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_PDIV_XTAL_8MHZ (1U)  /* PDIV value for main PLL settings, fPLL = 120MHz with fOSC = 8MH
  75:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_NDIV_XTAL_8MHZ (89U)  /* NDIV value for main PLL settings, fPLL = 120MHz with fOSC = 8M
  76:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_K2DIV_XTAL_8MHZ (2U)  /* K2DIV value for main PLL settings, fPLL = 120MHz with fOSC = 8
  77:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  78:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_PDIV_XTAL_12MHZ (1U)  /* PDIV value for main PLL settings, fPLL = 120MHz with fOSC = 12
  79:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_NDIV_XTAL_12MHZ (79U)  /* NDIV value for main PLL settings, fPLL = 120MHz with fOSC = 1
  80:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_K2DIV_XTAL_12MHZ (3U)  /* K2DIV value for main PLL settings, fPLL = 120MHz with fOSC = 
  81:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  82:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_PDIV_XTAL_16MHZ (1U)  /* PDIV value for main PLL settings, fPLL = 120MHz with fOSC = 16
  83:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_NDIV_XTAL_16MHZ (59U)  /* NDIV value for main PLL settings, fPLL = 120MHz with fOSC = 1
  84:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define PLL_K2DIV_XTAL_16MHZ (3U)  /* K2DIV value for main PLL settings, fPLL = 120MHz with fOSC = 
  85:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
  86:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_WDT_WARN           SCU_INTERRUPT_SRSTAT_PRWARN_Msk /**< Watchdog pr
  87:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RTC_PERIODIC       SCU_INTERRUPT_SRSTAT_PI_Msk     /**< RTC periodi
  88:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RTC_ALARM          SCU_INTERRUPT_SRSTAT_AI_Msk     /**< RTC alarm e
  89:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_DLR_OVERRUN        SCU_INTERRUPT_SRSTAT_DLROVR_Msk /**< DLR overrun
  90:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_LPACCR_Msk)
  91:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_LPACCR_UPDATED     SCU_INTERRUPT_SRSTAT_LPACCR_Msk /**< LPAC Contro
  92:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
  93:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_LPACTH0_Msk)
  94:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_LPACTH0_UPDATED    SCU_INTERRUPT_SRSTAT_LPACTH0_Msk /**< LPAC Thres
  95:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
  96:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_LPACTH1_Msk)
  97:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_LPACTH1_UPDATED    SCU_INTERRUPT_SRSTAT_LPACTH1_Msk  /**< LPAC Thre
  98:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
  99:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_LPACST_Msk)
 100:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_LPACST_UPDATED     SCU_INTERRUPT_SRSTAT_LPACST_Msk  /**< LPAC Statu
 101:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 102:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_LPACCLR_Msk)
 103:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_LPACCLR_UPDATED    SCU_INTERRUPT_SRSTAT_LPACCLR_Msk /**< LPAC event
 104:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 105:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_LPACSET_Msk)
 106:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_LPACSET_UPDATED    SCU_INTERRUPT_SRSTAT_LPACSET_Msk /**< LPAC event
 107:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 108:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_HINTST_Msk)
 109:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_HINTST_UPDATED     SCU_INTERRUPT_SRSTAT_HINTST_Msk /**< HIB HINTST 
 110:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 111:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_HINTCLR_Msk)
 112:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_HINTCLR_UPDATED    SCU_INTERRUPT_SRSTAT_HINTCLR_Msk /**< HIB HINTCL
 113:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 114:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_INTERRUPT_SRSTAT_HINTSET_Msk)
 115:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_HINTSET_UPDATED    SCU_INTERRUPT_SRSTAT_HINTSET_Msk /**< HIB HINTSE
 116:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 117:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_HDSTAT_UPDATED     SCU_INTERRUPT_SRSTAT_HDSTAT_Msk /**< HIB HDSTAT 
 118:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_HDCLR_UPDATED      SCU_INTERRUPT_SRSTAT_HDCLR_Msk /**< HIB HDCLR re
 119:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_HDSET_UPDATED      SCU_INTERRUPT_SRSTAT_HDSET_Msk /**< HIB HDSET re
 120:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_HDCR_UPDATED       SCU_INTERRUPT_SRSTAT_HDCR_Msk /**< HIB HDCR regi
 121:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_OSCSICTRL_UPDATED  SCU_INTERRUPT_SRSTAT_OSCSICTRL_Msk /**< HIB OSCS
 122:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_OSCULSTAT_UPDATED  SCU_INTERRUPT_SRSTAT_OSCULSTAT_Msk /**< HIB OSCU
 123:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_OSCULCTRL_UPDATED  SCU_INTERRUPT_SRSTAT_OSCULCTRL_Msk /**< HIB OSCU
 124:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RTCCTR_UPDATED     SCU_INTERRUPT_SRSTAT_RTC_CTR_Msk /**< HIB RTCCTR
 125:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RTCATIM0_UPDATED   SCU_INTERRUPT_SRSTAT_RTC_ATIM0_Msk /**< HIB RTCA
 126:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RTCATIM1_UPDATED   SCU_INTERRUPT_SRSTAT_RTC_ATIM1_Msk /**< HIB RTCA
 127:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RTCTIM0_UPDATED    SCU_INTERRUPT_SRSTAT_RTC_TIM0_Msk /**< HIB TIM0 
 128:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RTCTIM1_UPDATED    SCU_INTERRUPT_SRSTAT_RTC_TIM1_Msk /**< HIB TIM1 
 129:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #define XMC_SCU_INTERRUPT_EVENT_RMX_UPDATED        SCU_INTERRUPT_SRSTAT_RMX_Msk /**< HIB RMX regist
 130:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 131:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**************************************************************************************************
 132:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * ENUMS
 133:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  **************************************************************************************************
 134:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 135:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines Capture/Compare unit timer slice trigger, that enables synchronous start function avail
 136:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  CCUCON register. Use type \a XMC_SCU_CCU_TRIGGER_t for accessing these enum parameters.
 137:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 138:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CCU_TRIGGER
 139:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 140:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU40)
 141:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CCU_TRIGGER_CCU40 = SCU_GENERAL_CCUCON_GSC40_Msk, /**< Trigger mask used for Global Start
 142:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  CCU40 peripheral. */
 143:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 144:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU41)
 145:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CCU_TRIGGER_CCU41 = SCU_GENERAL_CCUCON_GSC41_Msk, /**< Trigger mask used for Global Start
 146:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  CCU41 peripheral. */
 147:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 148:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU42)
 149:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CCU_TRIGGER_CCU42 = SCU_GENERAL_CCUCON_GSC42_Msk, /**< Trigger mask used for Global Start
 150:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  CCU42 peripheral. */
 151:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 152:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU43)
 153:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CCU_TRIGGER_CCU43 = SCU_GENERAL_CCUCON_GSC43_Msk, /**< Trigger mask used for Global Start
 154:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  CCU43 peripheral. */
 155:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 156:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU80)
 157:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CCU_TRIGGER_CCU80 = SCU_GENERAL_CCUCON_GSC80_Msk, /**< Trigger mask used for Global Start
 158:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  CCU80 peripheral. */
 159:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 160:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU81)
 161:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CCU_TRIGGER_CCU81 = SCU_GENERAL_CCUCON_GSC81_Msk /**< Trigger mask used for Global Start 
 162:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  CCU41 peripheral. */
 163:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 164:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CCU_TRIGGER_t;
 165:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 166:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 167:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines enumerations representing the status of trap cause. The cause of the trap gets automati
 168:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  the \a TRAPSTAT register and can be checked by user software to determine the state of the syst
 169:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  purpose. 
 170:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_TRAP_t for accessing these enum parameters.
 171:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 172:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_TRAP 
 173:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 174:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_OSC_WDG      = SCU_TRAP_TRAPSTAT_SOSCWDGT_Msk, /**< OSC_HP Oscillator Watchdog trap.
 175:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_VCO_LOCK     = SCU_TRAP_TRAPSTAT_SVCOLCKT_Msk, /**< PLL loss of lock trap. */
 176:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_USB_VCO_LOCK = SCU_TRAP_TRAPSTAT_UVCOLCKT_Msk, /**< USB PLL loss of lock trap. */ 
 177:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_PARITY_ERROR = SCU_TRAP_TRAPSTAT_PET_Msk,      /**< Memory Parity error trap. */  
 178:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_BROWNOUT     = SCU_TRAP_TRAPSTAT_BRWNT_Msk,    /**< Brownout trap. */ 
 179:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_ULP_WDG      = SCU_TRAP_TRAPSTAT_ULPWDGT_Msk,  /**< Unstable 32KHz clock trap. */ 
 180:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_PER_BRIDGE0  = SCU_TRAP_TRAPSTAT_BWERR0T_Msk,  /**< Bad memory access of peripherals
 181:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_PER_BRIDGE1  = SCU_TRAP_TRAPSTAT_BWERR1T_Msk,  /**< Bad memory access of peripherals
 182:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_TRAP_TRAPSTAT_TEMPHIT_Msk)
 183:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_DIETEMP_HIGH = SCU_TRAP_TRAPSTAT_TEMPHIT_Msk,  /**< Die temperature higher than expe
 184:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 185:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_TRAP_TRAPSTAT_TEMPLOT_Msk)
 186:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_DIETEMP_LOW  = SCU_TRAP_TRAPSTAT_TEMPLOT_Msk,  /**< Die temperature lower than expec
 187:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 188:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ECAT0)
 189:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_TRAP_ECAT_RESET = SCU_TRAP_TRAPSTAT_ECAT0RST_Msk, /**< EtherCat Reset */ 
 190:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 191:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_TRAP_t;
 192:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 193:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 194:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines enumerations for different parity event generating modules that in turn generate a trap
 195:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Parity can be enabled with \a PETE register in order to get the trap flag reflected in \a TRAPR
 196:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  configure parity error trap generation mechanism bits of \a PETE register.
 197:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  All the enum items are tabulated as per bits present in \a PETE register.
 198:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_PARITY_t for accessing these enum parameters.
 199:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 200:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_PARITY
 201:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 202:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_PSRAM_MEM  = SCU_PARITY_PEEN_PEENPS_Msk,   /**< Program SRAM parity error trap. */
 203:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_DSRAM1_MEM = SCU_PARITY_PEEN_PEENDS1_Msk,  /**< Data SRAM-1 parity error trap. */ 
 204:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(XMC_SCU_PARITY_DSRAM2_MEM)
 205:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_DSRAM2_MEM = SCU_PARITY_PEEN_PEENDS2_Msk,  /**< Data SRAM-2 parity error trap. */ 
 206:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 207:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_USIC0_MEM  = SCU_PARITY_PEEN_PEENU0_Msk,   /**< USIC0 memory parity error trap. */
 208:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(XMC_SCU_PARITY_USIC1_MEM)
 209:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_USIC1_MEM  = SCU_PARITY_PEEN_PEENU1_Msk,   /**< USIC1 memory parity error trap. */
 210:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 211:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(XMC_SCU_PARITY_USIC2_MEM)
 212:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_USIC2_MEM  = SCU_PARITY_PEEN_PEENU2_Msk,   /**< USIC2 memory parity error trap. */
 213:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 214:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_MCAN_MEM   = SCU_PARITY_PEEN_PEENMC_Msk,   /**< CAN memory parity error trap. */
 215:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_PMU_MEM    = SCU_PARITY_PEEN_PEENPPRF_Msk, /**< PMU Prefetch memory parity error t
 216:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_USB_MEM    = SCU_PARITY_PEEN_PEENUSB_Msk,  /**< USB memory parity error trap. */ 
 217:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_PARITY_PEEN_PEENETH0TX_Msk)
 218:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_ETH_TXMEM  = SCU_PARITY_PEEN_PEENETH0TX_Msk, /**< Ethernet transmit memory parity 
 219:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 220:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_PARITY_PEEN_PEENETH0RX_Msk)
 221:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_ETH_RXMEM  = SCU_PARITY_PEEN_PEENETH0RX_Msk, /**< Ethernet receive memory parity e
 222:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 223:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_PARITY_PEEN_PEENSD0_Msk)
 224:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_SDMMC_MEM0 = SCU_PARITY_PEEN_PEENSD0_Msk, /**< SDMMC Memory-0 parity error trap. *
 225:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 226:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SCU_PARITY_PEEN_PEENSD1_Msk)
 227:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PARITY_SDMMC_MEM1 = SCU_PARITY_PEEN_PEENSD1_Msk, /**< SDMMC Memory-1 parity error trap. *
 228:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 229:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_PARITY_t;
 230:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 231:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 232:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines the different causes for last reset. The cause of the last reset gets automatically sto
 233:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  the \a SCU_RSTSTAT register and can be checked by user software to determine the state of the s
 234:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  purpose. All the enum items are tabulated as per bits present in \a SCU_RSTSTAT register.
 235:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_RESET_REASON_t for accessing these enum parameters.
 236:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 237:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_RESET_REASON
 238:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 239:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_RESET_REASON_PORST        = (1UL << SCU_RESET_RSTSTAT_RSTSTAT_Pos), /**< Reset due to Pow
 240:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_RESET_REASON_SWD          = (2UL << SCU_RESET_RSTSTAT_RSTSTAT_Pos), /**< Reset due to Ser
 241:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_RESET_REASON_PV           = (4UL << SCU_RESET_RSTSTAT_RSTSTAT_Pos), /**< Reset due to Pow
 242:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_RESET_REASON_SW           = (8UL << SCU_RESET_RSTSTAT_RSTSTAT_Pos), /**< Reset due to Sof
 243:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_RESET_REASON_LOCKUP       = (16UL << SCU_RESET_RSTSTAT_RSTSTAT_Pos), /**< Reset due to re
 244:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_RESET_REASON_WATCHDOG     = (32UL << SCU_RESET_RSTSTAT_RSTSTAT_Pos), /**< Reset due to Wa
 245:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_RESET_REASON_PARITY_ERROR = (128UL << SCU_RESET_RSTSTAT_RSTSTAT_Pos), /**< Reset due to r
 246:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_RESET_REASON_t;
 247:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 248:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 249:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines enumerations for events which can lead to interrupt. These enumeration values represent
 250:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * status of one of the bits in \a SRSTAT register. 
 251:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_INTERRUPT_EVENT_t for accessing these enum parameters.
 252:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 253:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef uint32_t XMC_SCU_INTERRUPT_EVENT_t;
 254:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 255:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  
 256:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 257:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines enumeration for the events that can generate non maskable interrupt(NMI).
 258:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  The NMI generation can be enabled with \a NMIREQEN register. The event will be reflected in \a 
 259:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  mirrored in the TRAPSTAT register. These enums can be used to configure NMI request generation 
 260:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  NMIREQEN register.  Once configured, these events can generate non maskable interrupt.
 261:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  All the enum items are tabulated as per bits present in \a NMIREQEN register.
 262:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_NMIREQ_t for accessing these enum parameters.
 263:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 264:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_NMIREQ
 265:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 266:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_NMIREQ_WDT_WARN = SCU_INTERRUPT_NMIREQEN_PRWARN_Msk, /**< Watchdog timer Pre-Warning even
 267:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_NMIREQ_RTC_PI   = SCU_INTERRUPT_NMIREQEN_PI_Msk,     /**< RTC Periodic event */ 
 268:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_NMIREQ_RTC_AI   = SCU_INTERRUPT_NMIREQEN_AI_Msk,     /**< RTC Alarm event */ 
 269:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_NMIREQ_ERU0_0   = SCU_INTERRUPT_NMIREQEN_ERU00_Msk,  /**< Channel 0 event of ERU0 */  
 270:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_NMIREQ_ERU0_1   = SCU_INTERRUPT_NMIREQEN_ERU01_Msk,  /**< Channel 1 event of ERU0 */ 
 271:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_NMIREQ_ERU0_2   = SCU_INTERRUPT_NMIREQEN_ERU02_Msk,  /**< Channel 2 event of ERU0 */ 
 272:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_NMIREQ_ERU0_3   = SCU_INTERRUPT_NMIREQEN_ERU03_Msk   /**< Channel 3 event of ERU0 */ 
 273:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_NMIREQ_t;
 274:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   
 275:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 276:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 277:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines enumeration representing different peripheral reset bits in the \a PRSTAT registers.
 278:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  All the enum items are tabulated as per bits present in \a PRSTAT0,  \a PRSTAT1,  \a PRSTAT2,
 279:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  \a PRSTAT3 registers. Use type \a XMC_SCU_PERIPHERAL_RESET_t for accessing these enum parameter
 280:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Note: Release of reset should be prevented when the peripheral clock is gated in cases where ke
 281:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  clock and bus interface clocks are shared, in order to avoid system hang-up.
 282:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 283:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_PERIPHERAL_RESET
 284:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 285:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_VADC   = SCU_RESET_PRSTAT0_VADCRS_Msk,   /**< VADC reset. */ 
 286:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(DSD)
 287:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_DSD    = SCU_RESET_PRSTAT0_DSDRS_Msk,    /**< DSD reset. */
 288:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 289:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_CCU40  = SCU_RESET_PRSTAT0_CCU40RS_Msk,  /**< CCU40 reset. */
 290:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU41)
 291:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_CCU41  = SCU_RESET_PRSTAT0_CCU41RS_Msk,  /**< CCU41 reset. */
 292:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 293:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU42)
 294:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_CCU42  = SCU_RESET_PRSTAT0_CCU42RS_Msk,  /**< CCU42 reset. */
 295:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 296:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU80)
 297:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_CCU80  = SCU_RESET_PRSTAT0_CCU80RS_Msk,  /**< CCU80 reset. */
 298:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 299:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU81)
 300:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_CCU81  = SCU_RESET_PRSTAT0_CCU81RS_Msk,  /**< CCU81 reset. */
 301:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 302:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(POSIF0)
 303:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_POSIF0 = SCU_RESET_PRSTAT0_POSIF0RS_Msk, /**< POSIF0 reset. */
 304:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 305:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(POSIF1)
 306:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_POSIF1 = SCU_RESET_PRSTAT0_POSIF1RS_Msk, /**< POSIF1 reset.*/
 307:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 308:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_USIC0  = SCU_RESET_PRSTAT0_USIC0RS_Msk,  /**< USIC0 reset. */
 309:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_ERU1   = SCU_RESET_PRSTAT0_ERU1RS_Msk,   /**< ERU1 reset. */
 310:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(HRPWM0)
 311:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_HRPWM0 = SCU_RESET_PRSTAT0_HRPWM0RS_Msk,  /**< HRPWM0 reset. */
 312:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 313:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU43)
 314:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_CCU43  = (SCU_RESET_PRSTAT1_CCU43RS_Msk | 0x10000000UL),   /**< CCU43 re
 315:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 316:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(LEDTS0)
 317:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_LEDTS0 = (SCU_RESET_PRSTAT1_LEDTSCU0RS_Msk | 0x10000000UL), /**< LEDTS0 
 318:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 319:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CAN)
 320:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_MCAN   = (SCU_RESET_PRSTAT1_MCAN0RS_Msk | 0x10000000UL), /**< MCAN reset
 321:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 322:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(DAC)  
 323:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_DAC    = (SCU_RESET_PRSTAT1_DACRS_Msk | 0x10000000UL),    /**< DAC reset
 324:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 325:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SDMMC)
 326:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_SDMMC  = (SCU_RESET_PRSTAT1_MMCIRS_Msk | 0x10000000UL),     /**< SDMMC r
 327:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 328:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USIC1)
 329:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_USIC1  = (SCU_RESET_PRSTAT1_USIC1RS_Msk | 0x10000000UL),    /**< USIC1 r
 330:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 331:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USIC2)
 332:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_USIC2  = (SCU_RESET_PRSTAT1_USIC2RS_Msk | 0x10000000UL),    /**< USIC2 r
 333:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 334:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_PORTS  = (SCU_RESET_PRSTAT1_PPORTSRS_Msk | 0x10000000UL),   /**< PORTS r
 335:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_WDT    = (SCU_RESET_PRSTAT2_WDTRS_Msk | 0x20000000UL),      /**< WDT res
 336:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ETH0)
 337:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_ETH0   = (SCU_RESET_PRSTAT2_ETH0RS_Msk | 0x20000000UL),     /**< ETH0 re
 338:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 339:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_GPDMA0 = (SCU_RESET_PRSTAT2_DMA0RS_Msk | 0x20000000UL),     /**< DMA0 re
 340:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(GPDMA1)
 341:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_GPDMA1 = (SCU_RESET_PRSTAT2_DMA1RS_Msk | 0x20000000UL),     /**< DMA1 re
 342:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 343:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(FCE)
 344:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_FCE    = (SCU_RESET_PRSTAT2_FCERS_Msk | 0x20000000UL),      /**< FCE res
 345:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 346:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USB0)  
 347:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_USB0   = (SCU_RESET_PRSTAT2_USBRS_Msk | 0x20000000UL),      /**< USB0 re
 348:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 349:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ECAT0)  
 350:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_ECAT0  = (SCU_RESET_PRSTAT2_ECAT0RS_Msk | 0x20000000UL),      /**< ECAT0
 351:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 352:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(EBU)
 353:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_RESET_EBU    = (SCU_RESET_PRSTAT3_EBURS_Msk | 0x30000000UL)       /**< EBU res
 354:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 355:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_PERIPHERAL_RESET_t;
 356:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 357:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 358:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines enumerations for disabling the clocks sources of peripherals. Disabling of the peripher
 359:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  clock is configured via the \a CLKCLR registers.
 360:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_PERIPHERAL_CLOCK_t for accessing these enum parameters.
 361:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 362:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK
 363:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 364:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_USB = SCU_CLK_CLKCLR_USBCDI_Msk, /**< USB module clock. */
 365:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SDMMC)
 366:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_MMC = SCU_CLK_CLKCLR_MMCCDI_Msk, /**< MMC module clock. */
 367:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 368:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ETH0)
 369:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_ETH = SCU_CLK_CLKCLR_ETH0CDI_Msk, /**< Ethernet module clock. */
 370:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 371:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(EBU)
 372:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_EBU = SCU_CLK_CLKCLR_EBUCDI_Msk, /**< EBU module clock. */
 373:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 374:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_CCU = SCU_CLK_CLKCLR_CCUCDI_Msk, /**< CCU module clock. */
 375:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_WDT = SCU_CLK_CLKCLR_WDTCDI_Msk  /**< WDT module clock. */
 376:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_t;
 377:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 378:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if(UC_SERIES != XMC45)
 379:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 380:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Defines enumeration for peripherals that support clock gating. 
 381:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The enumerations can be used for gating or ungating the peripheral clocks.
 382:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * All the enum items are tabulated as per bits present in \a CGATSTAT0 register.
 383:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Use type \a XMC_SCU_PERIPHERAL_CLOCK_t for accessing these enum parameters.
 384:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 385:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_PERIPHERAL_CLOCK
 386:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 387:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_VADC   = SCU_CLK_CGATSTAT0_VADC_Msk,  /**< VADC peripheral gating. */
 388:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(DSD)
 389:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_DSD    = SCU_CLK_CGATSTAT0_DSD_Msk,   /**< DSD peripheral gating. */
 390:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 391:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_CCU40  = SCU_CLK_CGATSTAT0_CCU40_Msk,  /**< CCU40 peripheral gating. */
 392:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU41)
 393:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_CCU41  = SCU_CLK_CGATSTAT0_CCU41_Msk,  /**< CCU41 peripheral gating. */
 394:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 395:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU42)
 396:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_CCU42  = SCU_CLK_CGATSTAT0_CCU42_Msk,  /**< CCU42 peripheral gating. */
 397:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 398:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU80)
 399:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_CCU80  = SCU_CLK_CGATSTAT0_CCU80_Msk,  /**< CCU80 peripheral gating. */
 400:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 401:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU81)
 402:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_CCU81  = SCU_CLK_CGATSTAT0_CCU81_Msk,  /**< CCU81 peripheral gating. */
 403:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 404:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(POSIF0)
 405:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_POSIF0 = SCU_CLK_CGATSTAT0_POSIF0_Msk,  /**< POSIF0 peripheral gating. *
 406:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 407:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(POSIF1)
 408:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_POSIF1 = SCU_CLK_CGATSTAT0_POSIF1_Msk,   /**< POSIF1 peripheral gating. 
 409:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 410:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_USIC0  = SCU_CLK_CGATSTAT0_USIC0_Msk,   /**< USIC0 peripheral gating. */
 411:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_ERU1   = SCU_CLK_CGATSTAT0_ERU1_Msk,    /**< ERU1 peripheral gating. */
 412:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(HRPWM0)
 413:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_HRPWM0 = SCU_CLK_CGATSTAT0_HRPWM0_Msk,  /**< HRPWM0 peripheral gating. *
 414:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 415:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CCU43)
 416:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_CCU43  = (SCU_CLK_CGATSTAT1_CCU43_Msk | 0x10000000UL),   /**< CCU43 peri
 417:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 418:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(LEDTS0)
 419:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_LEDTS0 = (SCU_CLK_CGATSTAT1_LEDTSCU0_Msk | 0x10000000UL), /**< LEDTS0 pe
 420:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 421:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(CAN)
 422:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_MCAN   = (SCU_CLK_CGATSTAT1_MCAN0_Msk | 0x10000000UL),   /**< MCAN perip
 423:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 424:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(DAC)  
 425:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_DAC    = (SCU_CLK_CGATSTAT1_DAC_Msk | 0x10000000UL),     /**< DAC periph
 426:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 427:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SDMMC)
 428:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_SDMMC  = (SCU_CLK_CGATSTAT1_MMCI_Msk | 0x10000000UL),    /**< SDMMC peri
 429:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 430:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USIC1)
 431:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_USIC1  = (SCU_CLK_CGATSTAT1_USIC1_Msk | 0x10000000UL),   /**< USIC1 peri
 432:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 433:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USIC2)
 434:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_USIC2  = (SCU_CLK_CGATSTAT1_USIC2_Msk | 0x10000000UL),    /**< USIC2 per
 435:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 436:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_PORTS  = (SCU_CLK_CGATSTAT1_PPORTS_Msk | 0x10000000UL),   /**< PORTS per
 437:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_WDT    = (SCU_CLK_CGATSTAT2_WDT_Msk | 0x20000000UL),      /**< WDT perip
 438:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ETH0)
 439:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_ETH0   = (SCU_CLK_CGATSTAT2_ETH0_Msk | 0x20000000UL),     /**< ETH0 peri
 440:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 441:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_GPDMA0 = (SCU_CLK_CGATSTAT2_DMA0_Msk | 0x20000000UL),     /**< DMA0 peri
 442:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(GPDMA1)
 443:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_GPDMA1 = (SCU_CLK_CGATSTAT2_DMA1_Msk | 0x20000000UL),     /**< DMA1 peri
 444:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 445:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(FCE)
 446:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_FCE    = (SCU_CLK_CGATSTAT2_FCE_Msk | 0x20000000UL),      /**< FCE perip
 447:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 448:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USB0)
 449:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_USB0   = (SCU_CLK_CGATSTAT2_USB_Msk | 0x20000000UL),      /**< USB0 peri
 450:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 451:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ECAT0)
 452:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_ECAT0   = (SCU_CLK_CGATSTAT2_ECAT0_Msk | 0x20000000UL),      /**< ECAT0 
 453:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 454:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(EBU)
 455:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_PERIPHERAL_CLOCK_EBU    = (SCU_CLK_CGATSTAT3_EBU_Msk | 0x30000000UL)       /**< EBU perip
 456:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 457:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_PERIPHERAL_CLOCK_t;
 458:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 459:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 460:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 461:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for system clock (fSYS) source. These enums are used to configure \a SYSSEL bit
 462:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Clock Control Register. 
 463:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_CLOCK_SYSCLKSRC_t for accessing these enum parameters.
 464:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */ 
 465:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_SYSCLKSRC
 466:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 467:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSCLKSRC_OFI = (0UL << SCU_CLK_SYSCLKCR_SYSSEL_Pos), /**< Internal Fast Clock (fOF
 468:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for system clock 
 469:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSCLKSRC_PLL = (1UL << SCU_CLK_SYSCLKCR_SYSSEL_Pos)  /**< PLL output (fPLL) as a
 470:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for system clock 
 471:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_SYSCLKSRC_t;
 472:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 473:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 474:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for selecting the P-Divider input frequency. These enums are used to configure 
 475:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  register. 
 476:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_CLOCK_OSCCLKSRC_t for accessing these enum parameters.
 477:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */ 
 478:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_SYSPLLCLKSRC
 479:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 480:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP = 0UL,  /**< External crystal oscillator
 481:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                 (fOHP) as the source for P-Divider. */
 482:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLLCLKSRC_OFI = SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk /**< Ba
 483:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                              as the source for P-Di
 484:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_SYSPLLCLKSRC_t;
 485:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 486:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 487:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Defines options for selecting the USB clock source(fUSB/fSDMMC).
 488:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * These enums are used to configure \a USBSEL bits of \a USBCLKCR
 489:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * register. User can choose either fPLL or fUSBPLL clock as a source for USB clock. 
 490:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Use type \a XMC_SCU_CLOCK_USBCLKSRC_t for accessing these enum parameters.
 491:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */ 
 492:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_USBCLKSRC
 493:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 494:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_USBCLKSRC_USBPLL = (0UL << SCU_CLK_USBCLKCR_USBSEL_Pos), /**< USB PLL(fUSB PLL) as 
 495:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for USB clock (fU
 496:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_USBCLKSRC_SYSPLL = (1UL << SCU_CLK_USBCLKCR_USBSEL_Pos)  /**< Main PLL output (fPLL
 497:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for USB clock (fU
 498:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_USBCLKSRC_t;
 499:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 500:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ECAT0) 
 501:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 502:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Defines options for selecting the ECAT clock source.
 503:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */ 
 504:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_ECATCLKSRC
 505:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 506:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_ECATCLKSRC_USBPLL = (0UL << SCU_CLK_ECATCLKCR_ECATSEL_Pos), /**< USB PLL (fUSBPLL) 
 507:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_ECATCLKSRC_SYSPLL = (1UL << SCU_CLK_ECATCLKCR_ECATSEL_Pos)  /**< Main PLL output (f
 508:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_ECATCLKSRC_t;
 509:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 510:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 511:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 512:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for selecting the source of WDT clock(fWDT). These enums are used to configure 
 513:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  register. User can choose either fOFI or fPLL or fSTDBY clock as a source for WDT clock. 
 514:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_CLOCK_USBCLKSRC_t for accessing these enum parameters.
 515:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */ 
 516:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_WDTCLKSRC
 517:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 518:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_WDTCLKSRC_OFI = (0UL << SCU_CLK_WDTCLKCR_WDTSEL_Pos),  /**< Internal Fast Clock 
 519:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            (fOFI) as the source for
 520:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_WDTCLKSRC_STDBY = (1UL << SCU_CLK_WDTCLKCR_WDTSEL_Pos), /**< Standby clock 
 521:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            (fSTDBY) as the source f
 522:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_WDTCLKSRC_PLL = (2UL << SCU_CLK_WDTCLKCR_WDTSEL_Pos)   /**< PLL output (fPLL) as th
 523:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for WDT clock (fW
 524:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_WDTCLKSRC_t;
 525:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 526:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 527:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for selecting the source of external clock out (fEXT). These enums are used to 
 528:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  register. User can choose either fSYS or fPLL or fUSBPLL clock as a source for external clock o
 529:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_CLOCK_EXTOUTCLKSRC_t for accessing these enum parameters.
 530:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */ 
 531:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_EXTOUTCLKSRC
 532:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 533:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_EXTOUTCLKSRC_SYS = (0UL << SCU_CLK_EXTCLKCR_ECKSEL_Pos),  /**< System clock (fSYS) 
 534:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                             the source for external
 535:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_EXTOUTCLKSRC_USB = (2UL << SCU_CLK_EXTCLKCR_ECKSEL_Pos), /**< USB PLL output(fUSB P
 536:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for external cloc
 537:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_EXTOUTCLKSRC_PLL = (3UL << SCU_CLK_EXTCLKCR_ECKSEL_Pos), /**< Main PLL output(fPLL)
 538:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for external cloc
 539:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if ((UC_SERIES == XMC42) || (UC_SERIES == XMC41))
 540:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_EXTOUTCLKSRC_STDBY = (4UL << SCU_CLK_EXTCLKCR_ECKSEL_Pos), /**< Standby clock(fSTDB
 541:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            source for external cloc
 542:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 543:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_EXTOUTCLKSRC_t;
 544:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 545:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 546:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for selecting the source of RTC Clock (fRTC). These enums are used to configure
 547:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  User can choose either fOSI or fULP clock as a source for RTC Clock (fRTC).
 548:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_HIB_RTCCLKSRC_t for accessing these enum parameters.
 549:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 550:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_HIB_RTCCLKSRC
 551:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 552:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_HIB_RTCCLKSRC_OSI = (0UL << SCU_HIBERNATE_HDCR_RCS_Pos), /**< Internal Slow Clock
 553:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                          (fOSI) as the source for R
 554:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_HIB_RTCCLKSRC_ULP = (1UL << SCU_HIBERNATE_HDCR_RCS_Pos) /**< Ultra Low Power Clock (fULP)
 555:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                         as the source for RTC Clock
 556:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_HIB_RTCCLKSRC_t;
 557:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 558:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 559:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for selecting the source of Standby Clock (fSTDBY). These enums are used to con
 560:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  register. User can choose either fOSI or fULP clock as a source for Standby Clock (fSTDBY).
 561:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_HIB_STDBYCLKSRC_t for accessing these enum parameters.
 562:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 563:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_HIB_STDBYCLKSRC
 564:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 565:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_HIB_STDBYCLKSRC_OSI = (0UL << SCU_HIBERNATE_HDCR_STDBYSEL_Pos), /**< Internal Slow Clock 
 566:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                           (fOSI) as the source for 
 567:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                           (fSTDBY). */
 568:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_HIB_STDBYCLKSRC_OSCULP = (1UL << SCU_HIBERNATE_HDCR_STDBYSEL_Pos) /**< Ultra Low Power Cl
 569:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                           (fULP) as the source for 
 570:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                           (fSTDBY). */
 571:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_HIB_STDBYCLKSRC_t;
 572:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 573:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 574:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for backup clock trimming. These enums are used to configure \a AOTREN  \a FOTR
 575:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  PLLCON0 register. Use type \a XMC_SCU_CLOCK_BACKUP_TRIM_t for accessing these enum parameters.
 576:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 577:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE
 578:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 579:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_FACTORY   = 0UL,  /**< Factory Oscillator Calibration: 
 580:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                         Force adjustment of the internal oscillator
 581:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC = 1UL   /**<  Automatic Oscillator Calibration adju
 582:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t;
 583:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 584:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 585:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 586:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines options for selecting device boot mode. These enums are used to configure \a SWCON bits
 587:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  User can choose among various boot modes by configuring SWCON bits.
 588:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_BOOTMODE_t for accessing these enum parameters.
 589:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 590:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_BOOTMODE 
 591:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 592:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_NORMAL     = (0UL << SCU_GENERAL_STCON_SWCON_Pos), /**< Boot from start of flash
 593:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_ASC_BSL    = (1UL << SCU_GENERAL_STCON_SWCON_Pos), /**< UART bootstrap. */
 594:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_BMI        = (2UL << SCU_GENERAL_STCON_SWCON_Pos), /**< Boot Mode Index - Custom
 595:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            sequence. */
 596:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_CAN_BSL    = (3UL << SCU_GENERAL_STCON_SWCON_Pos), /**< CAN bootstrap. */
 597:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_PSRAM_BOOT = (4UL << SCU_GENERAL_STCON_SWCON_Pos), /**< Boot from PSRAM. */
 598:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_ABM0       = (8UL << SCU_GENERAL_STCON_SWCON_Pos), /**< Boot from flash - fixed 
 599:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                            address 0. */
 600:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_ABM1       = (12UL << SCU_GENERAL_STCON_SWCON_Pos), /**< Boot from flash - fixed
 601:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                             address 1. */
 602:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_BOOTMODE_FABM       = (14UL << SCU_GENERAL_STCON_SWCON_Pos), /**< fallback Alternate Boot
 603:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                             Try ABM-0 then try ABM-
 604:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_BOOTMODE_t;
 605:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 606:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 607:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 608:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines various PLL modes of operation. These enums are used to configure \a VCOBYP bit of \a P
 609:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  User can choose either normal or prescalar mode by configuring VCOBYP bit.
 610:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_PLL_MODE_t for accessing these enum parameters.
 611:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 612:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_SYSPLL_MODE
 613:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 614:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLL_MODE_DISABLED, /**< fPLL derived from fOSC and PLL operating in prescalar mo
 615:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL,  /**< fPLL derived from fVCO and PLL operating in normal mode. 
 616:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLL_MODE_PRESCALAR /**< fPLL derived from fOSC and PLL operating in prescalar mo
 617:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_SYSPLL_MODE_t;
 618:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 619:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 620:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 621:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 622:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_SLEEP_MODE_CONFIG
 623:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 624:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_SYSCLK_FOFI = 0,  //!< XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_SYSCLK_FOF
 625:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_SYSCLK_FPLL = SCU_CLK_SLEEPCR_SYSSEL_Msk,  //!< XMC_SCU_CLOCK_SLE
 626:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USB0)
 627:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_USB = SCU_CLK_SLEEPCR_USBCR_Msk,  //!< XMC_SCU_CLOCK_SLEE
 628:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 629:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SDMMC)
 630:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_SDMMC = SCU_CLK_SLEEPCR_MMCCR_Msk,//!< XMC_SCU_CLOCK_SLEE
 631:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 632:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ETH0)
 633:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_ETH = SCU_CLK_SLEEPCR_ETH0CR_Msk,  //!< XMC_SCU_CLOCK_SLE
 634:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 635:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(EBU)
 636:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_EBU = SCU_CLK_SLEEPCR_EBUCR_Msk,  //!< XMC_SCU_CLOCK_SLEE
 637:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 638:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_CCU = SCU_CLK_SLEEPCR_CCUCR_Msk,  //!< XMC_SCU_CLOCK_SLEE
 639:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_DISABLE_WDT = SCU_CLK_SLEEPCR_WDTCR_Msk,  //!< XMC_SCU_CLOCK_SLEE
 640:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_SLEEP_MODE_CONFIG_t;
 641:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 642:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 643:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 644:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 645:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef enum XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG
 646:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 647:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_SYSCLK_FOFI = 0,  //!< XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_SY
 648:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_SYSCLK_FPLL = SCU_CLK_SLEEPCR_SYSSEL_Msk,  //!< XMC_SCU_CLOCK
 649:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_FLASH_POWERDOWN = SCU_CLK_DSLEEPCR_FPDN_Msk,//!< XMC_SCU_CLOC
 650:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_PLL_POWERDOWN = SCU_CLK_DSLEEPCR_PLLPDN_Msk,  //!< XMC_SCU_CL
 651:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_VCO_POWERDOWN = SCU_CLK_DSLEEPCR_VCOPDN_Msk,  //!< XMC_SCU_CL
 652:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(USB0)
 653:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_USB = SCU_CLK_SLEEPCR_USBCR_Msk,  //!< XMC_SCU_CLOCK_
 654:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 655:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(SDMMC)
 656:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_SDMMC = SCU_CLK_SLEEPCR_MMCCR_Msk,//!< XMC_SCU_CLOCK_
 657:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 658:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ETH0)
 659:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_ETH = SCU_CLK_SLEEPCR_ETH0CR_Msk,  //!< XMC_SCU_CLOCK
 660:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 661:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(EBU)
 662:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_EBU = SCU_CLK_SLEEPCR_EBUCR_Msk,  //!< XMC_SCU_CLOCK_
 663:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif  
 664:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_CCU = SCU_CLK_SLEEPCR_CCUCR_Msk,  //!< XMC_SCU_CLOCK_
 665:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_DISABLE_WDT = SCU_CLK_SLEEPCR_WDTCR_Msk,  //!< XMC_SCU_CLOCK_
 666:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_DEEPSLEEP_MODE_CONFIG_t;
 667:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 668:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 669:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**************************************************************************************************
 670:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * DATA STRUCTURES
 671:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  **************************************************************************************************
 672:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 673:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 674:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines a data structure for initializing the PLL functional block.
 675:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Structure holds divider values for N-DIV, P-DIV, K1-DIV, K2-DIV in order to generate desired 
 676:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  frequency using VCO. It holds the PLL mode of operation either normal or prescaler (VCO bypasse
 677:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_CLOCK_PLL_CONFIG_t for accessing these structure parameters.
 678:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 679:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef struct XMC_SCU_CLOCK_SYSPLL_CONFIG
 680:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 681:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   uint8_t n_div;                       /**<  PLL N-Divider value. */
 682:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   uint8_t p_div;                       /**<  PLL P-Divider value. */
 683:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   uint8_t k_div;                       /**<  K1-Divider(Prescalar mode) or K2-Divider (Normal mode)
 684:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLL_MODE_t mode;    /**<  PLL mode of operation. */
 685:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLLCLKSRC_t clksrc; /**<  PLL divider input frequency. */
 686:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } XMC_SCU_CLOCK_SYSPLL_CONFIG_t;
 687:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 688:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 689:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Defines a data structure used for initializing the clock functional block.
 690:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Clock functional block configures clock source needed for various peripheral and its divider va
 691:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *  Use type \a XMC_SCU_CLOCK_CONFIG_t for accessing these structure parameters.
 692:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 693:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** typedef struct XMC_SCU_CLOCK_CONFIG
 694:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 695:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSPLL_CONFIG_t         syspll_config;      /**< PLL configuration */
 696:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   bool                                  enable_oschp;       /**< Enable external high precision osc
 697:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  Should be enabled when fOHP has to
 698:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   bool                                  enable_osculp;      /**< Enable external ultra low power os
 699:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                                                                  Should be enabled when fULP has to
 700:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t calibration_mode;   /**< Backup clock trimming mode. */
 701:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_HIB_STDBYCLKSRC_t             fstdby_clksrc;      /**< Standby clock source. */
 702:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   XMC_SCU_CLOCK_SYSCLKSRC_t             fsys_clksrc;        /**< Choice of system clock. */
 703:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   uint8_t                               fsys_clkdiv;        /**< Ratio of fPLL to fSYS. */
 704:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   uint8_t                               fcpu_clkdiv;        /**< Ratio of fSys to fCPU. */
 705:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   uint8_t                               fccu_clkdiv;        /**< Ratio of fSys to fCCU. */
 706:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   uint8_t                               fperipheral_clkdiv; /**< Ratio of fSYS to fPERI. */
 707:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** } const XMC_SCU_CLOCK_CONFIG_t;
 708:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 709:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 710:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**************************************************************************************************
 711:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * API PROTOTYPES
 712:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  **************************************************************************************************
 713:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 714:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #ifdef __cplusplus
 715:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** extern "C" {
 716:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 717:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 718:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 719:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * 
 720:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param group   ADC Group to which the channel being monitored belongs to.\n
 721:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                 \b Range: 0 or 1.
 722:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param channel  The channel whose voltage range has to be monitored.\n
 723:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                 \b Range: 6 or 7. Value identifies the channel in the selected ADC group.
 724:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 725:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
 726:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 727:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 728:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables out of range comparator for the selected ADC group and channel. \n\n
 729:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The ADC channel input is compared by Out of Range Comparator (ORC) for overvoltage monitoring
 730:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * or for detection of out of range analog inputs. ORC must be turned on explicitly
 731:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * to leverage the auditing feature. ORC is enabled by setting the enable bit in the GORCEN registe
 732:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 733:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_DisableOutOfRangeComparator()\n\n\n
 734:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 735:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_EnableOutOfRangeComparator(const uint32_t group, const uint32_t channel);
 736:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 737:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 738:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * 
 739:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param group   ADC Group to which the channel being monitored belongs to.\n
 740:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                 \b Range: 0 or 1.
 741:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param channel  The channel whose voltage range has to be monitored.\n
 742:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                 \b Range: 6 or 7. Value identifies the channel in the selected ADC group.
 743:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 744:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
 745:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 746:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 747:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables the out of range comparator for the selected ADC group and the channel. \n\n
 748:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Out of range comparator is disabled by clearing the enable bit in the GORCEN register.
 749:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 750:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_EnableOutOfRangeComparator()\n\n\n
 751:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 752:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_DisableOutOfRangeComparator(const uint32_t group, const uint32_t channel);
 753:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 754:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 755:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
 756:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 757:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 758:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables die temperature measurement by powering the DTS module.\n\n
 759:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Die temperature sensor is enabled by setting the PWD bit of DTSCON register.
 760:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 761:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_DisableTemperatureSensor(), XMC_SCU_IsTemperatureSensorEnabled(), XMC_SCU_CalibrateTempe
 762:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_StartTemperatureMeasurement(), XMC_SCU_GetTemperatureMeasurement() \n\n\n
 763:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 764:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_EnableTemperatureSensor(void);
 765:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 766:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 767:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
 768:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 769:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 770:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables die temperature measurement by powering the DTS module off.\n\n
 771:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Die temperature sensor is disabled by clearing the PWD bit of DTSCON register.
 772:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 773:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_EnableTemperatureSensor(), XMC_SCU_IsTemperatureSensorEnabled(), XMC_SCU_CalibrateTemper
 774:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_StartTemperatureMeasurement(), XMC_SCU_GetTemperatureMeasurement() \n\n\n
 775:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 776:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_DisableTemperatureSensor(void);
 777:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 778:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 779:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return Status of die temperature sensor. \n
 780:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: true - if temperature sensor is enabled.\n
 781:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    false - if temperature sensor is disabled.
 782:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 783:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 784:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the die temperature sensor power status.\n\n
 785:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The status is obtained by reading the PWD bit of DTSCON register.
 786:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 787:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_EnableTemperatureSensor(), XMC_SCU_CalibrateTemperatureSensor(),
 788:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_StartTemperatureMeasurement(), XMC_SCU_GetTemperatureMeasurement() \n\n\n
 789:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 790:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** bool XMC_SCU_IsTemperatureSensorEnabled(void);
 791:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 792:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 793:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 794:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param offset  Offset value for calibrating the DTS result.\n
 795:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                \b Range: 0 to 127.
 796:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param gain    Gain value for calibrating the DTS conversion result.\n
 797:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                \b Range: 0 to 63.
 798:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 799:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
 800:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 801:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 802:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Calibrates the measurement of temperature by configuring the values of offset and gain of \a DTS
 803:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Allows to improve the accuracy of the temperature measurement with the adjustment of \a OFFSET a
 804:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * in the \a DTSCON register.
 805:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Offset adjustment is defined as a shift of the conversion result. The range of the offset adjust
 806:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * resolution that corresponds to +/- 12.5C. The offset value gets added to the measure result. 
 807:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Offset is considered as a signed value.
 808:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Gain adjustment helps in minimizing gain error. When the \a gain value is 0, result is generated
 809:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * When the \a gain value is 63, result is generated with least gain, i.e, \a RESULT - 63 at the hi
 810:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps:\n
 811:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_StopTempMeasurement to stop temperature measurement if it was started previous
 812:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_CalibrateTempMonitor with desired offset and gain calibration values to the DT
 813:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_SetRawTempLimits with desired lower and upper temperature threshold limit valu
 814:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_StartTempMeasurement to start temperature measurement.\n
 815:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Check whether Die Temperature Sensor (DTS) is busy in conversion by calling \a XMC_SCU_IsTempe
 816:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * conversion complete.\n
 817:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Read the die temperature value using \a XMC_SCU_GetTemperatureMeasurement API.
 818:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 819:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_EnableTemperatureSensor(),
 820:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_StartTemperatureMeasurement(), XMC_SCU_GetTemperatureMeasurement() \n\n\n
 821:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 822:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CalibrateTemperatureSensor(uint32_t offset, uint32_t gain);
 823:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 824:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 825:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_STATUS_t  Result of starting the temperature measurement.\n
 826:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                           \b Range: \n 
 827:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                              XMC_SCU_STATUS_OK if the measurement is started successfully.\n
 828:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                              XMC_SCU_STATUS_ERROR if temperature sensor is not enabled.\n
 829:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                              XMC_SCU_STATUS_BUSY if temperature sensor is busy measuring the tem
 830:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 831:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 832:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 833:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Starts die temperature measurement using internal temperature sensor.\n\n
 834:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API checks if the temperature sensor is enabled and is not busy in measurement.\n
 835:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps:\n
 836:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_StopTempMeasurement to stop temperature measurement if it was started previous
 837:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_SetRawTempLimits with desired lower and upper temperature threshold limit valu
 838:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_StartTempMeasurement to start temperature measurement.\n
 839:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Check whether Die Temperature Sensor (DTS) is busy in conversion by calling \a XMC_SCU_IsTempe
 840:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * conversion complete.\n
 841:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Read the die temperature value using \a XMC_SCU_GetTemperatureMeasurement API.
 842:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 843:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_EnableTemperatureSensor(), XMC_SCU_CalibrateTemperatureSensor(),
 844:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_GetTemperatureMeasurement() \n\n\n
 845:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 846:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** XMC_SCU_STATUS_t XMC_SCU_StartTemperatureMeasurement(void);
 847:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 848:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 849:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 850:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 851:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Measured temperature value.\n
 852:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: Valid temperature range is 0 to 1023. \n
 853:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              If sensor is not enabled, 0x7FFFFFFFH is returned.
 854:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 855:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 856:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Reads the measured value of die temperature.\n\n
 857:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Temperature measurement result is read from \a RESULT bit field of \a DTSSTAT register.
 858:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The temperature measured in C is given by (RESULT - 605) / 2.05 [C]
 859:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 860:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_IsTemperatureSensorBusy() \n\n\n
 861:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 862:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_GetTemperatureMeasurement(void);
 863:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 864:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 865:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return bool  Indicates if the die temperature sensor is busy.\n
 866:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    \b Range: \a true if sensor is busy in temperature measurement.
 867:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    \a false if sensor is free and can accept a new request for measurement.
 868:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 869:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 870:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Checks whether Die Temperature Sensor (DTS) is busy in temperature measurement.\n\n
 871:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The status is read from the \a BUSY bit field of the \a DTSSTAT register.
 872:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 873:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_GetTemperatureMeasurement() \n\n\n
 874:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 875:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** bool XMC_SCU_IsTemperatureSensorBusy(void);
 876:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 877:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 878:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return bool Status of die temperature sensor whether it is ready to start measurement. \n
 879:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: \n \a true if temperature sensor is ready to start measurement. \n
 880:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \a false if temperature sensor is not ready to start measurement.
 881:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 882:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 883:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Checks if the die temperature sensor is ready to start a measurement\n\n
 884:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The status is obtained by reading \a RDY bit of \a DTSSTAT register. It is recommended
 885:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * to check the ready status of die temperature sensor before starting it.
 886:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 887:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_StartTemperatureMeasurement(), XMC_SCU_IsTemperatureSensorBusy() \n\n\n
 888:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 889:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** bool XMC_SCU_IsTemperatureSensorReady(void);
 890:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 891:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if (UC_SERIES != XMC45)
 892:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 893:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return bool  Indicates if the measured die temperature value has exceeded the configured upper 
 894:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: \a true if the temperature value has exceeded the configured upper limit.
 895:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              if the temperature value is less than the configured upper limit.
 896:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 897:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 898:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Checks if the measured temperature has exceeded the configured upper limit of temperature.\n\n
 899:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API checks \a OVERFL bit (Upper Limit Overflow Status bit) of \a DTEMPALARM register.
 900:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The \a OVERFL bit will be set if the measured temperature has exceeded the limit configured in 
 901:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the bitfield \a UPPER in the \a DTEMPLIM register.
 902:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 903:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_SetRawTempLimits(),XMC_SCU_LowTemperature() \n\n\n
 904:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 905:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** bool XMC_SCU_HighTemperature(void);
 906:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 907:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 908:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 909:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param lower_temp  Lower threshold of die temperature. If measured temperature falls below this 
 910:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    alarm bit will be set in \a UNDERFL bit field of \a DTEMPALARM register.
 911:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param upper_temp  Upper threshold of die temperature. If measured temperature exceeds this valu
 912:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    alarm bit will be set in \a OVERFL bit field of \a DTEMPALARM register.
 913:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 914:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
 915:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 916:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 917:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the lower and upper threshold of die temperature.\n\n
 918:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * API configures \a DTEMPLIM register for upper and lower die temperature threshold limits.
 919:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * When the measured temperature is outside the range defined by the limits, alarm bits \a UNDERFL 
 920:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * will be set in the register \a DTEMPALARM.\n
 921:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps:\n
 922:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_StopTempMeasurement to stop temperature measurement if it was started previous
 923:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_SetRawTempLimits with desired lower and upper temperature threshold limit valu
 924:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_StartTempMeasurement to start temperature measurement.\n
 925:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Use \a XMC_SCU_HighTemperature() and XMC_SCU_LowTemperature() to monitor the temperature.\n
 926:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 927:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_HighTemperature(), XMC_SCU_LowTemperature() \n\n\n
 928:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 929:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_SetRawTempLimits(const uint32_t lower_temp, const uint32_t upper_temp);
 930:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 931:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 932:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return bool  Indicates if the measured die temperature value has dropped below the configured l
 933:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: \a true if the temperature value has dropped below the configured lower l
 934:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              if the temperature value is higher than the configured lower limit.
 935:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 936:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 937:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Checks if the measured temperature has dropped below the configured lower limit of temperature.\
 938:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API checks \a UNDERFL bit (Lower LimitUnderflow Status bit) of \a DTEMPALARM register.
 939:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The \a UNDERFL bit will be set if the measured temperature has dropped below the limit configure
 940:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the bitfield \a LOWER in the \a DTEMPLIM register.
 941:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 942:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_SetRawTempLimits(),XMC_SCU_HighTemperature() \n\n\n
 943:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 944:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** bool XMC_SCU_LowTemperature(void);
 945:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
 946:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 947:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 948:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t Configured boot mode for the device.\n
 949:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_BOOTMODE_t for enumeration of different boot modes.
 950:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 951:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 952:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the boot mode configured for the device.\n\n
 953:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The boot mode is read from the \a STCON register bit field \a SWCON.
 954:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 955:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 956:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_SetBootMode() \n\n\n
 957:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 958:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_GetBootMode(void);
 959:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 960:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 961:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 962:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param mode Boot mode to be configured for the device.\n
 963:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_BOOTMODE_t for selecting the boot mode.
 964:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 965:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
 966:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 967:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 968:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the desired boot mode for the device.\n\n
 969:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The XMC4 series devices support multiple boot modes. A running application can set a desired boo
 970:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * launch it by means of software reset. Switching of boot modes should be handled carefully. User 
 971:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the initial boot sequence is executed. A stable execution environment should be maintained when 
 972:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * eventually handed over to the application program.\n
 973:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps to launch requested bootmode:\n
 974:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_SetBootMode() with desired boot mode value.\n
 975:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Trigger a software reset using system reset request by enabling a bit \a SYSRESETREQ of AIRCR 
 976:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *   (PPB->AIRCR |= PPB_AIRCR_SYSRESETREQ_Msk).\n
 977:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 978:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_GetBootMode() \n\n\n
 979:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 980:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_SetBootMode(const XMC_SCU_BOOTMODE_t mode);
 981:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
 982:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 983:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 984:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param index  The SCU general purpose register to be read.\n
 985:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: 0 and 1 corresponding to GPR0 and GPR1.
 986:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 987:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Data read from the selected general purpose register.
 988:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
 989:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
 990:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides stored data from general purpose SCU register.\n\n
 991:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * SCU consists of 2 general purpose registers. These registers can be used for storing
 992:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * data. The API reads from either GPR0 or GPR1 based on the \a index value.
 993:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
 994:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_WriteGPR()\n\n\n
 995:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
 996:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_ReadGPR(const uint32_t index);
 997:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  
 998:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
 999:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1000:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param index  The SCU general purpose register to be written.\n
1001:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: 0 and 1 corresponding to GPR0 and GPR1.
1002:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param data  Data to be written to the selected general purpose register.
1003:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1004:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1005:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1006:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1007:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Stores data in the selected general purpose SCU register.\n\n
1008:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * SCU consists of 2 general purpose registers. These registers can be used for storing
1009:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * data. The API writes data to either GPR0 or GPR1 based on the \a index value.
1010:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1011:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_ReadGPR()\n\n\n
1012:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1013:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_WriteGPR(const uint32_t index, const uint32_t data);
1014:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1015:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1016:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1017:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param address  Location in the retention memory to be written.\n
1018:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: 4 bit address space is provided for selecting 16 words of 32 bits.
1019:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  equivalent to 64 bytes of data. \a address value should be from
1020:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  0 to 15.
1021:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param data    32 bit data to be written into retention memory. The API writes
1022:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                one word(4 bytes) of data to the address specified.\n
1023:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                \b Range: 32 bit data.
1024:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1025:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1026:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1027:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1028:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Writes input data to the selected address of Retention memory in hibernate domain.\n\n
1029:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The retention memory is located in hibernate domain. 
1030:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is used for the purpose of store/restore of context information.
1031:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Access to the retention memory space is served over shared serial interface. 
1032:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Retention memory content is retained even in hibernate mode.
1033:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1034:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_ReadFromRetentionMemory() \n\n\n
1035:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1036:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_WriteToRetentionMemory(uint32_t address, uint32_t data);
1037:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1038:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1039:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1040:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param address  Location in the retention memory to be read.\n
1041:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: 4 bit address space is provided for selecting 16 words of 32 bits.
1042:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  equivalent to 64 bytes of data. \a address value should be from
1043:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  0 to 15.
1044:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1045:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  32 bit data read from retention memory. The API reads
1046:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                one word(4 bytes) of data from the address specified.\n
1047:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                \b Range: 32 bit data.
1048:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1049:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1050:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Reads data from selected address of retention memory in hibernate domain.\n\n
1051:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The retention memory is located in hibernate domain. 
1052:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is used for the purpose of store/restore of context information.
1053:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Access to the retention memory space is served over shared serial interface. 
1054:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Retention memory content is retained even in hibernate mode.
1055:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1056:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_WriteToRetentionMemory() \n\n\n
1057:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1058:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_ReadFromRetentionMemory(uint32_t address);
1059:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1060:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1061:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1062:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param request  Non-maskable interrupt (NMI) request source to be enabled.\n
1063:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: Use type @ref XMC_SCU_NMIREQ_t for selecting the source of NMI. Multiple 
1064:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              sources can be combined using \a OR operation.
1065:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1066:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1067:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1068:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1069:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selectively enables interrupt sources to generate non maskable interrupt(NMI).\n\n
1070:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * NMI assertion can be individually enabled by setting corresponding bit of an interrupt in the 
1071:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \a NMIREQEN register.
1072:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1073:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_INTERRUPT_DisableNmiRequest() \n\n\n
1074:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1075:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_INTERRUPT_EnableNmiRequest(const uint32_t request);
1076:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1077:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1078:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1079:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param request  Non-maskable interrupt (NMI) request source to be disabled.\n
1080:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: Use type @ref XMC_SCU_NMIREQ_t for selecting the source of NMI. Multiple 
1081:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              sources can be combined using \a OR operation.
1082:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1083:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1084:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1085:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1086:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selectively disables interrupt sources from generating non maskable interrupt(NMI).\n\n
1087:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * NMI assertion can be individually disabled by clearing corresponding bits in the \a NMIREQEN reg
1088:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1089:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_INTERRUPT_EnableNmiRequest() \n\n\n
1090:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1091:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_INTERRUPT_DisableNmiRequest(const uint32_t request);
1092:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1093:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1094:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1095:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param trap  The event for which, trap generation has to be enabled.\n
1096:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_TRAP_t to identify the event.
1097:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1098:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1099:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1100:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1101:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables assertion of trap for the selected trap event.\n\n
1102:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Trap assertion can be individually enabled by clearing respective bit of the 
1103:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * event in \a TRAPDIS register in order to get an exception.
1104:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1105:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_TRAP_Disable(), XMC_SCU_TRAP_ClearStatus(), XMC_SCU_TRAP_GetStatus() \n\n\n
1106:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1107:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_TRAP_Enable(const uint32_t trap);
1108:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1109:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1110:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1111:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param trap  The event for which, trap generation has to be disabled.\n
1112:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_TRAP_t to identify the event.
1113:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1114:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1115:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1116:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1117:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables assertion of trap for the selected trap event.\n\n
1118:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Trap assertion can be individually disabled by setting the respective event bit 
1119:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * in the \a TRAPDIS register in order to suppress trap generation.
1120:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1121:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_TRAP_Enable(), XMC_SCU_TRAP_ClearStatus(), XMC_SCU_TRAP_GetStatus() \n\n\n
1122:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1123:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_TRAP_Disable(const uint32_t trap);
1124:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1125:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1126:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1127:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param trap  The event for which, trap status bit has to be cleared.\n
1128:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_TRAP_t to identify the event.
1129:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1130:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1131:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1132:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1133:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Clears the trap status of input event.\n\n
1134:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Once a trap event is detected, it will have to be acknowledged and later serviced. 
1135:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The trap status bit should be cleared to detect the occurence of trap next time. 
1136:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * This is useful while polling for TRAPSTAT without enabling the NMI for trap.
1137:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Trap status can be cleared by setting the event bit in the \a TRAPCLR register.
1138:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1139:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_INTERRUPT_EnableNmiRequest(), XMC_SCU_TRAP_GetStatus() \n\n\n
1140:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1141:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_TRAP_ClearStatus(const uint32_t trap);
1142:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1143:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1144:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Status of trap generating events.\n
1145:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_TRAP_t to identify the event. The returned
1146:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * value indicates the status of multiple events at their respective bit positions.
1147:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * User should mask the bits of the events of interest using the type specified.
1148:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1149:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1150:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the status of trap generating events. \n\n
1151:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The status is read from \a TRAPRAW register. Status of the specific events can be checked
1152:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * using their respective bits in the \a TRAPRAW register. The bit masks can be obtained from
1153:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the enumeration type @ref XMC_SCU_TRAP_t. Multiple events can be combined using \a OR operation.
1154:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * A trap event is considered to be asserted if the respective bit of the event is set to 1.
1155:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1156:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_INTERRUPT_EnableNmiRequest(), XMC_SCU_TRAP_ClearStatus() \n\n\n
1157:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1158:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_TRAP_GetStatus(void);  
1159:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1160:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1161:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1162:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param trap  The event for which, trap has to be triggered.\n
1163:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_TRAP_t to identify the event.
1164:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1165:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1166:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1167:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1168:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Triggers trap generation for the event specified. \n\n
1169:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The trap source has to be enabled before invocation of this API. 
1170:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Trap event can be triggered by setting its respective bit in the \a TRAPSET register.
1171:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Trap event can be configured to generate a non maskable interrupt by using the API XMC_SCU_INTER
1172:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps to manually assert a trap event:\n
1173:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_TRAP_EnableEvent with desired trap request source ID.\n
1174:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_TRAP_SetEvent with same trap request source ID to manually assert a trap event
1175:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1176:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_INTERRUPT_EnableNmiRequest(), XMC_SCU_TRAP_GetStatus() \n\n\n
1177:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1178:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_TRAP_Trigger(const uint32_t trap);
1179:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1180:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1181:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1182:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param peripheral  The peripheral to be reset.\n
1183:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Type @ref XMC_SCU_PERIPHERAL_RESET_t enumerates all the peripherals that can be
1184:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1185:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1186:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1187:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1188:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Puts the specified peripheral in to reset state. \n\n
1189:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API achieves reset of peripherals by setting the respective bit in the \a PRSET0,  \a PRSET1
1190:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * register. Status of reset assertion automatically stored in the \a PRSTATn register and can be c
1191:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * user software to determine the state of the system and for debug purpose.\n
1192:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps to assert a peripheral reset:\n
1193:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_RESET_AssertPeripheralReset() with desired peripheral identifier.\n
1194:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_RESET_IsPeripheralResetAsserted with same peripheral identifier to verify whet
1195:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * is in reset state.\n
1196:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1197:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_RESET_IsPeripheralResetAsserted() \n\n\n
1198:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1199:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_RESET_AssertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral);
1200:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1201:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1202:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1203:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param peripheral  The peripheral to be moved out of reset state.\n
1204:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Type @ref XMC_SCU_PERIPHERAL_RESET_t enumerates all the peripherals that can be
1205:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1206:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1207:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1208:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1209:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables the specified peripheral by moving it out of reset state.  \n\n
1210:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Any peripheral should be moved out of reset state for executing its functionality.
1211:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API enables the peripheral by setting its respective bit in the \a PRCLR0,  \a PRCLR1 or  \a
1212:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * register. Status of reset deassertion is automatically stored in the \a PRSTATn register and can
1213:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the user software to determine the state of the system and for debug purpose.\n
1214:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps to deassert a peripheral reset:\n
1215:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_RESET_DeassertPeripheralReset() with desired peripheral identifier.\n
1216:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_RESET_IsPeripheralResetAsserted() with desired peripheral identifier to verify
1217:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * has been enabled.\n
1218:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1219:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_RESET_AssertPeripheralReset() \n\n\n
1220:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1221:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral);
1222:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1223:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1224:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1225:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param peripheral  The peripheral, whose reset status has to be checked.\n
1226:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Type @ref XMC_SCU_PERIPHERAL_RESET_t enumerates all the peripherals.
1227:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1228:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return bool  Status of peripheral reset. \n
1229:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *               \b Range: \a true if peripheral is in reset state. \a false if peripheral is enabl
1230:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1231:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1232:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Checks the reset status of the selected peripheral.\n\n
1233:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API reads the reset status from \a PRSTATn register. Returns true if the peripheral is in
1234:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * reset state. On power up of the device, all the peripherals will be in reset state. 
1235:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If the peripheral is enabled, \a false will be returned as the status.
1236:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1237:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_RESET_AssertPeripheralReset(), XMC_SCU_RESET_DeassertPeripheralReset() \n\n\n 
1238:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1239:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** bool XMC_SCU_RESET_IsPeripheralResetAsserted(const XMC_SCU_PERIPHERAL_RESET_t peripheral);
1240:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  
1241:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1242:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1243:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param memory  The on-chip RAM type, for which the parity error status has to be cleared.\n
1244:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_PARITY_t to identify the on-chip RAM type. Multiple 
1245:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          memory status bits can be cleared by using the \a OR operation.
1246:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1247:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1248:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1249:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1250:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Clears the parity error status bit. \n\n
1251:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * When a memory parity error is detected using the status bits in \a PEFLAG register. It has to 
1252:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * be cleared by software to detect the parity error from the same memory next time.
1253:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API clears the parity error status bit of the selected peripheral by setting the 
1254:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * respective bit in the \a PEFLAG register. Status of multiple memory parity errors 
1255:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * can be cleared by combining the enum values using \a OR operation.
1256:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1257:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_PARITY_GetStatus(), XMC_SCU_PARITY_Enable(), XMC_SCU_PARITY_EnableTrapGeneration() \n\n\
1258:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1259:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_PARITY_ClearStatus(const uint32_t memory);
1260:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1261:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1262:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1263:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param memory  The on-chip RAM type, for which the parity error checking has to be enabled.\n
1264:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_PARITY_t to identify the on-chip RAM type. Multiple 
1265:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          memory types can be combined using the \a OR operation.
1266:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1267:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1268:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1269:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1270:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables parity error checking for the selected on-chip RAM type.\n\n
1271:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Parity error checking can be enabled by setting respective bits in the \a PEEN register.
1272:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Additionally parity error can be configured to generate trap when the error is detected,
1273:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * using the API XMC_SCU_PARITY_EnableTrapGeneration(). Such a trap can be further configured
1274:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * to generate non maskable interrupt(NMI) using the API XMC_SCU_INTERRUPT_EnableNmiRequest().
1275:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1276:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_PARITY_EnableTrapGeneration(), XMC_SCU_INTERRUPT_EnableNmiRequest() \n\n\n
1277:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1278:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_PARITY_Enable(const uint32_t memory);
1279:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1280:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1281:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1282:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param memory   The on-chip RAM type, for which the parity error checking has to be disabled.\n
1283:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_PARITY_t to identify the on-chip RAM type. Multiple 
1284:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          memory types can be combined using the \a OR operation.
1285:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1286:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1287:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1288:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1289:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables parity error checking for the selected on-chip RAM type.\n\n
1290:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Parity error detection can be disabled by clearing the respective bit in the \a PEEN register.
1291:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1292:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_PARITY_Enable(), XMC_SCU_PARITY_DisableTrapGeneration() \n\n\n
1293:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1294:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_PARITY_Disable(const uint32_t memory);
1295:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1296:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1297:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1298:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param memory  The on-chip RAM type, for which the parity error trap generation has to be enable
1299:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_PARITY_t to identify the on-chip RAM type. Multiple 
1300:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          memory types can be combined using the \a OR operation.
1301:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1302:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1303:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1304:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1305:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables trap assertion for the parity error source.\n\n
1306:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Parity error detection for different types of on-chip RAM can generate trap.
1307:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Trap assertion for parity error can be individually enabled by setting the respective bits
1308:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * in the \a PETE register. The generated trap can be additionally configured to generate
1309:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * non maskable interrupt(NMI) using the API XMC_SCU_INTERRUPT_EnableNmiRequest().
1310:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1311:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_INTERRUPT_EnableNmiRequest(), XMC_SCU_PARITY_DisableTrapGeneration() \n\n\n
1312:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1313:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_PARITY_EnableTrapGeneration(const uint32_t memory);
1314:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1315:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1316:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1317:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param memory  The on-chip RAM type, for which the parity error trap generation has to be disabl
1318:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_PARITY_t to identify the on-chip RAM type. Multiple 
1319:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          memory types can be combined using the \a OR operation.
1320:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1321:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None  
1322:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1323:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1324:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables the assertion of trap for the parity error source.\n\n
1325:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Trap assertion can be disabled by clearing the respective bit of the RAM type in the \a PETE reg
1326:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1327:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1328:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_PARITY_EnableTrapGeneration() \n\n\n
1329:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1330:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_PARITY_DisableTrapGeneration(const uint32_t memory);
1331:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1332:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1333:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1334:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Status of parity error detection for the on-chip RAM modules.\n
1335:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_PARITY_t to get the bit mask of each RAM module type.
1336:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1337:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1338:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the status of parity error detection for the on-chip RAM modules.\n\n
1339:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Parity error status information is obtained from the \a PEFLAG register.
1340:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If a particular RAM module has parity error, its respective bit field will be set to 1 in the 
1341:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * returned value. A check for the status of a particular RAM module can be done by
1342:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * masking the returned value with the RAM module identifier from the type @ref XMC_SCU_PARITY_t.
1343:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1344:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_PARITY_ClearStatus() \n\n\n
1345:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1346:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_PARITY_GetStatus(void);  
1347:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1348:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1349:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1350:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param clock  Peripheral for which the clock has to be enabled. \n
1351:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_t to select the peripheral.
1352:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1353:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1354:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1355:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1356:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables the source clock for selected peripheral.\n\n
1357:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The various outputs of Clock Generation Unit (CGU) can be individually enabled by setting the pe
1358:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * specific bit in the \a CLKSET register.\n
1359:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps to verify whether a source clock of peripheral is enabl
1360:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_CLOCK_EnableClock() with desired peripheral identifier.\n
1361:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_CLOCK_IsClockEnabled() with same peripheral identifier to verify whether the c
1362:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1363:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_DisableClock(), XMC_SCU_RESET_DeassertPeripheralReset() \n\n\n
1364:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1365:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_EnableClock(const XMC_SCU_CLOCK_t clock);
1366:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1367:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1368:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1369:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param clock  Peripheral for which the clock has to be disabled. \n
1370:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_t to select the peripheral.
1371:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1372:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1373:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1374:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1375:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables source clock for the peripheral selected.\n\n
1376:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The various outputs of Clock Generation Unit (CGU) can be individually disabled  by setting the 
1377:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * specific bits in the \a CLKCLR register.\n
1378:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is recommended to use following steps to verify whether clock source of the peripheral is ena
1379:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_CLOCK_DisableClock with desired peripheral identifier.\n
1380:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * - Call \a XMC_SCU_CLOCK_IsClockEnabled with same peripheral identifier to verify whether periphe
1381:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1382:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_EnableClock(), XMC_SCU_RESET_AssertPeripheralReset() \n\n\n
1383:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1384:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_DisableClock(const XMC_SCU_CLOCK_t clock);
1385:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1386:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1387:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1388:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param clock   Peripheral for which the clock status has to be checked. \n
1389:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_t to select the peripheral.
1390:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1391:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return bool  Status of peripheral clock.\n
1392:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: \a true if peripheral clock is enabled. \a false if peripheral clock is disable
1393:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1394:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1395:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Checks the status of peripheral source clock.\n\n
1396:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The status of peripheral source clock is read from the \a CLKSTATn register. 
1397:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Returns \a true if clock is enabled and returns \a false otherwise.
1398:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1399:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_EnableClock(), XMC_SCU_CLOCK_DisableClock() \n\n\n
1400:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1401:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** bool XMC_SCU_CLOCK_IsClockEnabled(const XMC_SCU_CLOCK_t clock);
1402:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1403:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1404:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1405:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param source  Source of clock for fSYS.\n
1406:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_SYSCLKSRC_t to select the source of clock.\n
1407:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_SYSCLKSRC_OFI for selecting internal fast clock as fSYS.\n
1408:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_SYSCLKSRC_PLL for selecting the output of PLL fPLL as fSYS.
1409:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1410:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1411:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1412:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1413:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source for system clock (fSYS).\n\n
1414:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * System clock is selected by setting \a SYSSEL bits in the \a SYSCLKCR register.
1415:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If \a XMC_SCU_CLOCK_SYSCLKSRC_PLL is selected, then the dividers of the PLL have to be
1416:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * additionally configured to achieve the required system clock frequency. 
1417:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   * \par<b>Related APIs:</b><BR>
1418:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_StartSystemPll(), XMC_SCU_CLOCK_EnableHighPerformanceOscillator() \n\n\n
1419:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1420:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source);
1421:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1422:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1423:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_CLOCK_SYSCLKSRC_t   Source of clock for fSYS.\n
1424:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_SYSCLKSRC_t to select the source of clock.\n
1425:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_SYSCLKSRC_OFI - internal fast clock selected as fSYS.\n
1426:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_SYSCLKSRC_PLL - output of PLL fPLL selected as fSYS.
1427:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1428:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1429:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the selected source of system clock (fSYS). \n\n
1430:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selected source of fSYS is obtained by reading \a SYSSEL bits of \a SYSCLKCR register.
1431:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1432:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetSystemClockSource(), XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency() \n\n\n
1433:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1434:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_CLOCK_SYSCLKSRC_t XMC_SCU_CLOCK_GetSystemClockSource(void)
1435:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1436:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_CLOCK_SYSCLKSRC_t)(SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk);
1437:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1438:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1439:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1440:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1441:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param source   Source of clock for USB and SDMMC(fUSB/SDMMC).\n
1442:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_USBCLKSRC_t to select the source of clock.\n
1443:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_USBCLKSRC_USBPLL - output of USB PLL as source of USB clock(fUSB/
1444:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_USBCLKSRC_SYSPLL - output of PLL fPLL as source of USB clock(fUSB
1445:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1446:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1447:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1448:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1449:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source of USB/SDMMC clock (fUSB/SDMMC).\n\n
1450:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * USB and SDMMC use a common clock source. They can either use fUSB PLL or fPLL as the source of c
1451:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The selection is done by configuring the \a USBSEL bits of \a USBCLKCR register.
1452:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1453:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetUsbClockDivider(), XMC_SCU_CLOCK_GetUsbPllClockFrequency() \n\n\n
1454:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1455:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetUsbClockSource(const XMC_SCU_CLOCK_USBCLKSRC_t source);
1456:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1457:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1458:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_CLOCK_USBCLKSRC_t   Source of clock for USB and SDMMC(fUSB/SDMMC).\n
1459:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_USBCLKSRC_t to identify the source of clock.\n
1460:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_USBCLKSRC_USBPLL - output of USB PLL is selected as source of USB
1461:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_USBCLKSRC_SYSPLL - output of PLL fPLL is selected as source of US
1462:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1463:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1464:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the selected source of USB and SDMMC clock frequency.\n\n
1465:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The clock source is read from from the \a USBSEL bits of \a USBCLKCR register.
1466:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1467:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetUsbClockDivider(), XMC_SCU_CLOCK_GetUsbPllClockFrequency() \n\n\n
1468:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1469:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_CLOCK_USBCLKSRC_t XMC_SCU_CLOCK_GetUsbClockSource(void)
1470:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1471:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_CLOCK_USBCLKSRC_t)(SCU_CLK->USBCLKCR & SCU_CLK_USBCLKCR_USBSEL_Msk);
1472:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1473:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1474:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1475:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1476:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param source  Clock source for watchdog timer.\n
1477:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type XMC_SCU_CLOCK_WDTCLKSRC_t to identify the clock source.\n
1478:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_WDTCLKSRC_OFI - internal fast oscillator (fOFI)\n
1479:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_WDTCLKSRC_STDBY - backup standby clock (fSTDBY)\n
1480:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_WDTCLKSRC_PLL - PLL output clock (fPLL)
1481:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1482:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1483:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1484:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1485:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source of WDT clock (fWDT).\n\n
1486:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The selected value is configured to the \a WDTSEL bits of \a WDTCLKCR register.
1487:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The watchdog timer counts at the frequency selected using this API. So the time for
1488:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * timeout or pre-warning of watchdog has to be calculated based on this selection.
1489:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1490:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1491:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetWdtClockDivider(), XMC_SCU_CLOCK_GetWdtClockFrequency() \n\n\n
1492:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1493:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetWdtClockSource(const XMC_SCU_CLOCK_WDTCLKSRC_t source);
1494:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1495:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1496:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_CLOCK_WDTCLKSRC_t   Clock source configured for watchdog timer.\n
1497:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type XMC_SCU_CLOCK_WDTCLKSRC_t to identify the clock source.\n
1498:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_WDTCLKSRC_OFI - internal fast oscillator (fOFI)\n
1499:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_WDTCLKSRC_STDBY - backup standby clock (fSTDBY)\n
1500:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  XMC_SCU_CLOCK_WDTCLKSRC_PLL - PLL output clock (fPLL)
1501:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1502:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1503:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the source of clock used for watchdog timer.\n\n
1504:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a WDTSEL bits of \a WDTCLKCR register.
1505:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The time for timeout or pre-warning of watchdog has to be calculated based on 
1506:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the clock source selected.
1507:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1508:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetWdtClockDivider(), XMC_SCU_CLOCK_SetWdtClockSource() \n\n\n
1509:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1510:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_CLOCK_WDTCLKSRC_t XMC_SCU_CLOCK_GetWdtClockSource(void)
1511:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1512:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_CLOCK_WDTCLKSRC_t)(SCU_CLK->WDTCLKCR & SCU_CLK_WDTCLKCR_WDTSEL_Msk);
1513:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1514:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1515:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1516:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1517:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param source   Source for standby clock.\n
1518:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_HIB_STDBYCLKSRC_t to identify the clock source.\n
1519:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    XMC_SCU_HIB_STDBYCLKSRC_OSI - internal slow oscillator (fOSI) \n
1520:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    XMC_SCU_HIB_STDBYCLKSRC_OSCULP - ultra low power osciallator (fULP) \n
1521:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1522:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1523:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1524:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1525:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source of Standby clock (fSTDBY).\n\n
1526:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Clock source is configured by setting the \a STDBYSEL bits of \a HDCR register.
1527:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Hibernate domain should be enabled explicitly before using the API.
1528:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1529:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_HIB_GetStdbyClockSource(), XMC_SCU_HIB_EnableHibernateDomain() \n\n\n
1530:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1531:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_HIB_SetStandbyClockSource(const XMC_SCU_HIB_STDBYCLKSRC_t source);
1532:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1533:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1534:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_HIB_RTCCLKSRC_t   Source clock of standby clock(fSTDBY).\n
1535:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: Use type @ref XMC_SCU_HIB_STDBYCLKSRC_t to identify the clock source.\n
1536:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    XMC_SCU_HIB_STDBYCLKSRC_OSI - internal slow oscillator (fOSI) \n
1537:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    XMC_SCU_HIB_STDBYCLKSRC_OSCULP - ultra low power osciallator (fULP) \n
1538:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1539:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1540:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the source of standby clock (fSTDBY).\n\n
1541:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a STDBYSEL bits of \a HDCR register.\n
1542:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1543:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_HIB_SetStandbyClockSource(), XMC_SCU_HIB_EnableHibernateDomain() \n\n\n
1544:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1545:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_HIB_RTCCLKSRC_t XMC_SCU_HIB_GetStdbyClockSource(void)
1546:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1547:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_HIB_RTCCLKSRC_t)(SCU_HIBERNATE->HDCR & SCU_HIBERNATE_HDCR_STDBYSEL_Msk);
1548:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1549:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1550:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1551:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1552:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param source  Source of RTC clock.\n
1553:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            \b Range: Use type @ref XMC_SCU_HIB_RTCCLKSRC_t to identify the clock source.\n
1554:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_HIB_RTCCLKSRC_OSI - internal slow oscillator(fOSI). \n
1555:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_HIB_RTCCLKSRC_ULP - ultra low power oscillator(fULP). \n
1556:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1557:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1558:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1559:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1560:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source of RTC clock (fRTC).\n\n
1561:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is configured to \a RCS bit of \a HDCR register.
1562:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * fULP needs external input powered by VBAT or VDDP. fOSI is internal clock.
1563:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The frequency of the clock will be 32.768 kHz.
1564:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1565:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_HIB_GetRtcClockSource() \n\n\n
1566:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1567:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_HIB_SetRtcClockSource(const XMC_SCU_HIB_RTCCLKSRC_t source);
1568:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1569:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1570:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_HIB_RTCCLKSRC_t   Source of RTC clock.\n
1571:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            \b Range: Use type @ref XMC_SCU_HIB_RTCCLKSRC_t to identify the clock source.\n
1572:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_HIB_RTCCLKSRC_OSI - internal slow oscillator(fOSI). \n
1573:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_HIB_RTCCLKSRC_ULP - ultra low power oscillator(fULP). \n
1574:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1575:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1576:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the source of RTC clock (fRTC).
1577:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a RCS bit of \a HDCR register.
1578:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The frequency of the clock will be 32.768 kHz.
1579:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1580:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_HIB_SetRtcClockSource() \n\n\n
1581:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1582:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_HIB_RTCCLKSRC_t XMC_SCU_HIB_GetRtcClockSource(void)
1583:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1584:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_HIB_RTCCLKSRC_t)(SCU_HIBERNATE->HDCR & SCU_HIBERNATE_HDCR_RCS_Msk);
1585:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1586:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1587:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1588:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1589:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param clock  Source of external clock output(fEXT).\n
1590:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *           \b Range: Use type @ref XMC_SCU_CLOCK_EXTOUTCLKSRC_t to identify the clock.\n
1591:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_SYS - system clock fSYS. \n
1592:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_USB - USB clock fUSB. \n
1593:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_PLL - PLL output fPLL. \n
1594:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \if XMC42
1595:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_STDBY - Standby clock fSTDBY. \n
1596:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1597:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \endif
1598:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \if XMC41
1599:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_STDBY - Standby clock fSTDBY. \n
1600:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \endif
1601:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1602:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1603:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1604:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1605:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source of external clock out (fEXT).\n\n
1606:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value will be configured to \a ECKSEL bits of \a EXTCLKCR register.
1607:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1608:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetExternalOutputClockSource(), XMC_SCU_CLOCK_SetExternalOutputClockDivider() \n\n
1609:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1610:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetExternalOutputClockSource(const XMC_SCU_CLOCK_EXTOUTCLKSRC_t clock);
1611:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1612:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1613:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_CLOCK_EXTOUTCLKSRC_t   Source of external clock output(fEXT).\n
1614:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *           \b Range: Use type @ref XMC_SCU_CLOCK_EXTOUTCLKSRC_t to identify the clock.\n
1615:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_SYS - system clock fSYS. \n
1616:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_USB - USB clock fUSB. \n
1617:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_PLL - PLL output fPLL. \n
1618:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \if XMC42
1619:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_STDBY - Standby clock fSTDBY. \n
1620:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \endif
1621:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \if XMC41
1622:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                      XMC_SCU_CLOCK_EXTOUTCLKSRC_STDBY - Standby clock fSTDBY. \n
1623:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \endif
1624:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1625:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1626:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the source of external clock output(fEXT).\n\n
1627:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a ECKSEL bits of \a EXTCLKCR register.
1628:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1629:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetExternalOutputClockSource(), XMC_SCU_CLOCK_SetExternalOutputClockDivider() \n\n
1630:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1631:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_CLOCK_EXTOUTCLKSRC_t XMC_SCU_CLOCK_GetExternalOutputClockSource(void)
1632:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1633:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_CLOCK_EXTOUTCLKSRC_t)(SCU_CLK->EXTCLKCR & SCU_CLK_EXTCLKCR_ECKSEL_Msk);
1634:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1635:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1636:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1637:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1638:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param source  Source of clock for system PLL.\n
1639:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_SYSPLLCLKSRC_t for identifying the clock source.\n
1640:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                            XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP - External High performance oscillat
1641:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                            XMC_SCU_CLOCK_SYSPLLCLKSRC_OFI - Internal fast clock (fOFI).
1642:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1643:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1644:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1645:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1646:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source of system PLL.\n\n
1647:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is configured to \a VCOBYP bit of \a PLLCON0 register.
1648:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If \a XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP is selected, ensure that the high performance oscillator 
1649:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * enabled by using the API XMC_SCU_CLOCK_EnableHighPerformanceOscillator().
1650:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1651:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_EnableHighPerformanceOscillator()\n\n\n
1652:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1653:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source);
1654:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1655:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1656:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_CLOCK_OSCCLKSRC_t   Source of clock for system PLL.\n
1657:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *        \b Range: Use type @ref XMC_SCU_CLOCK_SYSPLLCLKSRC_t for identifying the clock source.\n
1658:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                            XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP - External High performance oscillat
1659:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                            XMC_SCU_CLOCK_SYSPLLCLKSRC_OFI - Internal fast clock (fOFI).
1660:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1661:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1662:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the source of system PLL clock (fPLL). \n\n
1663:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a VCOBYP bit of \a PLLCON0 register.
1664:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1665:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_EnableHighPerformanceOscillator(), XMC_SCU_CLOCK_SetSystemPllClockSource()\n\n\n
1666:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1667:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_CLOCK_SYSPLLCLKSRC_t XMC_SCU_CLOCK_GetSystemPllClockSource(void)
1668:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1669:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_CLOCK_SYSPLLCLKSRC_t)(SCU_PLL->PLLCON0 & SCU_PLL_PLLCON0_VCOBYP_Msk);
1670:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1671:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1672:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ECAT0) 
1673:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1674:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1675:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param source  Source of ECAT clock.\n
1676:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            \b Range: Use type @ref XMC_SCU_CLOCK_ECATCLKSRC_t to identify the clock source.\n
1677:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_CLOCK_ECATCLKSRC_USBPLL - USB PLL (fUSBPLL) as a source for ECAT c
1678:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_CLOCK_ECATCLKSRC_SYSPLL - Main PLL output (fPLL) as a source for E
1679:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1680:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1681:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1682:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1683:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Selects the source of ECAT clock (fECAT).\n\n
1684:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is configured to \a ECATSEL bit of \a ECATCLKCR register.
1685:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1686:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetECATClockSource() \n\n\n
1687:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1688:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE void XMC_SCU_CLOCK_SetECATClockSource(const XMC_SCU_CLOCK_ECATCLKSRC_t source)
1689:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1690:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   SCU_CLK->ECATCLKCR = (SCU_CLK->ECATCLKCR & ((uint32_t)~SCU_CLK_ECATCLKCR_ECATSEL_Msk)) |
1691:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****                       ((uint32_t)source);
1692:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1693:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1694:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1695:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return XMC_SCU_CLOCK_ECATCLKSRC_t   Source of ECAT clock.\n
1696:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            \b Range: Use type @ref XMC_SCU_CLOCK_ECATCLKSRC_t to identify the clock source.\n
1697:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_CLOCK_ECATCLKSRC_USBPLL - USB PLL (fUSBPLL) as a source for ECAT c
1698:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                       XMC_SCU_CLOCK_ECATCLKSRC_SYSPLL - Main PLL output (fPLL) as a source for E
1699:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1700:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1701:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the source of ECAT clock (fECAT).
1702:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a ECATSEL bit of \a ECATCLKCR register.
1703:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1704:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_HIB_SetRtcClockSource() \n\n\n
1705:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1706:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE XMC_SCU_CLOCK_ECATCLKSRC_t XMC_SCU_CLOCK_GetECATClockSource(void)
1707:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1708:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (XMC_SCU_CLOCK_ECATCLKSRC_t)((SCU_CLK->ECATCLKCR & SCU_CLK_ECATCLKCR_ECATSEL_Msk) >> SCU_C
1709:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1710:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
1711:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1712:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1713:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1714:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param divider   Ratio of fSYS clock source to the value of fSYS.
1715:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: 1 to 256.
1716:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1717:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1718:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1719:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1720:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the ratio of system clock source to the value of system clock frequency.\n\n
1721:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is configured as \a SYSDIV bits of \a SYSCLKCR register. The divider value is 
1722:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * decremented by 1 before configuring.
1723:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1724:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetSystemClockDivider(),  XMC_SCU_CLOCK_SetSystemClockSource() \n\n\n
1725:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1726:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider);
1727:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1728:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1729:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t   Ratio of fSYS clock source to the value of fSYS.
1730:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: 0 to 255.
1731:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1732:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1733:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the value of ratio between the source of system clock to the the value of system clock 
1734:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a SYSDIV bits of \a SYSCLKCR register.
1735:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1736:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetSystemClockDivider(),  XMC_SCU_CLOCK_SetSystemClockSource() \n\n\n
1737:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1738:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetSystemClockDivider(void)
1739:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1740:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) >> SCU_CLK_SYSCLKCR_SYSDIV_Po
1741:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1742:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1743:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1744:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1745:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio  Ratio of fCCU clock source to the value of fCCU.
1746:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: 1 or 2.\n
1747:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  1-> fCCU= fSYS \n
1748:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  2-> fCCU= fSYS/2.
1749:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1750:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1751:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1752:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1753:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the divider for CCU clock source. \n\n
1754:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Capture compare unit(CCU) can take either fSYS or fSYS/2 as the source of clock.
1755:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The configuration is set to \a CCUDIV bit of \a CCUCLKCR register. The CCUDIV bit is 1 bit wide.
1756:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1757:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1758:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetCcuClockDivider() \n\n\n
1759:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1760:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t ratio);
1761:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1762:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1763:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Ratio of fCCU clock source to the value of fCCU.
1764:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *              \b Range: 0 or 1.\n
1765:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  0-> fCCU= fSYS \n
1766:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                  1-> fCCU= fSYS/2.
1767:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1768:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1769:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the ratio of CCU clock(fCCU) to system clock(fSYS).\n\n
1770:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a CCUDIV bit of \a CCUCLKCR register.
1771:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1772:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1773:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetCcuClockDivider() \n\n\n
1774:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1775:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetCcuClockDivider(void)
1776:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1777:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->CCUCLKCR & SCU_CLK_CCUCLKCR_CCUDIV_Msk) >> SCU_CLK_CCUCLKCR_CCUDIV_Po
1778:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1779:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1780:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1781:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1782:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio  Ratio between system clock(fSYS) and CPU clock(fCPU).
1783:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 1 or 2.\n
1784:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            1-> fCPU= fSYS. \n
1785:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            2-> fCPU= fSYS/2.
1786:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1787:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1788:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1789:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1790:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the CPU clock by setting the divider value for the system clock. \n\n
1791:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is set to the \a CPUDIV bit of \a CPUCLKCR register.
1792:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1793:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetCpuClockDivider() \n\n\n
1794:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1795:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t ratio);
1796:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1797:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1798:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t   Ratio between system clock(fSYS) and CPU clock(fCPU).
1799:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 0 or 1.\n
1800:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            0-> fCPU= fSYS. \n
1801:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            1-> fCPU= fSYS/2.
1802:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1803:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1804:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the ratio between system clock(fSYS) and CPU clock(fCPU). \n\n
1805:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a CPUDIV bit of \a CPUCLKCR register.
1806:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1807:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetCpuClockDivider() \n\n\n
1808:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1809:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetCpuClockDivider(void)
1810:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1811:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) >> SCU_CLK_CPUCLKCR_CPUDIV_Po
1812:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1813:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1814:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1815:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1816:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio  Ratio of peripheral clock source to the value of peripheral clock.\n
1817:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 1 or 2.\n
1818:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                1-> fPERIPH= fCPU.\n
1819:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                2-> fPERIPH= fCPU/2.
1820:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1821:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1822:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1823:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1824:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the peripheral clock by setting the divider for CPU clock(fCPU).\n\n
1825:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The peripheral clock can be equal to either fCPU or fCPU/2. The value is configured to \a PBDIV 
1826:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1827:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1828:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetPeripheralClockDivider() \n\n\n
1829:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1830:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t ratio);
1831:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1832:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1833:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Ratio of peripheral clock source to the value of peripheral clock.\n
1834:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 0 or 1.\n
1835:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                0-> fPERIPH= fCPU.\n
1836:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                1-> fPERIPH= fCPU/2.
1837:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1838:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1839:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the ratio of CPU clock(fCPU) to peripheral clock(fPERIPH).\n\n
1840:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a PBDIV bit of \a PBCLKCR register.
1841:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1842:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetPeripheralClockDivider() \n\n\n
1843:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1844:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetPeripheralClockDivider(void)
1845:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1846:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->PBCLKCR & SCU_CLK_PBCLKCR_PBDIV_Msk) >> SCU_CLK_PBCLKCR_PBDIV_Pos);
1847:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1848:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1849:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1850:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1851:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio   Ratio of PLL output clock(fPLL) to USB clock(fUSB).
1852:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 1 to 8.
1853:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1854:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1855:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1856:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1857:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the USB clock(fUSB) by setting the USB clock divider. \n\n
1858:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is decremented by 1 before setting it to \a USBDIV bits of \a USBCLKCR register.
1859:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1860:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1861:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetUsbClockDivider(), XMC_SCU_CLOCK_SetUsbClockSource() \n\n\n
1862:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1863:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t ratio);
1864:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1865:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1866:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1867:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Ratio of PLL output clock(fPLL) to USB clock(fUSB).
1868:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 0 to 7.
1869:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1870:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1871:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the ratio between PLL output frequency(fPLL) and USB clock(fUSB).\n\n
1872:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a USBDIV bit of \a USBCLKCR register.
1873:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1874:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetUsbClockDivider(), XMC_SCU_CLOCK_GetUsbClockSource() \n\n\n
1875:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1876:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetUsbClockDivider(void)
1877:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1878:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->USBCLKCR & SCU_CLK_USBCLKCR_USBDIV_Msk) >> SCU_CLK_USBCLKCR_USBDIV_Po
1879:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1880:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1881:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1882:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1883:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(EBU)
1884:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1885:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1886:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio Ratio of PLL clock(fPLL) to EBU clock(fEBU).\n
1887:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 1 to 64.
1888:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1889:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1890:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1891:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1892:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the EBU clock(fEBU) by setting the divider value.\n\n
1893:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The clock divider is configured to the \a EBUDIV bits of \a EBUCLKCR register.
1894:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1895:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetEbuClockDivider() \n\n\n
1896:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1897:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetEbuClockDivider(const uint32_t ratio);
1898:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1899:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1900:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1901:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Ratio of PLL clock(fPLL) to EBU clock(fEBU).\n
1902:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 0 to 63.
1903:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1904:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1905:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the ratio between PLL clock(fPLL) and EBU clock(fEBU).\n\n
1906:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a EBUDIV bits of \a EBUCLKCR register.
1907:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1908:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetEbuClockDivider() \n\n\n
1909:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1910:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetEbuClockDivider(void)
1911:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1912:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->EBUCLKCR & SCU_CLK_EBUCLKCR_EBUDIV_Msk) >> SCU_CLK_EBUCLKCR_EBUDIV_Po
1913:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1914:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
1915:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1916:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1917:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1918:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio  Ratio between the source of WDT clock and the WDT clock.\n
1919:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 1 to 256.
1920:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1921:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1922:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1923:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1924:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the WDT clock by setting the clock divider for the WDT clock source.\n\n
1925:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is configured to \a WDTDIV bits of \a WDTCLKCR register. The value of divider
1926:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * is decremented by 1 before configuring. Check the selected clock source for the WDT clock
1927:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * before configuring the divider using the API XMC_SCU_CLOCK_SetWdtClockSource().
1928:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1929:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetWdtClockSource(), XMC_SCU_CLOCK_GetWdtClockDivider() \n\n\n
1930:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1931:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t ratio);
1932:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1933:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1934:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1935:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Ratio between the source of WDT clock and the WDT clock.\n
1936:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 0 to 255.
1937:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1938:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1939:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the ratio between the WDT parent clock and the WDT clock. \n\n
1940:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a WDTDIV bits of \a WDTCLKCR register.
1941:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Ensure that the WDT parent clock is considered before using the value of
1942:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the divider value.
1943:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1944:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetWdtClockSource(), XMC_SCU_CLOCK_SetWdtClockDivider() \n\n\n
1945:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1946:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetWdtClockDivider(void)
1947:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1948:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->WDTCLKCR & SCU_CLK_WDTCLKCR_WDTDIV_Msk) >> SCU_CLK_WDTCLKCR_WDTDIV_Po
1949:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1950:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1951:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1952:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1953:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio   Ratio between the external output parent clock selected and the output clock.\n
1954:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 1 to 512.
1955:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1956:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1957:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1958:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1959:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the external output clock by setting the divider value for the parent clock. \n\n
1960:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value will be configured to \a ECKDIV bits of \a EXTCLKCR register.
1961:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The divider value is decremented by 1 before storing it to the bit fields.
1962:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Ensure that the source of external output clock is configured appropriately using the API
1963:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetExternalOutputClockSource().
1964:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1965:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetExternalOutputClockSource(), XMC_SCU_CLOCK_GetExternalOutputClockDivider() \n\n
1966:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1967:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetExternalOutputClockDivider(const uint32_t ratio);
1968:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1969:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1970:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1971:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Ratio between the external output parent clock selected and the output clock.\
1972:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 0 to 511.
1973:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1974:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1975:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the divider value applied on parent clock before the generation of external output cloc
1976:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a EXTDIV bit of \a EXTCLKCR register.
1977:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1978:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetExternalOutputClockSource(), XMC_SCU_CLOCK_SetExternalOutputClockDivider() \n\n
1979:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
1980:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetExternalOutputClockDivider(void)
1981:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
1982:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->EXTCLKCR & SCU_CLK_EXTCLKCR_ECKDIV_Msk) >> SCU_CLK_EXTCLKCR_ECKDIV_Po
1983:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
1984:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
1985:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #if defined(ECAT0)
1986:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
1987:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1988:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @param ratio   Ratio between the source of ECAT clock and the ECAT clock.\n
1989:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 1 to 4.
1990:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1991:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
1992:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
1993:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
1994:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Configures the ECAT clock by setting the clock divider for the ECAT clock source.\n\n
1995:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is configured to \a ECADIV bits of \a ECATCLKCR register. The value of divider
1996:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * is decremented by 1 before configuring.
1997:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
1998:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetECATClockSource(), XMC_SCU_CLOCK_GetECATClockDivider() \n\n\n
1999:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2000:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_SetECATClockDivider(const uint32_t divider);
2001:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2002:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2003:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2004:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Ratio between the source of ECAT clock and the ECAT clock.\n
2005:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: 0 to 3.
2006:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2007:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2008:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the ratio between the ECAT parent clock and the ECAT clock. \n\n
2009:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained by reading \a ECADIV bits of \a ECATCLKCR register.
2010:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2011:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetECATClockSource(), XMC_SCU_CLOCK_SetECATClockDivider() \n\n\n
2012:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2013:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetECATClockDivider(void)
2014:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
2015:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return (uint32_t)((SCU_CLK->ECATCLKCR & SCU_CLK_ECATCLKCR_ECADIV_Msk) >> SCU_CLK_ECATCLKCR_ECADIV
2016:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
2017:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** #endif
2018:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2019:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2020:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2021:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
2022:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2023:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2024:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables the high precision oscillator by configuring external crystal mode.\n\n
2025:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API configures \a MODE bits of \a OSCHPCTRL register to 0, there by configuring the 
2026:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * external clock input. 
2027:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2028:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_DisableHighPerformanceOscillator() \n\n\n
2029:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2030:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void);
2031:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2032:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2033:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
2034:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2035:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2036:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables the high precision oscillator by disabling the external oscillator.\n\n
2037:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API configures \a MODE bits of \a OSCHPCTRL register to 1, there by disabling the 
2038:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * external oscillator. 
2039:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2040:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_EnableHighPerformanceOscillator() \n\n\n
2041:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2042:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_DisableHighPerformanceOscillator(void);
2043:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2044:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2045:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2046:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
2047:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2048:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2049:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Enables ultra low power oscillator(ULP). \n\n
2050:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It enables the hibernate domain, configures the ultra low power oscillator
2051:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * uisng the \a MODE bits of the \a OSCULCTRL register. The \a Mode bits will be
2052:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * reset to 0 to enable the low power oscillator. Mirror register update delays 
2053:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * are handled internally.
2054:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2055:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_DisableLowPowerOscillator() \n\n\n
2056:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2057:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_EnableLowPowerOscillator(void);
2058:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2059:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2060:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2061:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return None
2062:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2063:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2064:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Disables ultra low power oscillator.\n\n
2065:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It is disabled by setting the \a MODE bits of \a OSCULCTRL register to value 2.
2066:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * By default on power up, the ultra low power osciallator is disabled.
2067:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2068:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_EnableLowPowerOscillator() \n\n\n
2069:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2070:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** void XMC_SCU_CLOCK_DisableLowPowerOscillator(void);
2071:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2072:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2073:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2074:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t   System frequency in Hertz.\n
2075:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            \b Range: clock frequency in Hertz. Range of the value depends on the source clock fr
2076:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *            and the configured values of dividers.
2077:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2078:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2079:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the value of system PLL output clock frequency(fPLL).\n\n
2080:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API uses \a N-DIV,  \a P-DIV,  \a K1-DIV,  \a K2-DIV bits information from \a PLLCON1 regist
2081:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * VCOBYP bit information from \a PLLCON0 register. It calculates frequency of system pll clock usi
2082:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If normal Mode : fPLL = (fOSC * N)/(P * K2).
2083:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If prescaler mode: fPLL = fOSC/ K1.
2084:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2085:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_SetSystemClockSource() \n\n\n
2086:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2087:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_CLOCK_GetSystemPllClockFrequency(void);
2088:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2089:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2090:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2091:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  Source clock used for deriving system clock.\n
2092:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *          \b Range: fOHP frequency if external high precision frequency is used. \n
2093:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *                    fOFI fast internal clock frequency.
2094:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2095:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2096:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the value of the input clock frequency for deriving the system clock.
2097:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The API retrieves frequency of system PLL input clock (fPLLin).
2098:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Based on \a PINSEL bits information from \a PLLCON2 register, the parent clock source is obtaine
2099:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * This bit field specifies if fOHP or fOFI is used for deriving system clock.
2100:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * System clock frequency is obtained by dividing the source clock frequency with different divider
2101:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2102:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetSystemPllClockFrequency() \n\n\n
2103:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2104:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency(void);
2105:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2106:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2107:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2108:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t   USB PLL output clock frequency.
2109:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2110:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2111:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the frequency of USB PLL output clock (fUSBPLL).\n\n
2112:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * It obtains the \a VCOBYP bits information from \a USBPLLCON register and decides if USB PLL mode
2113:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If USB PLL mode is used, the USB clock frequency is obtained by dividing the source clock by USB
2114:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The frequency is obtained using following formula:\n
2115:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If Normal Mode : fUSBPLL = (fOSC * N)/(P * 2).\n
2116:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * If Prescaler mode: fPLL = fOSC.
2117:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2118:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetSystemPllClockSourceFrequency() \n\n\n
2119:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2120:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_CLOCK_GetUsbPllClockFrequency(void);
2121:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2122:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2123:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2124:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t   System clock frequency in Hertz.
2125:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2126:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2127:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the frequency of system clock (fSYS).\n\n
2128:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value obtained by dividing \a CPUDIV bits information of \a CPUCLKCR register with SystemCor
2129:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Based on these values, fSYS clock frequency is derived using the following formula:\n
2130:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * fSYS = fCPU << CPUDIV.
2131:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2132:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetUsbPllClockFrequency() \n\n\n
2133:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2134:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetSystemClockFrequency(void)
2135:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 145              	 .loc 2 2135 0
 146              	 .cfi_startproc
 147              	 
 148              	 
 149              	 
 150 0000 80B4     	 push {r7}
 151              	.LCFI12:
 152              	 .cfi_def_cfa_offset 4
 153              	 .cfi_offset 7,-4
 154 0002 00AF     	 add r7,sp,#0
 155              	.LCFI13:
 156              	 .cfi_def_cfa_register 7
2136:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return SystemCoreClock << ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) >> SCU_CLK_CPUCLKCR_
 157              	 .loc 2 2136 0
 158 0004 064B     	 ldr r3,.L6
 159 0006 1A68     	 ldr r2,[r3]
 160 0008 064B     	 ldr r3,.L6+4
 161 000a 1B69     	 ldr r3,[r3,#16]
 162 000c 03F00103 	 and r3,r3,#1
 163 0010 02FA03F3 	 lsl r3,r2,r3
2137:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
 164              	 .loc 2 2137 0
 165 0014 1846     	 mov r0,r3
 166 0016 BD46     	 mov sp,r7
 167              	.LCFI14:
 168              	 .cfi_def_cfa_register 13
 169              	 
 170 0018 5DF8047B 	 ldr r7,[sp],#4
 171              	.LCFI15:
 172              	 .cfi_restore 7
 173              	 .cfi_def_cfa_offset 0
 174 001c 7047     	 bx lr
 175              	.L7:
 176 001e 00BF     	 .align 2
 177              	.L6:
 178 0020 00000000 	 .word SystemCoreClock
 179 0024 00460050 	 .word 1342195200
 180              	 .cfi_endproc
 181              	.LFE192:
 183              	 .section .text.XMC_SCU_CLOCK_GetEthernetClockFrequency,"ax",%progbits
 184              	 .align 2
 185              	 .thumb
 186              	 .thumb_func
 188              	XMC_SCU_CLOCK_GetEthernetClockFrequency:
 189              	.LFB193:
2138:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  
2139:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2140:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2141:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2142:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t  CCU clock frequency in Hertz.
2143:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2144:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2145:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the frequency of clock(fCPU) used for CCU4, CCU8, POSIF and HRPWM.\n\n
2146:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained from \a CCUDIV bits of \a CCUCLKCR register and system clock (fSYS) freque
2147:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Based on these values, fCCU clock frequency is calculated using following formula:\n
2148:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * fCCU = fSYS >> CCUDIV.\n
2149:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2150:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetCcuClockDivider(), XMC_SCU_CLOCK_GetSystemClockFrequency() \n\n\n
2151:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2152:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_CLOCK_GetCcuClockFrequency(void);
2153:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2154:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2155:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t   USB clock frequency in Hertz.
2156:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2157:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2158:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the frequency of USB and SDMMC clock(fUSB/fSDMMC).\n\n
2159:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is obtained from \a USBDIV bits of \a USBCLKCR register and USB clock source.
2160:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Based on these values fUSB/fSDMMC clock frequency is calculated using following formula:\n
2161:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * if USB clock source = USBPLL: fUSB/fSDMMC = fUSBPLL/(USBDIV + 1).\n
2162:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * if USB clock source = PLL:  fUSB/fSDMMC = fPLL/(USBDIV + 1).\n
2163:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2164:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2165:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetUsbClockSource(), XMC_SCU_CLOCK_GetUsbClockDivider() \n\n\n
2166:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2167:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** uint32_t XMC_SCU_CLOCK_GetUsbClockFrequency(void); 
2168:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** 
2169:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** /**
2170:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * @return uint32_t   Ethernet clock frequency in Hertz.
2171:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  *
2172:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Description</b><br>
2173:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * Provides the frequency of Ethernet clock(fETH).\n\n
2174:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * The value is derived from system clock frequency(fSYS). It is calculated using
2175:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * the following formula:\n
2176:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * fETH = fSYS >> 1;
2177:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * \par<b>Related APIs:</b><BR>
2178:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  * XMC_SCU_CLOCK_GetSystemClockFrequency() \n\n\n
2179:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****  */
2180:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** __STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetEthernetClockFrequency(void)
2181:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** {
 190              	 .loc 2 2181 0
 191              	 .cfi_startproc
 192              	 
 193              	 
 194 0000 80B5     	 push {r7,lr}
 195              	.LCFI16:
 196              	 .cfi_def_cfa_offset 8
 197              	 .cfi_offset 7,-8
 198              	 .cfi_offset 14,-4
 199 0002 00AF     	 add r7,sp,#0
 200              	.LCFI17:
 201              	 .cfi_def_cfa_register 7
2182:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h ****   return XMC_SCU_CLOCK_GetSystemClockFrequency() >> 1U;
 202              	 .loc 2 2182 0
 203 0004 FFF7FEFF 	 bl XMC_SCU_CLOCK_GetSystemClockFrequency
 204 0008 0346     	 mov r3,r0
 205 000a 5B08     	 lsrs r3,r3,#1
2183:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc4_scu.h **** }
 206              	 .loc 2 2183 0
 207 000c 1846     	 mov r0,r3
 208 000e 80BD     	 pop {r7,pc}
 209              	 .cfi_endproc
 210              	.LFE193:
 212              	 .section .text.XCM_ETH_MAC_IsNormalEvent,"ax",%progbits
 213              	 .align 2
 214              	 .thumb
 215              	 .thumb_func
 217              	XCM_ETH_MAC_IsNormalEvent:
 218              	.LFB202:
 219              	 .file 3 "../Libraries/XMCLib/src/xmc_eth_mac.c"
   1:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
   2:../Libraries/XMCLib/src/xmc_eth_mac.c **** /**
   3:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * @file xmc_eth_mac.c
   4:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * @date 2016-01-12
   5:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *
   6:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * @cond
   7:../Libraries/XMCLib/src/xmc_eth_mac.c ****  **************************************************************************************************
   8:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * XMClib v2.1.6 - XMC Peripheral Driver Library 
   9:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *
  10:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  11:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * All rights reserved.                        
  12:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *                                             
  13:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  14:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * following conditions are met:   
  15:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *                                                                              
  16:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  17:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * disclaimer.                        
  18:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * 
  19:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  20:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * disclaimer in the documentation and/or other materials provided with the distribution.
  21:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * 
  22:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  23:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * products derived from this software without specific prior written permission.                  
  24:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *                                                                              
  25:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  26:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  27:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  28:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  29:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  30:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  31:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  32:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *                                                                              
  33:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  34:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * Infineon Technologies AG dave@infineon.com).                                                    
  35:../Libraries/XMCLib/src/xmc_eth_mac.c ****  **************************************************************************************************
  36:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *
  37:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * Change History
  38:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * --------------
  39:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *
  40:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * 2015-06-20:
  41:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *     - Initial
  42:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *
  43:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * 2015-09-01:
  44:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *     - Add clock gating control in enable/disable APIs
  45:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *     - Add transmit polling if run out of buffers
  46:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *
  47:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * 2015-11-30:
  48:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *     - Fix XMC_ETH_MAC_GetRxFrameSize return value in case of errors
  49:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *
  50:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * @endcond
  51:../Libraries/XMCLib/src/xmc_eth_mac.c ****  */
  52:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
  53:../Libraries/XMCLib/src/xmc_eth_mac.c **** /*******************************************************************************
  54:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * HEADER FILES
  55:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *******************************************************************************/
  56:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
  57:../Libraries/XMCLib/src/xmc_eth_mac.c **** #include <xmc_eth_mac.h>
  58:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
  59:../Libraries/XMCLib/src/xmc_eth_mac.c **** #if defined (ETH0)
  60:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
  61:../Libraries/XMCLib/src/xmc_eth_mac.c **** #include <stdlib.h>
  62:../Libraries/XMCLib/src/xmc_eth_mac.c **** #include <xmc_scu.h>
  63:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
  64:../Libraries/XMCLib/src/xmc_eth_mac.c **** /*******************************************************************************
  65:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * MACROS
  66:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *******************************************************************************/
  67:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
  68:../Libraries/XMCLib/src/xmc_eth_mac.c **** /**
  69:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * ETH MAC clock speed
  70:../Libraries/XMCLib/src/xmc_eth_mac.c ****  */
  71:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define XMC_ETH_MAC_CLK_SPEED_35MHZ  (35000000U)  /**< ETH MAC clock speed 35 MHZ */
  72:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define XMC_ETH_MAC_CLK_SPEED_60MHZ  (60000000U)  /**< ETH MAC clock speed 60 MHZ */
  73:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define XMC_ETH_MAC_CLK_SPEED_100MHZ (100000000U) /**< ETH MAC clock speed 100 MHZ */
  74:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define XMC_ETH_MAC_CLK_SPEED_150MHZ (150000000U) /**< ETH MAC clock speed 150 MHZ */
  75:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define XMC_ETH_MAC_CLK_SPEED_200MHZ (200000000U) /**< ETH MAC clock speed 200 MHZ */
  76:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define XMC_ETH_MAC_CLK_SPEED_250MHZ (250000000U) /**< ETH MAC clock speed 250 MHZ */
  77:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
  78:../Libraries/XMCLib/src/xmc_eth_mac.c **** /**
  79:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * ETH MAC MDC divider
  80:../Libraries/XMCLib/src/xmc_eth_mac.c ****  */
  81:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define XMC_ETH_MAC_MDC_DIVIDER_16  (2U << ETH_GMII_ADDRESS_CR_Pos) /**< MDC clock: ETH clock/16 */
  82:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define XMC_ETH_MAC_MDC_DIVIDER_26  (3U << ETH_GMII_ADDRESS_CR_Pos) /**< MDC clock: ETH clock/26 */
  83:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define XMC_ETH_MAC_MDC_DIVIDER_42  (0U << ETH_GMII_ADDRESS_CR_Pos) /**< MDC clock: ETH clock/42 */
  84:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define XMC_ETH_MAC_MDC_DIVIDER_62  (1U << ETH_GMII_ADDRESS_CR_Pos) /**< MDC clock: ETH clock/62 */
  85:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define XMC_ETH_MAC_MDC_DIVIDER_102 (4U << ETH_GMII_ADDRESS_CR_Pos) /**< MDC clock: ETH clock/102 *
  86:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define XMC_ETH_MAC_MDC_DIVIDER_124 (5U << ETH_GMII_ADDRESS_CR_Pos) /**< MDC clock: ETH clock/124 *
  87:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
  88:../Libraries/XMCLib/src/xmc_eth_mac.c **** /**
  89:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * TDES0 Descriptor TX Packet Control/Status
  90:../Libraries/XMCLib/src/xmc_eth_mac.c ****  */
  91:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_OWN  (0x80000000U) /**< Own bit 1=DMA, 0=CPU */
  92:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_IC   (0x40000000U) /**< Interrupt on competition */
  93:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_LS   (0x20000000U) /**< Last segment */
  94:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_FS   (0x10000000U) /**< First segment */
  95:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_DC   (0x08000000U) /**< Disable CRC */
  96:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_DP   (0x04000000U) /**< Disable pad */
  97:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_TTSE (0x02000000U) /**< Transmit time stamp enable */
  98:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_CIC  (0x00C00000U) /**< Checksum insertion control */
  99:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_TER  (0x00200000U) /**< Transmit end of ring */
 100:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_TCH  (0x00100000U) /**< Second address chained */
 101:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_TTSS (0x00020000U) /**< Transmit time stamp status */
 102:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_IHE  (0x00010000U) /**< IP header error */
 103:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_ES   (0x00008000U) /**< Error summary */
 104:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_JT   (0x00004000U) /**< Jabber timeout */
 105:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_FF   (0x00002000U) /**< Frame flushed */
 106:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_IPE  (0x00001000U) /**< IP payload error */
 107:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_LOC  (0x00000800U) /**< Loss of carrier */
 108:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_NC   (0x00000400U) /**< No carrier */
 109:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_LC   (0x00000200U) /**< Late collision */
 110:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_EC   (0x00000100U) /**< Excessive collision */
 111:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_VF   (0x00000080U) /**< VLAN frame */
 112:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_CC   (0x00000078U) /**< Collision count */
 113:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_ED   (0x00000004U) /**< Excessive deferral */
 114:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_UF   (0x00000002U) /**< Underflow error */
 115:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_TDES0_DB   (0x00000001U) /**< Deferred bit */
 116:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 117:../Libraries/XMCLib/src/xmc_eth_mac.c **** /**
 118:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * RDES0 Descriptor RX Packet Status
 119:../Libraries/XMCLib/src/xmc_eth_mac.c ****  */
 120:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_OWN  (0x80000000U) /**< Own bit 1=DMA, 0=CPU */
 121:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_AFM  (0x40000000U) /**< Destination address filter fail */
 122:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_FL   (0x3FFF0000U) /**< Frame length mask */
 123:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_ES   (0x00008000U) /**< Error summary */
 124:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_DE   (0x00004000U) /**< Descriptor error */
 125:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_SAF  (0x00002000U) /**< Source address filter fail */
 126:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_LE   (0x00001000U) /**< Length error */
 127:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_OE   (0x00000800U) /**< Overflow error */
 128:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_VLAN (0x00000400U) /**< VLAN tag */
 129:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_FS   (0x00000200U) /**< First descriptor */
 130:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_LS   (0x00000100U) /**< Last descriptor */
 131:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_TSA  (0x00000080U) /**< Timestamp available */
 132:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_LC   (0x00000040U) /**< Late collision */
 133:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_FT   (0x00000020U) /**< Frame type */
 134:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_RWT  (0x00000010U) /**< Receive watchdog timeout */
 135:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_RE   (0x00000008U) /**< Receive error */
 136:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_DBE  (0x00000004U) /**< Dribble bit error */
 137:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_CE   (0x00000002U) /**< CRC error */
 138:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES0_ESA  (0x00000001U) /**< Extended Status/Rx MAC address */
 139:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 140:../Libraries/XMCLib/src/xmc_eth_mac.c **** /**
 141:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * RDES1 Descriptor RX Packet Control
 142:../Libraries/XMCLib/src/xmc_eth_mac.c ****  */
 143:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES1_RBS2 (0x1FFF0000U) /**< Receive buffer 2 size */
 144:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES1_RER  (0x00008000U) /**< Receive end of ring */
 145:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES1_RCH  (0x00004000U) /**< Second address chained */
 146:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_DMA_RDES1_RBS1 (0x00001FFFU) /**< Receive buffer 1 size */
 147:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 148:../Libraries/XMCLib/src/xmc_eth_mac.c **** /**
 149:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * Normal MAC events
 150:../Libraries/XMCLib/src/xmc_eth_mac.c ****  */
 151:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_EVENT_NORMAL (XMC_ETH_MAC_EVENT_TRANSMIT |\
 152:../Libraries/XMCLib/src/xmc_eth_mac.c ****                               XMC_ETH_MAC_EVENT_TRANSMIT_BUFFER_UNAVAILABLE |\
 153:../Libraries/XMCLib/src/xmc_eth_mac.c ****                               XMC_ETH_MAC_EVENT_RECEIVE |\
 154:../Libraries/XMCLib/src/xmc_eth_mac.c ****                               XMC_ETH_MAC_EVENT_EARLY_RECEIVE)
 155:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 156:../Libraries/XMCLib/src/xmc_eth_mac.c **** /**
 157:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * Abnormal MAC events
 158:../Libraries/XMCLib/src/xmc_eth_mac.c ****  */
 159:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_MAC_EVENT_ABNORMAL (XMC_ETH_MAC_EVENT_TRANSMIT_PROCESS_STOPPED |\
 160:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                 XMC_ETH_MAC_EVENT_TRANSMIT_JABBER_TIMEOUT |\
 161:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                 XMC_ETH_MAC_EVENT_RECEIVE_OVERFLOW |\
 162:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                 XMC_ETH_MAC_EVENT_TRANSMIT_UNDERFLOW |\
 163:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                 XMC_ETH_MAC_EVENT_RECEIVE_BUFFER_UNAVAILABLE |\
 164:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                 XMC_ETH_MAC_EVENT_RECEIVE_PROCESS_STOPPED |\
 165:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                 XMC_ETH_MAC_EVENT_RECEIVE_WATCHDOG_TIMEOUT |\
 166:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                 XMC_ETH_MAC_EVENT_EARLY_TRANSMIT |\
 167:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                 XMC_ETH_MAC_EVENT_BUS_ERROR)
 168:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 169:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Definition needed in case of device header file previous to v1.5.1*/
 170:../Libraries/XMCLib/src/xmc_eth_mac.c **** #ifndef ETH_BUS_MODE_ATDS_Msk
 171:../Libraries/XMCLib/src/xmc_eth_mac.c **** #define ETH_BUS_MODE_ATDS_Msk  (0x00000080UL)
 172:../Libraries/XMCLib/src/xmc_eth_mac.c **** #endif
 173:../Libraries/XMCLib/src/xmc_eth_mac.c **** /*******************************************************************************
 174:../Libraries/XMCLib/src/xmc_eth_mac.c ****  * API IMPLEMENTATION
 175:../Libraries/XMCLib/src/xmc_eth_mac.c ****  *******************************************************************************/
 176:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 177:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Check if the event passed is a normal event */
 178:../Libraries/XMCLib/src/xmc_eth_mac.c **** __STATIC_INLINE bool XCM_ETH_MAC_IsNormalEvent(uint32_t event)
 179:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 220              	 .loc 3 179 0
 221              	 .cfi_startproc
 222              	 
 223              	 
 224              	 
 225 0000 80B4     	 push {r7}
 226              	.LCFI18:
 227              	 .cfi_def_cfa_offset 4
 228              	 .cfi_offset 7,-4
 229 0002 83B0     	 sub sp,sp,#12
 230              	.LCFI19:
 231              	 .cfi_def_cfa_offset 16
 232 0004 00AF     	 add r7,sp,#0
 233              	.LCFI20:
 234              	 .cfi_def_cfa_register 7
 235 0006 7860     	 str r0,[r7,#4]
 180:../Libraries/XMCLib/src/xmc_eth_mac.c ****   return (bool)((event & ((uint32_t)XMC_ETH_MAC_EVENT_TRANSMIT |
 236              	 .loc 3 180 0
 237 0008 7A68     	 ldr r2,[r7,#4]
 238 000a 44F24503 	 movw r3,#16453
 239 000e 1340     	 ands r3,r3,r2
 240 0010 002B     	 cmp r3,#0
 241 0012 14BF     	 ite ne
 242 0014 0123     	 movne r3,#1
 243 0016 0023     	 moveq r3,#0
 244 0018 DBB2     	 uxtb r3,r3
 181:../Libraries/XMCLib/src/xmc_eth_mac.c ****                           (uint32_t)XMC_ETH_MAC_EVENT_TRANSMIT_BUFFER_UNAVAILABLE |
 182:../Libraries/XMCLib/src/xmc_eth_mac.c ****                           (uint32_t)XMC_ETH_MAC_EVENT_RECEIVE |
 183:../Libraries/XMCLib/src/xmc_eth_mac.c ****                           (uint32_t)XMC_ETH_MAC_EVENT_EARLY_RECEIVE)) != (uint32_t)0);
 184:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 245              	 .loc 3 184 0
 246 001a 1846     	 mov r0,r3
 247 001c 0C37     	 adds r7,r7,#12
 248              	.LCFI21:
 249              	 .cfi_def_cfa_offset 4
 250 001e BD46     	 mov sp,r7
 251              	.LCFI22:
 252              	 .cfi_def_cfa_register 13
 253              	 
 254 0020 5DF8047B 	 ldr r7,[sp],#4
 255              	.LCFI23:
 256              	 .cfi_restore 7
 257              	 .cfi_def_cfa_offset 0
 258 0024 7047     	 bx lr
 259              	 .cfi_endproc
 260              	.LFE202:
 262 0026 00BF     	 .section .text.XCM_ETH_MAC_IsAbnormalEvent,"ax",%progbits
 263              	 .align 2
 264              	 .thumb
 265              	 .thumb_func
 267              	XCM_ETH_MAC_IsAbnormalEvent:
 268              	.LFB203:
 185:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 186:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Check if the event passed is an abnormal event */
 187:../Libraries/XMCLib/src/xmc_eth_mac.c **** __STATIC_INLINE bool XCM_ETH_MAC_IsAbnormalEvent(uint32_t event)
 188:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 269              	 .loc 3 188 0
 270              	 .cfi_startproc
 271              	 
 272              	 
 273              	 
 274 0000 80B4     	 push {r7}
 275              	.LCFI24:
 276              	 .cfi_def_cfa_offset 4
 277              	 .cfi_offset 7,-4
 278 0002 83B0     	 sub sp,sp,#12
 279              	.LCFI25:
 280              	 .cfi_def_cfa_offset 16
 281 0004 00AF     	 add r7,sp,#0
 282              	.LCFI26:
 283              	 .cfi_def_cfa_register 7
 284 0006 7860     	 str r0,[r7,#4]
 189:../Libraries/XMCLib/src/xmc_eth_mac.c ****    return (bool)((event & ((uint32_t)XMC_ETH_MAC_EVENT_TRANSMIT_PROCESS_STOPPED |
 285              	 .loc 3 189 0
 286 0008 7A68     	 ldr r2,[r7,#4]
 287 000a 42F2BA73 	 movw r3,#10170
 288 000e 1340     	 ands r3,r3,r2
 289 0010 002B     	 cmp r3,#0
 290 0012 14BF     	 ite ne
 291 0014 0123     	 movne r3,#1
 292 0016 0023     	 moveq r3,#0
 293 0018 DBB2     	 uxtb r3,r3
 190:../Libraries/XMCLib/src/xmc_eth_mac.c ****                            (uint32_t)XMC_ETH_MAC_EVENT_TRANSMIT_JABBER_TIMEOUT |
 191:../Libraries/XMCLib/src/xmc_eth_mac.c ****                            (uint32_t)XMC_ETH_MAC_EVENT_RECEIVE_OVERFLOW |
 192:../Libraries/XMCLib/src/xmc_eth_mac.c ****                            (uint32_t)XMC_ETH_MAC_EVENT_TRANSMIT_UNDERFLOW |
 193:../Libraries/XMCLib/src/xmc_eth_mac.c ****                            (uint32_t)XMC_ETH_MAC_EVENT_RECEIVE_BUFFER_UNAVAILABLE |
 194:../Libraries/XMCLib/src/xmc_eth_mac.c ****                            (uint32_t)XMC_ETH_MAC_EVENT_RECEIVE_PROCESS_STOPPED |
 195:../Libraries/XMCLib/src/xmc_eth_mac.c ****                            (uint32_t)XMC_ETH_MAC_EVENT_RECEIVE_WATCHDOG_TIMEOUT |
 196:../Libraries/XMCLib/src/xmc_eth_mac.c ****                            (uint32_t)XMC_ETH_MAC_EVENT_EARLY_TRANSMIT |
 197:../Libraries/XMCLib/src/xmc_eth_mac.c ****                            (uint32_t)XMC_ETH_MAC_EVENT_BUS_ERROR)) != (uint32_t)0);
 198:../Libraries/XMCLib/src/xmc_eth_mac.c ****  }
 294              	 .loc 3 198 0
 295 001a 1846     	 mov r0,r3
 296 001c 0C37     	 adds r7,r7,#12
 297              	.LCFI27:
 298              	 .cfi_def_cfa_offset 4
 299 001e BD46     	 mov sp,r7
 300              	.LCFI28:
 301              	 .cfi_def_cfa_register 13
 302              	 
 303 0020 5DF8047B 	 ldr r7,[sp],#4
 304              	.LCFI29:
 305              	 .cfi_restore 7
 306              	 .cfi_def_cfa_offset 0
 307 0024 7047     	 bx lr
 308              	 .cfi_endproc
 309              	.LFE203:
 311 0026 00BF     	 .section .text.XMC_ETH_MAC_Init,"ax",%progbits
 312              	 .align 2
 313              	 .global XMC_ETH_MAC_Init
 314              	 .thumb
 315              	 .thumb_func
 317              	XMC_ETH_MAC_Init:
 318              	.LFB204:
 199:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 200:../Libraries/XMCLib/src/xmc_eth_mac.c **** #ifdef XMC_ASSERT_ENABLE 
 201:../Libraries/XMCLib/src/xmc_eth_mac.c ****  
 202:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Check if the passed argument is a valid ETH module */ 
 203:../Libraries/XMCLib/src/xmc_eth_mac.c **** __STATIC_INLINE bool XMC_ETH_MAC_IsValidModule(ETH_GLOBAL_TypeDef *const eth)
 204:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 205:../Libraries/XMCLib/src/xmc_eth_mac.c ****   return (eth == ETH0);
 206:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 207:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 208:../Libraries/XMCLib/src/xmc_eth_mac.c **** #endif
 209:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 210:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* ETH MAC initialize */
 211:../Libraries/XMCLib/src/xmc_eth_mac.c **** XMC_ETH_MAC_STATUS_t XMC_ETH_MAC_Init(XMC_ETH_MAC_t *const eth_mac)
 212:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 319              	 .loc 3 212 0
 320              	 .cfi_startproc
 321              	 
 322              	 
 323 0000 80B5     	 push {r7,lr}
 324              	.LCFI30:
 325              	 .cfi_def_cfa_offset 8
 326              	 .cfi_offset 7,-8
 327              	 .cfi_offset 14,-4
 328 0002 84B0     	 sub sp,sp,#16
 329              	.LCFI31:
 330              	 .cfi_def_cfa_offset 24
 331 0004 00AF     	 add r7,sp,#0
 332              	.LCFI32:
 333              	 .cfi_def_cfa_register 7
 334 0006 7860     	 str r0,[r7,#4]
 213:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ETH_MAC_STATUS_t status;
 214:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 215:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_Init: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->regs));
 216:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 217:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ETH_MAC_Enable(eth_mac);
 335              	 .loc 3 217 0
 336 0008 7868     	 ldr r0,[r7,#4]
 337 000a FFF7FEFF 	 bl XMC_ETH_MAC_Enable
 218:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ETH_MAC_Reset(eth_mac);
 338              	 .loc 3 218 0
 339 000e 7868     	 ldr r0,[r7,#4]
 340 0010 FFF7FEFF 	 bl XMC_ETH_MAC_Reset
 219:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 220:../Libraries/XMCLib/src/xmc_eth_mac.c ****   status = XMC_ETH_MAC_SetManagmentClockDivider(eth_mac);
 341              	 .loc 3 220 0
 342 0014 7868     	 ldr r0,[r7,#4]
 343 0016 FFF7FEFF 	 bl XMC_ETH_MAC_SetManagmentClockDivider
 344 001a 0346     	 mov r3,r0
 345 001c FB73     	 strb r3,[r7,#15]
 221:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 222:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ETH_MAC_SetAddress(eth_mac, eth_mac->address);
 346              	 .loc 3 222 0
 347 001e 7B68     	 ldr r3,[r7,#4]
 348 0020 D3E90223 	 ldrd r2,[r3,#8]
 349 0024 7868     	 ldr r0,[r7,#4]
 350 0026 FFF7FEFF 	 bl XMC_ETH_MAC_SetAddress
 223:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 224:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /* Initialize MAC configuration */
 225:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->MAC_CONFIGURATION = (uint32_t)ETH_MAC_CONFIGURATION_IPC_Msk;
 351              	 .loc 3 225 0
 352 002a 7B68     	 ldr r3,[r7,#4]
 353 002c 1B68     	 ldr r3,[r3]
 354 002e 4FF48062 	 mov r2,#1024
 355 0032 1A60     	 str r2,[r3]
 226:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 227:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /* Initialize Filter registers */
 228:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->FLOW_CONTROL = ETH_FLOW_CONTROL_DZPQ_Msk; /* Disable Zero Quanta Pause */
 356              	 .loc 3 228 0
 357 0034 7B68     	 ldr r3,[r7,#4]
 358 0036 1B68     	 ldr r3,[r3]
 359 0038 8022     	 movs r2,#128
 360 003a 9A61     	 str r2,[r3,#24]
 229:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 230:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->OPERATION_MODE = (uint32_t)ETH_OPERATION_MODE_RSF_Msk |
 361              	 .loc 3 230 0
 362 003c 7B68     	 ldr r3,[r7,#4]
 363 003e 1B68     	 ldr r3,[r3]
 364 0040 03F58053 	 add r3,r3,#4096
 365 0044 1833     	 adds r3,r3,#24
 366 0046 4FF00872 	 mov r2,#35651584
 367 004a 1A60     	 str r2,[r3]
 231:../Libraries/XMCLib/src/xmc_eth_mac.c **** 		                          (uint32_t)ETH_OPERATION_MODE_TSF_Msk;
 232:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 233:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /* Increase enhanced descriptor to 8 WORDS, required when the Advanced Time-Stamp feature or Full
 234:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->BUS_MODE |= (uint32_t)ETH_BUS_MODE_ATDS_Msk;
 368              	 .loc 3 234 0
 369 004c 7B68     	 ldr r3,[r7,#4]
 370 004e 1B68     	 ldr r3,[r3]
 371 0050 7A68     	 ldr r2,[r7,#4]
 372 0052 1268     	 ldr r2,[r2]
 373 0054 02F58052 	 add r2,r2,#4096
 374 0058 1268     	 ldr r2,[r2]
 375 005a 42F08002 	 orr r2,r2,#128
 376 005e 03F58053 	 add r3,r3,#4096
 377 0062 1A60     	 str r2,[r3]
 235:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 236:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /* Initialize DMA Descriptors */
 237:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ETH_MAC_InitRxDescriptors(eth_mac);
 378              	 .loc 3 237 0
 379 0064 7868     	 ldr r0,[r7,#4]
 380 0066 FFF7FEFF 	 bl XMC_ETH_MAC_InitRxDescriptors
 238:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ETH_MAC_InitTxDescriptors(eth_mac);
 381              	 .loc 3 238 0
 382 006a 7868     	 ldr r0,[r7,#4]
 383 006c FFF7FEFF 	 bl XMC_ETH_MAC_InitTxDescriptors
 239:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 240:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /* Clear interrupts */
 241:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->STATUS = 0xFFFFFFFFUL;
 384              	 .loc 3 241 0
 385 0070 7B68     	 ldr r3,[r7,#4]
 386 0072 1B68     	 ldr r3,[r3]
 387 0074 03F58053 	 add r3,r3,#4096
 388 0078 1433     	 adds r3,r3,#20
 389 007a 4FF0FF32 	 mov r2,#-1
 390 007e 1A60     	 str r2,[r3]
 242:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 243:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->frame_end = NULL;
 391              	 .loc 3 243 0
 392 0080 7B68     	 ldr r3,[r7,#4]
 393 0082 0022     	 movs r2,#0
 394 0084 1A62     	 str r2,[r3,#32]
 244:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 245:../Libraries/XMCLib/src/xmc_eth_mac.c ****   return status;
 395              	 .loc 3 245 0
 396 0086 FB7B     	 ldrb r3,[r7,#15]
 246:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 397              	 .loc 3 246 0
 398 0088 1846     	 mov r0,r3
 399 008a 1037     	 adds r7,r7,#16
 400              	.LCFI33:
 401              	 .cfi_def_cfa_offset 8
 402 008c BD46     	 mov sp,r7
 403              	.LCFI34:
 404              	 .cfi_def_cfa_register 13
 405              	 
 406 008e 80BD     	 pop {r7,pc}
 407              	 .cfi_endproc
 408              	.LFE204:
 410              	 .section .text.XMC_ETH_MAC_InitRxDescriptors,"ax",%progbits
 411              	 .align 2
 412              	 .global XMC_ETH_MAC_InitRxDescriptors
 413              	 .thumb
 414              	 .thumb_func
 416              	XMC_ETH_MAC_InitRxDescriptors:
 417              	.LFB205:
 247:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 248:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Initialize RX descriptors */
 249:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_InitRxDescriptors(XMC_ETH_MAC_t *const eth_mac)
 250:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 418              	 .loc 3 250 0
 419              	 .cfi_startproc
 420              	 
 421              	 
 422              	 
 423 0000 80B4     	 push {r7}
 424              	.LCFI35:
 425              	 .cfi_def_cfa_offset 4
 426              	 .cfi_offset 7,-4
 427 0002 85B0     	 sub sp,sp,#20
 428              	.LCFI36:
 429              	 .cfi_def_cfa_offset 24
 430 0004 00AF     	 add r7,sp,#0
 431              	.LCFI37:
 432              	 .cfi_def_cfa_register 7
 433 0006 7860     	 str r0,[r7,#4]
 251:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint32_t i;
 252:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint32_t next;
 253:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 254:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_InitRxDescriptors: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac
 255:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 256:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /*
 257:../Libraries/XMCLib/src/xmc_eth_mac.c ****    * Chained structure (ETH_MAC_DMA_RDES1_RCH), second address in the descriptor
 258:../Libraries/XMCLib/src/xmc_eth_mac.c ****    * (buffer2) is the next descriptor address
 259:../Libraries/XMCLib/src/xmc_eth_mac.c ****    */
 260:../Libraries/XMCLib/src/xmc_eth_mac.c ****   for (i = 0U; i < eth_mac->num_rx_buf; ++i)
 434              	 .loc 3 260 0
 435 0008 0023     	 movs r3,#0
 436 000a FB60     	 str r3,[r7,#12]
 437 000c 37E0     	 b .L17
 438              	.L19:
 261:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 262:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	eth_mac->rx_desc[i].status = (uint32_t)ETH_MAC_DMA_RDES0_OWN;
 439              	 .loc 3 262 0
 440 000e 7B68     	 ldr r3,[r7,#4]
 441 0010 1A69     	 ldr r2,[r3,#16]
 442 0012 FB68     	 ldr r3,[r7,#12]
 443 0014 5B01     	 lsls r3,r3,#5
 444 0016 1344     	 add r3,r3,r2
 445 0018 4FF00042 	 mov r2,#-2147483648
 446 001c 1A60     	 str r2,[r3]
 263:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	eth_mac->rx_desc[i].length = (uint32_t)ETH_MAC_DMA_RDES1_RCH | (uint32_t)XMC_ETH_MAC_BUF_SIZE;
 447              	 .loc 3 263 0
 448 001e 7B68     	 ldr r3,[r7,#4]
 449 0020 1A69     	 ldr r2,[r3,#16]
 450 0022 FB68     	 ldr r3,[r7,#12]
 451 0024 5B01     	 lsls r3,r3,#5
 452 0026 1344     	 add r3,r3,r2
 453 0028 44F2EE52 	 movw r2,#17902
 454 002c 5A60     	 str r2,[r3,#4]
 264:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	eth_mac->rx_desc[i].buffer1 = (uint32_t)&(eth_mac->rx_buf[i * XMC_ETH_MAC_BUF_SIZE]);
 455              	 .loc 3 264 0
 456 002e 7B68     	 ldr r3,[r7,#4]
 457 0030 1A69     	 ldr r2,[r3,#16]
 458 0032 FB68     	 ldr r3,[r7,#12]
 459 0034 5B01     	 lsls r3,r3,#5
 460 0036 1344     	 add r3,r3,r2
 461 0038 7A68     	 ldr r2,[r7,#4]
 462 003a 9169     	 ldr r1,[r2,#24]
 463 003c FA68     	 ldr r2,[r7,#12]
 464 003e 40F2EE50 	 movw r0,#1518
 465 0042 00FB02F2 	 mul r2,r0,r2
 466 0046 0A44     	 add r2,r2,r1
 467 0048 9A60     	 str r2,[r3,#8]
 265:../Libraries/XMCLib/src/xmc_eth_mac.c ****     next = i + 1U;
 468              	 .loc 3 265 0
 469 004a FB68     	 ldr r3,[r7,#12]
 470 004c 0133     	 adds r3,r3,#1
 471 004e BB60     	 str r3,[r7,#8]
 266:../Libraries/XMCLib/src/xmc_eth_mac.c ****     if (next == eth_mac->num_rx_buf)
 472              	 .loc 3 266 0
 473 0050 7B68     	 ldr r3,[r7,#4]
 474 0052 93F82430 	 ldrb r3,[r3,#36]
 475 0056 1A46     	 mov r2,r3
 476 0058 BB68     	 ldr r3,[r7,#8]
 477 005a 9A42     	 cmp r2,r3
 478 005c 01D1     	 bne .L18
 267:../Libraries/XMCLib/src/xmc_eth_mac.c ****     {
 268:../Libraries/XMCLib/src/xmc_eth_mac.c ****       next = 0U;
 479              	 .loc 3 268 0
 480 005e 0023     	 movs r3,#0
 481 0060 BB60     	 str r3,[r7,#8]
 482              	.L18:
 269:../Libraries/XMCLib/src/xmc_eth_mac.c ****     }
 270:../Libraries/XMCLib/src/xmc_eth_mac.c ****     eth_mac->rx_desc[i].buffer2 = (uint32_t)&(eth_mac->rx_desc[next]);
 483              	 .loc 3 270 0 discriminator 2
 484 0062 7B68     	 ldr r3,[r7,#4]
 485 0064 1A69     	 ldr r2,[r3,#16]
 486 0066 FB68     	 ldr r3,[r7,#12]
 487 0068 5B01     	 lsls r3,r3,#5
 488 006a 1344     	 add r3,r3,r2
 489 006c 7A68     	 ldr r2,[r7,#4]
 490 006e 1169     	 ldr r1,[r2,#16]
 491 0070 BA68     	 ldr r2,[r7,#8]
 492 0072 5201     	 lsls r2,r2,#5
 493 0074 0A44     	 add r2,r2,r1
 494 0076 DA60     	 str r2,[r3,#12]
 260:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 495              	 .loc 3 260 0 discriminator 2
 496 0078 FB68     	 ldr r3,[r7,#12]
 497 007a 0133     	 adds r3,r3,#1
 498 007c FB60     	 str r3,[r7,#12]
 499              	.L17:
 260:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 500              	 .loc 3 260 0 is_stmt 0 discriminator 1
 501 007e 7B68     	 ldr r3,[r7,#4]
 502 0080 93F82430 	 ldrb r3,[r3,#36]
 503 0084 1A46     	 mov r2,r3
 504 0086 FB68     	 ldr r3,[r7,#12]
 505 0088 9A42     	 cmp r2,r3
 506 008a C0D8     	 bhi .L19
 271:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 272:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->RECEIVE_DESCRIPTOR_LIST_ADDRESS = (uint32_t)&(eth_mac->rx_desc[0]);
 507              	 .loc 3 272 0 is_stmt 1
 508 008c 7B68     	 ldr r3,[r7,#4]
 509 008e 1B68     	 ldr r3,[r3]
 510 0090 7A68     	 ldr r2,[r7,#4]
 511 0092 1269     	 ldr r2,[r2,#16]
 512 0094 03F58053 	 add r3,r3,#4096
 513 0098 0C33     	 adds r3,r3,#12
 514 009a 1A60     	 str r2,[r3]
 273:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->rx_index = 0U;
 515              	 .loc 3 273 0
 516 009c 7B68     	 ldr r3,[r7,#4]
 517 009e 0022     	 movs r2,#0
 518 00a0 83F82720 	 strb r2,[r3,#39]
 274:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 519              	 .loc 3 274 0
 520 00a4 1437     	 adds r7,r7,#20
 521              	.LCFI38:
 522              	 .cfi_def_cfa_offset 4
 523 00a6 BD46     	 mov sp,r7
 524              	.LCFI39:
 525              	 .cfi_def_cfa_register 13
 526              	 
 527 00a8 5DF8047B 	 ldr r7,[sp],#4
 528              	.LCFI40:
 529              	 .cfi_restore 7
 530              	 .cfi_def_cfa_offset 0
 531 00ac 7047     	 bx lr
 532              	 .cfi_endproc
 533              	.LFE205:
 535 00ae 00BF     	 .section .text.XMC_ETH_MAC_InitTxDescriptors,"ax",%progbits
 536              	 .align 2
 537              	 .global XMC_ETH_MAC_InitTxDescriptors
 538              	 .thumb
 539              	 .thumb_func
 541              	XMC_ETH_MAC_InitTxDescriptors:
 542              	.LFB206:
 275:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 276:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Initialize TX descriptors */
 277:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_InitTxDescriptors(XMC_ETH_MAC_t *const eth_mac)
 278:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 543              	 .loc 3 278 0
 544              	 .cfi_startproc
 545              	 
 546              	 
 547              	 
 548 0000 80B4     	 push {r7}
 549              	.LCFI41:
 550              	 .cfi_def_cfa_offset 4
 551              	 .cfi_offset 7,-4
 552 0002 85B0     	 sub sp,sp,#20
 553              	.LCFI42:
 554              	 .cfi_def_cfa_offset 24
 555 0004 00AF     	 add r7,sp,#0
 556              	.LCFI43:
 557              	 .cfi_def_cfa_register 7
 558 0006 7860     	 str r0,[r7,#4]
 279:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint32_t i;
 280:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint32_t next;
 281:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 282:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_InitTxDescriptors: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac
 283:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 284:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /* Chained structure (ETH_MAC_DMA_TDES0_TCH), second address in the descriptor (buffer2) is the n
 285:../Libraries/XMCLib/src/xmc_eth_mac.c ****   for (i = 0U; i < eth_mac->num_tx_buf; ++i)
 559              	 .loc 3 285 0
 560 0008 0023     	 movs r3,#0
 561 000a FB60     	 str r3,[r7,#12]
 562 000c 2EE0     	 b .L21
 563              	.L23:
 286:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 287:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	eth_mac->tx_desc[i].status = ETH_MAC_DMA_TDES0_TCH | ETH_MAC_DMA_TDES0_LS | ETH_MAC_DMA_TDES0_FS;
 564              	 .loc 3 287 0
 565 000e 7B68     	 ldr r3,[r7,#4]
 566 0010 5A69     	 ldr r2,[r3,#20]
 567 0012 FB68     	 ldr r3,[r7,#12]
 568 0014 5B01     	 lsls r3,r3,#5
 569 0016 1344     	 add r3,r3,r2
 570 0018 204A     	 ldr r2,.L24
 571 001a 1A60     	 str r2,[r3]
 288:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	eth_mac->tx_desc[i].buffer1 = (uint32_t)&(eth_mac->tx_buf[i * XMC_ETH_MAC_BUF_SIZE]);
 572              	 .loc 3 288 0
 573 001c 7B68     	 ldr r3,[r7,#4]
 574 001e 5A69     	 ldr r2,[r3,#20]
 575 0020 FB68     	 ldr r3,[r7,#12]
 576 0022 5B01     	 lsls r3,r3,#5
 577 0024 1344     	 add r3,r3,r2
 578 0026 7A68     	 ldr r2,[r7,#4]
 579 0028 D169     	 ldr r1,[r2,#28]
 580 002a FA68     	 ldr r2,[r7,#12]
 581 002c 40F2EE50 	 movw r0,#1518
 582 0030 00FB02F2 	 mul r2,r0,r2
 583 0034 0A44     	 add r2,r2,r1
 584 0036 9A60     	 str r2,[r3,#8]
 289:../Libraries/XMCLib/src/xmc_eth_mac.c ****     next = i + 1U;
 585              	 .loc 3 289 0
 586 0038 FB68     	 ldr r3,[r7,#12]
 587 003a 0133     	 adds r3,r3,#1
 588 003c BB60     	 str r3,[r7,#8]
 290:../Libraries/XMCLib/src/xmc_eth_mac.c ****     if (next == eth_mac->num_tx_buf)
 589              	 .loc 3 290 0
 590 003e 7B68     	 ldr r3,[r7,#4]
 591 0040 93F82530 	 ldrb r3,[r3,#37]
 592 0044 1A46     	 mov r2,r3
 593 0046 BB68     	 ldr r3,[r7,#8]
 594 0048 9A42     	 cmp r2,r3
 595 004a 01D1     	 bne .L22
 291:../Libraries/XMCLib/src/xmc_eth_mac.c ****     {
 292:../Libraries/XMCLib/src/xmc_eth_mac.c ****         next = 0U;
 596              	 .loc 3 292 0
 597 004c 0023     	 movs r3,#0
 598 004e BB60     	 str r3,[r7,#8]
 599              	.L22:
 293:../Libraries/XMCLib/src/xmc_eth_mac.c ****     }
 294:../Libraries/XMCLib/src/xmc_eth_mac.c ****     eth_mac->tx_desc[i].buffer2 = (uint32_t)&(eth_mac->tx_desc[next]);
 600              	 .loc 3 294 0 discriminator 2
 601 0050 7B68     	 ldr r3,[r7,#4]
 602 0052 5A69     	 ldr r2,[r3,#20]
 603 0054 FB68     	 ldr r3,[r7,#12]
 604 0056 5B01     	 lsls r3,r3,#5
 605 0058 1344     	 add r3,r3,r2
 606 005a 7A68     	 ldr r2,[r7,#4]
 607 005c 5169     	 ldr r1,[r2,#20]
 608 005e BA68     	 ldr r2,[r7,#8]
 609 0060 5201     	 lsls r2,r2,#5
 610 0062 0A44     	 add r2,r2,r1
 611 0064 DA60     	 str r2,[r3,#12]
 285:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 612              	 .loc 3 285 0 discriminator 2
 613 0066 FB68     	 ldr r3,[r7,#12]
 614 0068 0133     	 adds r3,r3,#1
 615 006a FB60     	 str r3,[r7,#12]
 616              	.L21:
 285:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 617              	 .loc 3 285 0 is_stmt 0 discriminator 1
 618 006c 7B68     	 ldr r3,[r7,#4]
 619 006e 93F82530 	 ldrb r3,[r3,#37]
 620 0072 1A46     	 mov r2,r3
 621 0074 FB68     	 ldr r3,[r7,#12]
 622 0076 9A42     	 cmp r2,r3
 623 0078 C9D8     	 bhi .L23
 295:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 296:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->TRANSMIT_DESCRIPTOR_LIST_ADDRESS = (uint32_t)&(eth_mac->tx_desc[0]);
 624              	 .loc 3 296 0 is_stmt 1
 625 007a 7B68     	 ldr r3,[r7,#4]
 626 007c 1B68     	 ldr r3,[r3]
 627 007e 7A68     	 ldr r2,[r7,#4]
 628 0080 5269     	 ldr r2,[r2,#20]
 629 0082 03F58053 	 add r3,r3,#4096
 630 0086 1033     	 adds r3,r3,#16
 631 0088 1A60     	 str r2,[r3]
 297:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->tx_index = 0U;
 632              	 .loc 3 297 0
 633 008a 7B68     	 ldr r3,[r7,#4]
 634 008c 0022     	 movs r2,#0
 635 008e 83F82620 	 strb r2,[r3,#38]
 298:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 636              	 .loc 3 298 0
 637 0092 1437     	 adds r7,r7,#20
 638              	.LCFI44:
 639              	 .cfi_def_cfa_offset 4
 640 0094 BD46     	 mov sp,r7
 641              	.LCFI45:
 642              	 .cfi_def_cfa_register 13
 643              	 
 644 0096 5DF8047B 	 ldr r7,[sp],#4
 645              	.LCFI46:
 646              	 .cfi_restore 7
 647              	 .cfi_def_cfa_offset 0
 648 009a 7047     	 bx lr
 649              	.L25:
 650              	 .align 2
 651              	.L24:
 652 009c 00001030 	 .word 806354944
 653              	 .cfi_endproc
 654              	.LFE206:
 656              	 .section .text.XMC_ETH_MAC_SetAddressPerfectFilter,"ax",%progbits
 657              	 .align 2
 658              	 .global XMC_ETH_MAC_SetAddressPerfectFilter
 659              	 .thumb
 660              	 .thumb_func
 662              	XMC_ETH_MAC_SetAddressPerfectFilter:
 663              	.LFB207:
 299:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 300:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Set address perfect filter */
 301:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_SetAddressPerfectFilter(XMC_ETH_MAC_t *const eth_mac,
 302:../Libraries/XMCLib/src/xmc_eth_mac.c **** 		                                 uint8_t index,
 303:../Libraries/XMCLib/src/xmc_eth_mac.c **** 								         const uint64_t addr,
 304:../Libraries/XMCLib/src/xmc_eth_mac.c **** 								         uint32_t flags)
 305:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 664              	 .loc 3 305 0
 665              	 .cfi_startproc
 666              	 
 667              	 
 668              	 
 669 0000 B0B4     	 push {r4,r5,r7}
 670              	.LCFI47:
 671              	 .cfi_def_cfa_offset 12
 672              	 .cfi_offset 4,-12
 673              	 .cfi_offset 5,-8
 674              	 .cfi_offset 7,-4
 675 0002 87B0     	 sub sp,sp,#28
 676              	.LCFI48:
 677              	 .cfi_def_cfa_offset 40
 678 0004 00AF     	 add r7,sp,#0
 679              	.LCFI49:
 680              	 .cfi_def_cfa_register 7
 681 0006 F860     	 str r0,[r7,#12]
 682 0008 C7E90023 	 strd r2,[r7]
 683 000c 0B46     	 mov r3,r1
 684 000e FB72     	 strb r3,[r7,#11]
 306:../Libraries/XMCLib/src/xmc_eth_mac.c ****   __IO uint32_t *reg;
 307:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 308:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_SetAddressPerfectFilter: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(e
 309:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_SetAddressFilter: index is out of range", ((index > 0) && (index < 4)));
 310:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 311:../Libraries/XMCLib/src/xmc_eth_mac.c ****   reg = &(eth_mac->regs->MAC_ADDRESS0_HIGH);
 685              	 .loc 3 311 0
 686 0010 FB68     	 ldr r3,[r7,#12]
 687 0012 1B68     	 ldr r3,[r3]
 688 0014 4033     	 adds r3,r3,#64
 689 0016 7B61     	 str r3,[r7,#20]
 312:../Libraries/XMCLib/src/xmc_eth_mac.c ****   reg[index] = (uint32_t)(addr >> 32U) | flags;
 690              	 .loc 3 312 0
 691 0018 FB7A     	 ldrb r3,[r7,#11]
 692 001a 9B00     	 lsls r3,r3,#2
 693 001c 7A69     	 ldr r2,[r7,#20]
 694 001e D118     	 adds r1,r2,r3
 695 0020 D7E90023 	 ldrd r2,[r7]
 696 0024 1C00     	 movs r4,r3
 697 0026 0025     	 movs r5,#0
 698 0028 2246     	 mov r2,r4
 699 002a BB6A     	 ldr r3,[r7,#40]
 700 002c 1343     	 orrs r3,r3,r2
 701 002e 0B60     	 str r3,[r1]
 313:../Libraries/XMCLib/src/xmc_eth_mac.c ****   reg[index + 1U] = (uint32_t)addr;
 702              	 .loc 3 313 0
 703 0030 FB7A     	 ldrb r3,[r7,#11]
 704 0032 0133     	 adds r3,r3,#1
 705 0034 9B00     	 lsls r3,r3,#2
 706 0036 7A69     	 ldr r2,[r7,#20]
 707 0038 1344     	 add r3,r3,r2
 708 003a 3A68     	 ldr r2,[r7]
 709 003c 1A60     	 str r2,[r3]
 314:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 710              	 .loc 3 314 0
 711 003e 1C37     	 adds r7,r7,#28
 712              	.LCFI50:
 713              	 .cfi_def_cfa_offset 12
 714 0040 BD46     	 mov sp,r7
 715              	.LCFI51:
 716              	 .cfi_def_cfa_register 13
 717              	 
 718 0042 B0BC     	 pop {r4,r5,r7}
 719              	.LCFI52:
 720              	 .cfi_restore 7
 721              	 .cfi_restore 5
 722              	 .cfi_restore 4
 723              	 .cfi_def_cfa_offset 0
 724 0044 7047     	 bx lr
 725              	 .cfi_endproc
 726              	.LFE207:
 728              	 .section .text.XMC_ETH_MAC_SetAddressHashFilter,"ax",%progbits
 729              	 .align 2
 730              	 .global XMC_ETH_MAC_SetAddressHashFilter
 731              	 .thumb
 732              	 .thumb_func
 734              	XMC_ETH_MAC_SetAddressHashFilter:
 735              	.LFB208:
 315:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 316:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Set address hash filter */
 317:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_SetAddressHashFilter(XMC_ETH_MAC_t *const eth_mac, const uint64_t hash)
 318:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 736              	 .loc 3 318 0
 737              	 .cfi_startproc
 738              	 
 739              	 
 740              	 
 741 0000 B0B4     	 push {r4,r5,r7}
 742              	.LCFI53:
 743              	 .cfi_def_cfa_offset 12
 744              	 .cfi_offset 4,-12
 745              	 .cfi_offset 5,-8
 746              	 .cfi_offset 7,-4
 747 0002 85B0     	 sub sp,sp,#20
 748              	.LCFI54:
 749              	 .cfi_def_cfa_offset 32
 750 0004 00AF     	 add r7,sp,#0
 751              	.LCFI55:
 752              	 .cfi_def_cfa_register 7
 753 0006 F860     	 str r0,[r7,#12]
 754 0008 C7E90023 	 strd r2,[r7]
 319:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->HASH_TABLE_HIGH = (uint32_t)(hash >> 32);
 755              	 .loc 3 319 0
 756 000c FB68     	 ldr r3,[r7,#12]
 757 000e 1968     	 ldr r1,[r3]
 758 0010 D7E90023 	 ldrd r2,[r7]
 759 0014 1C00     	 movs r4,r3
 760 0016 0025     	 movs r5,#0
 761 0018 2346     	 mov r3,r4
 762 001a 8B60     	 str r3,[r1,#8]
 320:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->HASH_TABLE_LOW = (uint32_t)hash;
 763              	 .loc 3 320 0
 764 001c FB68     	 ldr r3,[r7,#12]
 765 001e 1B68     	 ldr r3,[r3]
 766 0020 3A68     	 ldr r2,[r7]
 767 0022 DA60     	 str r2,[r3,#12]
 321:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 768              	 .loc 3 321 0
 769 0024 1437     	 adds r7,r7,#20
 770              	.LCFI56:
 771              	 .cfi_def_cfa_offset 12
 772 0026 BD46     	 mov sp,r7
 773              	.LCFI57:
 774              	 .cfi_def_cfa_register 13
 775              	 
 776 0028 B0BC     	 pop {r4,r5,r7}
 777              	.LCFI58:
 778              	 .cfi_restore 7
 779              	 .cfi_restore 5
 780              	 .cfi_restore 4
 781              	 .cfi_def_cfa_offset 0
 782 002a 7047     	 bx lr
 783              	 .cfi_endproc
 784              	.LFE208:
 786              	 .section .text.XMC_ETH_MAC_SendFrame,"ax",%progbits
 787              	 .align 2
 788              	 .global XMC_ETH_MAC_SendFrame
 789              	 .thumb
 790              	 .thumb_func
 792              	XMC_ETH_MAC_SendFrame:
 793              	.LFB209:
 322:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 323:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Send frame */
 324:../Libraries/XMCLib/src/xmc_eth_mac.c **** XMC_ETH_MAC_STATUS_t XMC_ETH_MAC_SendFrame(XMC_ETH_MAC_t *const eth_mac, const uint8_t *frame, uint
 325:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 794              	 .loc 3 325 0
 795              	 .cfi_startproc
 796              	 
 797              	 
 798 0000 80B5     	 push {r7,lr}
 799              	.LCFI59:
 800              	 .cfi_def_cfa_offset 8
 801              	 .cfi_offset 7,-8
 802              	 .cfi_offset 14,-4
 803 0002 88B0     	 sub sp,sp,#32
 804              	.LCFI60:
 805              	 .cfi_def_cfa_offset 40
 806 0004 00AF     	 add r7,sp,#0
 807              	.LCFI61:
 808              	 .cfi_def_cfa_register 7
 809 0006 F860     	 str r0,[r7,#12]
 810 0008 B960     	 str r1,[r7,#8]
 811 000a 7A60     	 str r2,[r7,#4]
 812 000c 3B60     	 str r3,[r7]
 326:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ETH_MAC_STATUS_t status;
 327:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint8_t *dst;
 328:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint32_t ctrl;
 329:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 330:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_SendFrame:", eth_mac != NULL);
 331:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_SendFrame:", eth_mac->regs != ETH0);
 332:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_SendFrame:", (frame != NULL) && (len > 0));
 333:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 334:../Libraries/XMCLib/src/xmc_eth_mac.c ****   dst = eth_mac->frame_end;
 813              	 .loc 3 334 0
 814 000e FB68     	 ldr r3,[r7,#12]
 815 0010 1B6A     	 ldr r3,[r3,#32]
 816 0012 BB61     	 str r3,[r7,#24]
 335:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 336:../Libraries/XMCLib/src/xmc_eth_mac.c ****   if (eth_mac->tx_desc[eth_mac->tx_index].status & ETH_MAC_DMA_TDES0_OWN)
 817              	 .loc 3 336 0
 818 0014 FB68     	 ldr r3,[r7,#12]
 819 0016 5A69     	 ldr r2,[r3,#20]
 820 0018 FB68     	 ldr r3,[r7,#12]
 821 001a 93F82630 	 ldrb r3,[r3,#38]
 822 001e 5B01     	 lsls r3,r3,#5
 823 0020 1344     	 add r3,r3,r2
 824 0022 1B68     	 ldr r3,[r3]
 825 0024 002B     	 cmp r3,#0
 826 0026 1BDA     	 bge .L29
 337:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 338:../Libraries/XMCLib/src/xmc_eth_mac.c ****     /* Transmitter is busy, wait */
 339:../Libraries/XMCLib/src/xmc_eth_mac.c ****     status = XMC_ETH_MAC_STATUS_BUSY;
 827              	 .loc 3 339 0
 828 0028 0123     	 movs r3,#1
 829 002a FB77     	 strb r3,[r7,#31]
 340:../Libraries/XMCLib/src/xmc_eth_mac.c ****     if (eth_mac->regs->STATUS & ETH_STATUS_TU_Msk)
 830              	 .loc 3 340 0
 831 002c FB68     	 ldr r3,[r7,#12]
 832 002e 1B68     	 ldr r3,[r3]
 833 0030 03F58053 	 add r3,r3,#4096
 834 0034 1433     	 adds r3,r3,#20
 835 0036 1B68     	 ldr r3,[r3]
 836 0038 03F00403 	 and r3,r3,#4
 837 003c 002B     	 cmp r3,#0
 838 003e 00F09E80 	 beq .L31
 341:../Libraries/XMCLib/src/xmc_eth_mac.c ****     {
 342:../Libraries/XMCLib/src/xmc_eth_mac.c ****       /* Receive buffer unavailable, resume DMA */
 343:../Libraries/XMCLib/src/xmc_eth_mac.c ****       eth_mac->regs->STATUS = (uint32_t)ETH_STATUS_TU_Msk;
 839              	 .loc 3 343 0
 840 0042 FB68     	 ldr r3,[r7,#12]
 841 0044 1B68     	 ldr r3,[r3]
 842 0046 03F58053 	 add r3,r3,#4096
 843 004a 1433     	 adds r3,r3,#20
 844 004c 0422     	 movs r2,#4
 845 004e 1A60     	 str r2,[r3]
 344:../Libraries/XMCLib/src/xmc_eth_mac.c ****       eth_mac->regs->TRANSMIT_POLL_DEMAND = 0U;
 846              	 .loc 3 344 0
 847 0050 FB68     	 ldr r3,[r7,#12]
 848 0052 1B68     	 ldr r3,[r3]
 849 0054 03F58053 	 add r3,r3,#4096
 850 0058 0433     	 adds r3,r3,#4
 851 005a 0022     	 movs r2,#0
 852 005c 1A60     	 str r2,[r3]
 853 005e 8EE0     	 b .L31
 854              	.L29:
 345:../Libraries/XMCLib/src/xmc_eth_mac.c ****     }
 346:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 347:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 348:../Libraries/XMCLib/src/xmc_eth_mac.c ****   else
 349:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 350:../Libraries/XMCLib/src/xmc_eth_mac.c ****     if (dst == NULL)
 855              	 .loc 3 350 0
 856 0060 BB69     	 ldr r3,[r7,#24]
 857 0062 002B     	 cmp r3,#0
 858 0064 12D1     	 bne .L32
 351:../Libraries/XMCLib/src/xmc_eth_mac.c ****     {
 352:../Libraries/XMCLib/src/xmc_eth_mac.c ****       /* Start of a new transmit frame */
 353:../Libraries/XMCLib/src/xmc_eth_mac.c ****       dst = (uint8_t *)eth_mac->tx_desc[eth_mac->tx_index].buffer1;
 859              	 .loc 3 353 0
 860 0066 FB68     	 ldr r3,[r7,#12]
 861 0068 5A69     	 ldr r2,[r3,#20]
 862 006a FB68     	 ldr r3,[r7,#12]
 863 006c 93F82630 	 ldrb r3,[r3,#38]
 864 0070 5B01     	 lsls r3,r3,#5
 865 0072 1344     	 add r3,r3,r2
 866 0074 9B68     	 ldr r3,[r3,#8]
 867 0076 BB61     	 str r3,[r7,#24]
 354:../Libraries/XMCLib/src/xmc_eth_mac.c ****       eth_mac->tx_desc[eth_mac->tx_index].length = len;
 868              	 .loc 3 354 0
 869 0078 FB68     	 ldr r3,[r7,#12]
 870 007a 5A69     	 ldr r2,[r3,#20]
 871 007c FB68     	 ldr r3,[r7,#12]
 872 007e 93F82630 	 ldrb r3,[r3,#38]
 873 0082 5B01     	 lsls r3,r3,#5
 874 0084 1344     	 add r3,r3,r2
 875 0086 7A68     	 ldr r2,[r7,#4]
 876 0088 5A60     	 str r2,[r3,#4]
 877 008a 11E0     	 b .L33
 878              	.L32:
 355:../Libraries/XMCLib/src/xmc_eth_mac.c ****     }
 356:../Libraries/XMCLib/src/xmc_eth_mac.c ****     else
 357:../Libraries/XMCLib/src/xmc_eth_mac.c ****     {
 358:../Libraries/XMCLib/src/xmc_eth_mac.c ****       /* Sending data fragments in progress */
 359:../Libraries/XMCLib/src/xmc_eth_mac.c ****       eth_mac->tx_desc[eth_mac->tx_index].length += len;
 879              	 .loc 3 359 0
 880 008c FB68     	 ldr r3,[r7,#12]
 881 008e 5A69     	 ldr r2,[r3,#20]
 882 0090 FB68     	 ldr r3,[r7,#12]
 883 0092 93F82630 	 ldrb r3,[r3,#38]
 884 0096 5B01     	 lsls r3,r3,#5
 885 0098 1344     	 add r3,r3,r2
 886 009a FA68     	 ldr r2,[r7,#12]
 887 009c 5169     	 ldr r1,[r2,#20]
 888 009e FA68     	 ldr r2,[r7,#12]
 889 00a0 92F82620 	 ldrb r2,[r2,#38]
 890 00a4 5201     	 lsls r2,r2,#5
 891 00a6 0A44     	 add r2,r2,r1
 892 00a8 5168     	 ldr r1,[r2,#4]
 893 00aa 7A68     	 ldr r2,[r7,#4]
 894 00ac 0A44     	 add r2,r2,r1
 895 00ae 5A60     	 str r2,[r3,#4]
 896              	.L33:
 360:../Libraries/XMCLib/src/xmc_eth_mac.c ****     }
 361:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 362:../Libraries/XMCLib/src/xmc_eth_mac.c ****     memcpy(dst, frame, len);
 897              	 .loc 3 362 0
 898 00b0 B869     	 ldr r0,[r7,#24]
 899 00b2 B968     	 ldr r1,[r7,#8]
 900 00b4 7A68     	 ldr r2,[r7,#4]
 901 00b6 FFF7FEFF 	 bl memcpy
 363:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 364:../Libraries/XMCLib/src/xmc_eth_mac.c ****     if (flags & (uint32_t)XMC_ETH_MAC_TX_FRAME_FRAGMENT)
 902              	 .loc 3 364 0
 903 00ba 3B68     	 ldr r3,[r7]
 904 00bc 03F00103 	 and r3,r3,#1
 905 00c0 002B     	 cmp r3,#0
 906 00c2 03D0     	 beq .L34
 365:../Libraries/XMCLib/src/xmc_eth_mac.c ****     {
 366:../Libraries/XMCLib/src/xmc_eth_mac.c ****       /* More data to come, remember current write position */
 367:../Libraries/XMCLib/src/xmc_eth_mac.c ****       eth_mac->frame_end = dst;
 907              	 .loc 3 367 0
 908 00c4 FB68     	 ldr r3,[r7,#12]
 909 00c6 BA69     	 ldr r2,[r7,#24]
 910 00c8 1A62     	 str r2,[r3,#32]
 911 00ca 56E0     	 b .L35
 912              	.L34:
 368:../Libraries/XMCLib/src/xmc_eth_mac.c ****     }
 369:../Libraries/XMCLib/src/xmc_eth_mac.c ****     else
 370:../Libraries/XMCLib/src/xmc_eth_mac.c ****     {
 371:../Libraries/XMCLib/src/xmc_eth_mac.c ****       /* Frame is now ready, send it to DMA */
 372:../Libraries/XMCLib/src/xmc_eth_mac.c ****       ctrl = eth_mac->tx_desc[eth_mac->tx_index].status | ETH_MAC_DMA_TDES0_CIC;
 913              	 .loc 3 372 0
 914 00cc FB68     	 ldr r3,[r7,#12]
 915 00ce 5A69     	 ldr r2,[r3,#20]
 916 00d0 FB68     	 ldr r3,[r7,#12]
 917 00d2 93F82630 	 ldrb r3,[r3,#38]
 918 00d6 5B01     	 lsls r3,r3,#5
 919 00d8 1344     	 add r3,r3,r2
 920 00da 1B68     	 ldr r3,[r3]
 921 00dc 43F44003 	 orr r3,r3,#12582912
 922 00e0 7B61     	 str r3,[r7,#20]
 373:../Libraries/XMCLib/src/xmc_eth_mac.c ****       ctrl &= ~(ETH_MAC_DMA_TDES0_IC | ETH_MAC_DMA_TDES0_TTSE);
 923              	 .loc 3 373 0
 924 00e2 7B69     	 ldr r3,[r7,#20]
 925 00e4 23F08443 	 bic r3,r3,#1107296256
 926 00e8 7B61     	 str r3,[r7,#20]
 374:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 375:../Libraries/XMCLib/src/xmc_eth_mac.c ****       if (flags & (uint32_t)XMC_ETH_MAC_TX_FRAME_EVENT)
 927              	 .loc 3 375 0
 928 00ea 3B68     	 ldr r3,[r7]
 929 00ec 03F00203 	 and r3,r3,#2
 930 00f0 002B     	 cmp r3,#0
 931 00f2 03D0     	 beq .L36
 376:../Libraries/XMCLib/src/xmc_eth_mac.c ****       {
 377:../Libraries/XMCLib/src/xmc_eth_mac.c ****     	ctrl |= ETH_MAC_DMA_TDES0_IC;
 932              	 .loc 3 377 0
 933 00f4 7B69     	 ldr r3,[r7,#20]
 934 00f6 43F08043 	 orr r3,r3,#1073741824
 935 00fa 7B61     	 str r3,[r7,#20]
 936              	.L36:
 378:../Libraries/XMCLib/src/xmc_eth_mac.c ****       }
 379:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 380:../Libraries/XMCLib/src/xmc_eth_mac.c ****       if (flags & (uint32_t)XMC_ETH_MAC_TX_FRAME_TIMESTAMP)
 937              	 .loc 3 380 0
 938 00fc 3B68     	 ldr r3,[r7]
 939 00fe 03F00403 	 and r3,r3,#4
 940 0102 002B     	 cmp r3,#0
 941 0104 03D0     	 beq .L37
 381:../Libraries/XMCLib/src/xmc_eth_mac.c ****       {
 382:../Libraries/XMCLib/src/xmc_eth_mac.c ****     	ctrl |= ETH_MAC_DMA_TDES0_TTSE;
 942              	 .loc 3 382 0
 943 0106 7B69     	 ldr r3,[r7,#20]
 944 0108 43F00073 	 orr r3,r3,#33554432
 945 010c 7B61     	 str r3,[r7,#20]
 946              	.L37:
 383:../Libraries/XMCLib/src/xmc_eth_mac.c ****       }
 384:../Libraries/XMCLib/src/xmc_eth_mac.c ****       eth_mac->tx_ts_index = eth_mac->tx_index;
 947              	 .loc 3 384 0
 948 010e FB68     	 ldr r3,[r7,#12]
 949 0110 93F82620 	 ldrb r2,[r3,#38]
 950 0114 FB68     	 ldr r3,[r7,#12]
 951 0116 83F82820 	 strb r2,[r3,#40]
 385:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 386:../Libraries/XMCLib/src/xmc_eth_mac.c ****       eth_mac->tx_desc[eth_mac->tx_index].status = ctrl | ETH_MAC_DMA_TDES0_OWN;
 952              	 .loc 3 386 0
 953 011a FB68     	 ldr r3,[r7,#12]
 954 011c 5A69     	 ldr r2,[r3,#20]
 955 011e FB68     	 ldr r3,[r7,#12]
 956 0120 93F82630 	 ldrb r3,[r3,#38]
 957 0124 5B01     	 lsls r3,r3,#5
 958 0126 1344     	 add r3,r3,r2
 959 0128 7A69     	 ldr r2,[r7,#20]
 960 012a 42F00042 	 orr r2,r2,#-2147483648
 961 012e 1A60     	 str r2,[r3]
 387:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 388:../Libraries/XMCLib/src/xmc_eth_mac.c ****       eth_mac->tx_index++;
 962              	 .loc 3 388 0
 963 0130 FB68     	 ldr r3,[r7,#12]
 964 0132 93F82630 	 ldrb r3,[r3,#38]
 965 0136 0133     	 adds r3,r3,#1
 966 0138 DAB2     	 uxtb r2,r3
 967 013a FB68     	 ldr r3,[r7,#12]
 968 013c 83F82620 	 strb r2,[r3,#38]
 389:../Libraries/XMCLib/src/xmc_eth_mac.c ****       if (eth_mac->tx_index == eth_mac->num_tx_buf)
 969              	 .loc 3 389 0
 970 0140 FB68     	 ldr r3,[r7,#12]
 971 0142 93F82620 	 ldrb r2,[r3,#38]
 972 0146 FB68     	 ldr r3,[r7,#12]
 973 0148 93F82530 	 ldrb r3,[r3,#37]
 974 014c 9A42     	 cmp r2,r3
 975 014e 03D1     	 bne .L38
 390:../Libraries/XMCLib/src/xmc_eth_mac.c ****       {
 391:../Libraries/XMCLib/src/xmc_eth_mac.c ****     	eth_mac->tx_index = 0U;
 976              	 .loc 3 391 0
 977 0150 FB68     	 ldr r3,[r7,#12]
 978 0152 0022     	 movs r2,#0
 979 0154 83F82620 	 strb r2,[r3,#38]
 980              	.L38:
 392:../Libraries/XMCLib/src/xmc_eth_mac.c ****       }
 393:../Libraries/XMCLib/src/xmc_eth_mac.c ****       eth_mac->frame_end = NULL;
 981              	 .loc 3 393 0
 982 0158 FB68     	 ldr r3,[r7,#12]
 983 015a 0022     	 movs r2,#0
 984 015c 1A62     	 str r2,[r3,#32]
 394:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 395:../Libraries/XMCLib/src/xmc_eth_mac.c ****       /* Start frame transmission */
 396:../Libraries/XMCLib/src/xmc_eth_mac.c ****       eth_mac->regs->STATUS = (uint32_t)ETH_STATUS_TPS_Msk;
 985              	 .loc 3 396 0
 986 015e FB68     	 ldr r3,[r7,#12]
 987 0160 1B68     	 ldr r3,[r3]
 988 0162 03F58053 	 add r3,r3,#4096
 989 0166 1433     	 adds r3,r3,#20
 990 0168 0222     	 movs r2,#2
 991 016a 1A60     	 str r2,[r3]
 397:../Libraries/XMCLib/src/xmc_eth_mac.c ****       eth_mac->regs->TRANSMIT_POLL_DEMAND = 0U;
 992              	 .loc 3 397 0
 993 016c FB68     	 ldr r3,[r7,#12]
 994 016e 1B68     	 ldr r3,[r3]
 995 0170 03F58053 	 add r3,r3,#4096
 996 0174 0433     	 adds r3,r3,#4
 997 0176 0022     	 movs r2,#0
 998 0178 1A60     	 str r2,[r3]
 999              	.L35:
 398:../Libraries/XMCLib/src/xmc_eth_mac.c ****     }
 399:../Libraries/XMCLib/src/xmc_eth_mac.c ****     status = XMC_ETH_MAC_STATUS_OK;
 1000              	 .loc 3 399 0
 1001 017a 0023     	 movs r3,#0
 1002 017c FB77     	 strb r3,[r7,#31]
 1003              	.L31:
 400:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 401:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 402:../Libraries/XMCLib/src/xmc_eth_mac.c ****   return status;
 1004              	 .loc 3 402 0
 1005 017e FB7F     	 ldrb r3,[r7,#31]
 403:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 1006              	 .loc 3 403 0
 1007 0180 1846     	 mov r0,r3
 1008 0182 2037     	 adds r7,r7,#32
 1009              	.LCFI62:
 1010              	 .cfi_def_cfa_offset 8
 1011 0184 BD46     	 mov sp,r7
 1012              	.LCFI63:
 1013              	 .cfi_def_cfa_register 13
 1014              	 
 1015 0186 80BD     	 pop {r7,pc}
 1016              	 .cfi_endproc
 1017              	.LFE209:
 1019              	 .section .text.XMC_ETH_MAC_ReadFrame,"ax",%progbits
 1020              	 .align 2
 1021              	 .global XMC_ETH_MAC_ReadFrame
 1022              	 .thumb
 1023              	 .thumb_func
 1025              	XMC_ETH_MAC_ReadFrame:
 1026              	.LFB210:
 404:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 405:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Read frame */
 406:../Libraries/XMCLib/src/xmc_eth_mac.c **** uint32_t XMC_ETH_MAC_ReadFrame(XMC_ETH_MAC_t *const eth_mac, uint8_t *frame, uint32_t len)
 407:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 1027              	 .loc 3 407 0
 1028              	 .cfi_startproc
 1029              	 
 1030              	 
 1031 0000 80B5     	 push {r7,lr}
 1032              	.LCFI64:
 1033              	 .cfi_def_cfa_offset 8
 1034              	 .cfi_offset 7,-8
 1035              	 .cfi_offset 14,-4
 1036 0002 86B0     	 sub sp,sp,#24
 1037              	.LCFI65:
 1038              	 .cfi_def_cfa_offset 32
 1039 0004 00AF     	 add r7,sp,#0
 1040              	.LCFI66:
 1041              	 .cfi_def_cfa_register 7
 1042 0006 F860     	 str r0,[r7,#12]
 1043 0008 B960     	 str r1,[r7,#8]
 1044 000a 7A60     	 str r2,[r7,#4]
 408:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint8_t const *src;
 409:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 410:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_ReadFrame:", eth_mac != NULL);
 411:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_ReadFrame:", eth_mac->regs != ETH0);
 412:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_ReadFrame:", (frame != NULL) && (len > 0));
 413:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 414:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /* Fast-copy data to packet buffer */
 415:../Libraries/XMCLib/src/xmc_eth_mac.c ****   src = (uint8_t const *)eth_mac->rx_desc[eth_mac->rx_index].buffer1;
 1045              	 .loc 3 415 0
 1046 000c FB68     	 ldr r3,[r7,#12]
 1047 000e 1A69     	 ldr r2,[r3,#16]
 1048 0010 FB68     	 ldr r3,[r7,#12]
 1049 0012 93F82730 	 ldrb r3,[r3,#39]
 1050 0016 5B01     	 lsls r3,r3,#5
 1051 0018 1344     	 add r3,r3,r2
 1052 001a 9B68     	 ldr r3,[r3,#8]
 1053 001c 7B61     	 str r3,[r7,#20]
 416:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 417:../Libraries/XMCLib/src/xmc_eth_mac.c ****   memcpy(frame, src, len);
 1054              	 .loc 3 417 0
 1055 001e B868     	 ldr r0,[r7,#8]
 1056 0020 7969     	 ldr r1,[r7,#20]
 1057 0022 7A68     	 ldr r2,[r7,#4]
 1058 0024 FFF7FEFF 	 bl memcpy
 418:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 419:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /* Return this block back to DMA */
 420:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->rx_desc[eth_mac->rx_index].status = ETH_MAC_DMA_RDES0_OWN;
 1059              	 .loc 3 420 0
 1060 0028 FB68     	 ldr r3,[r7,#12]
 1061 002a 1A69     	 ldr r2,[r3,#16]
 1062 002c FB68     	 ldr r3,[r7,#12]
 1063 002e 93F82730 	 ldrb r3,[r3,#39]
 1064 0032 5B01     	 lsls r3,r3,#5
 1065 0034 1344     	 add r3,r3,r2
 1066 0036 4FF00042 	 mov r2,#-2147483648
 1067 003a 1A60     	 str r2,[r3]
 421:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 422:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->rx_index++;
 1068              	 .loc 3 422 0
 1069 003c FB68     	 ldr r3,[r7,#12]
 1070 003e 93F82730 	 ldrb r3,[r3,#39]
 1071 0042 0133     	 adds r3,r3,#1
 1072 0044 DAB2     	 uxtb r2,r3
 1073 0046 FB68     	 ldr r3,[r7,#12]
 1074 0048 83F82720 	 strb r2,[r3,#39]
 423:../Libraries/XMCLib/src/xmc_eth_mac.c ****   if (eth_mac->rx_index == eth_mac->num_rx_buf)
 1075              	 .loc 3 423 0
 1076 004c FB68     	 ldr r3,[r7,#12]
 1077 004e 93F82720 	 ldrb r2,[r3,#39]
 1078 0052 FB68     	 ldr r3,[r7,#12]
 1079 0054 93F82430 	 ldrb r3,[r3,#36]
 1080 0058 9A42     	 cmp r2,r3
 1081 005a 03D1     	 bne .L41
 424:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 425:../Libraries/XMCLib/src/xmc_eth_mac.c ****     eth_mac->rx_index = 0U;
 1082              	 .loc 3 425 0
 1083 005c FB68     	 ldr r3,[r7,#12]
 1084 005e 0022     	 movs r2,#0
 1085 0060 83F82720 	 strb r2,[r3,#39]
 1086              	.L41:
 426:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 427:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 428:../Libraries/XMCLib/src/xmc_eth_mac.c ****   if (eth_mac->regs->STATUS & ETH_STATUS_RU_Msk)
 1087              	 .loc 3 428 0
 1088 0064 FB68     	 ldr r3,[r7,#12]
 1089 0066 1B68     	 ldr r3,[r3]
 1090 0068 03F58053 	 add r3,r3,#4096
 1091 006c 1433     	 adds r3,r3,#20
 1092 006e 1B68     	 ldr r3,[r3]
 1093 0070 03F08003 	 and r3,r3,#128
 1094 0074 002B     	 cmp r3,#0
 1095 0076 0DD0     	 beq .L42
 429:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 430:../Libraries/XMCLib/src/xmc_eth_mac.c ****     /* Receive buffer unavailable, resume DMA */
 431:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	eth_mac->regs->STATUS = (uint32_t)ETH_STATUS_RU_Msk;
 1096              	 .loc 3 431 0
 1097 0078 FB68     	 ldr r3,[r7,#12]
 1098 007a 1B68     	 ldr r3,[r3]
 1099 007c 03F58053 	 add r3,r3,#4096
 1100 0080 1433     	 adds r3,r3,#20
 1101 0082 8022     	 movs r2,#128
 1102 0084 1A60     	 str r2,[r3]
 432:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	eth_mac->regs->RECEIVE_POLL_DEMAND = 0U;
 1103              	 .loc 3 432 0
 1104 0086 FB68     	 ldr r3,[r7,#12]
 1105 0088 1B68     	 ldr r3,[r3]
 1106 008a 03F58053 	 add r3,r3,#4096
 1107 008e 0833     	 adds r3,r3,#8
 1108 0090 0022     	 movs r2,#0
 1109 0092 1A60     	 str r2,[r3]
 1110              	.L42:
 433:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 434:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 435:../Libraries/XMCLib/src/xmc_eth_mac.c ****   return (len);
 1111              	 .loc 3 435 0
 1112 0094 7B68     	 ldr r3,[r7,#4]
 436:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 1113              	 .loc 3 436 0
 1114 0096 1846     	 mov r0,r3
 1115 0098 1837     	 adds r7,r7,#24
 1116              	.LCFI67:
 1117              	 .cfi_def_cfa_offset 8
 1118 009a BD46     	 mov sp,r7
 1119              	.LCFI68:
 1120              	 .cfi_def_cfa_register 13
 1121              	 
 1122 009c 80BD     	 pop {r7,pc}
 1123              	 .cfi_endproc
 1124              	.LFE210:
 1126 009e 00BF     	 .section .text.XMC_ETH_MAC_GetRxFrameSize,"ax",%progbits
 1127              	 .align 2
 1128              	 .global XMC_ETH_MAC_GetRxFrameSize
 1129              	 .thumb
 1130              	 .thumb_func
 1132              	XMC_ETH_MAC_GetRxFrameSize:
 1133              	.LFB211:
 437:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 438:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Get RX frame size */
 439:../Libraries/XMCLib/src/xmc_eth_mac.c **** uint32_t XMC_ETH_MAC_GetRxFrameSize(XMC_ETH_MAC_t *const eth_mac)
 440:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 1134              	 .loc 3 440 0
 1135              	 .cfi_startproc
 1136              	 
 1137              	 
 1138              	 
 1139 0000 80B4     	 push {r7}
 1140              	.LCFI69:
 1141              	 .cfi_def_cfa_offset 4
 1142              	 .cfi_offset 7,-4
 1143 0002 85B0     	 sub sp,sp,#20
 1144              	.LCFI70:
 1145              	 .cfi_def_cfa_offset 24
 1146 0004 00AF     	 add r7,sp,#0
 1147              	.LCFI71:
 1148              	 .cfi_def_cfa_register 7
 1149 0006 7860     	 str r0,[r7,#4]
 441:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint32_t status;
 442:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint32_t len = 0U;
 1150              	 .loc 3 442 0
 1151 0008 0023     	 movs r3,#0
 1152 000a FB60     	 str r3,[r7,#12]
 443:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 444:../Libraries/XMCLib/src/xmc_eth_mac.c ****   status = eth_mac->rx_desc[eth_mac->rx_index].status;
 1153              	 .loc 3 444 0
 1154 000c 7B68     	 ldr r3,[r7,#4]
 1155 000e 1A69     	 ldr r2,[r3,#16]
 1156 0010 7B68     	 ldr r3,[r7,#4]
 1157 0012 93F82730 	 ldrb r3,[r3,#39]
 1158 0016 5B01     	 lsls r3,r3,#5
 1159 0018 1344     	 add r3,r3,r2
 1160 001a 1B68     	 ldr r3,[r3]
 1161 001c BB60     	 str r3,[r7,#8]
 445:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 446:../Libraries/XMCLib/src/xmc_eth_mac.c ****   if (status & ETH_MAC_DMA_RDES0_OWN)
 1162              	 .loc 3 446 0
 1163 001e BB68     	 ldr r3,[r7,#8]
 1164 0020 002B     	 cmp r3,#0
 1165 0022 02DA     	 bge .L45
 447:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 448:../Libraries/XMCLib/src/xmc_eth_mac.c ****     /* Owned by DMA */
 449:../Libraries/XMCLib/src/xmc_eth_mac.c ****     len = 0U;
 1166              	 .loc 3 449 0
 1167 0024 0023     	 movs r3,#0
 1168 0026 FB60     	 str r3,[r7,#12]
 1169 0028 18E0     	 b .L46
 1170              	.L45:
 450:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 451:../Libraries/XMCLib/src/xmc_eth_mac.c ****   else if (((status & ETH_MAC_DMA_RDES0_ES) != 0U) ||
 1171              	 .loc 3 451 0
 1172 002a BB68     	 ldr r3,[r7,#8]
 1173 002c 03F40043 	 and r3,r3,#32768
 1174 0030 002B     	 cmp r3,#0
 1175 0032 09D1     	 bne .L47
 452:../Libraries/XMCLib/src/xmc_eth_mac.c ****            ((status & ETH_MAC_DMA_RDES0_FS) == 0U) ||
 1176              	 .loc 3 452 0 discriminator 1
 1177 0034 BB68     	 ldr r3,[r7,#8]
 1178 0036 03F40073 	 and r3,r3,#512
 451:../Libraries/XMCLib/src/xmc_eth_mac.c ****            ((status & ETH_MAC_DMA_RDES0_FS) == 0U) ||
 1179              	 .loc 3 451 0 discriminator 1
 1180 003a 002B     	 cmp r3,#0
 1181 003c 04D0     	 beq .L47
 453:../Libraries/XMCLib/src/xmc_eth_mac.c ****            ((status & ETH_MAC_DMA_RDES0_LS) == 0U)) 
 1182              	 .loc 3 453 0
 1183 003e BB68     	 ldr r3,[r7,#8]
 1184 0040 03F48073 	 and r3,r3,#256
 452:../Libraries/XMCLib/src/xmc_eth_mac.c ****            ((status & ETH_MAC_DMA_RDES0_FS) == 0U) ||
 1185              	 .loc 3 452 0
 1186 0044 002B     	 cmp r3,#0
 1187 0046 03D1     	 bne .L48
 1188              	.L47:
 454:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 455:../Libraries/XMCLib/src/xmc_eth_mac.c ****     /* Error, this block is invalid */
 456:../Libraries/XMCLib/src/xmc_eth_mac.c ****     len = 0xFFFFFFFFU;
 1189              	 .loc 3 456 0
 1190 0048 4FF0FF33 	 mov r3,#-1
 1191 004c FB60     	 str r3,[r7,#12]
 1192 004e 05E0     	 b .L46
 1193              	.L48:
 457:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 458:../Libraries/XMCLib/src/xmc_eth_mac.c ****   else 
 459:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 460:../Libraries/XMCLib/src/xmc_eth_mac.c ****     /* Subtract CRC */
 461:../Libraries/XMCLib/src/xmc_eth_mac.c ****     len = ((status & ETH_MAC_DMA_RDES0_FL) >> 16U) - 4U;
 1194              	 .loc 3 461 0
 1195 0050 BA68     	 ldr r2,[r7,#8]
 1196 0052 064B     	 ldr r3,.L50
 1197 0054 1340     	 ands r3,r3,r2
 1198 0056 1B0C     	 lsrs r3,r3,#16
 1199 0058 043B     	 subs r3,r3,#4
 1200 005a FB60     	 str r3,[r7,#12]
 1201              	.L46:
 462:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 463:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 464:../Libraries/XMCLib/src/xmc_eth_mac.c ****   return len;
 1202              	 .loc 3 464 0
 1203 005c FB68     	 ldr r3,[r7,#12]
 465:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 1204              	 .loc 3 465 0
 1205 005e 1846     	 mov r0,r3
 1206 0060 1437     	 adds r7,r7,#20
 1207              	.LCFI72:
 1208              	 .cfi_def_cfa_offset 4
 1209 0062 BD46     	 mov sp,r7
 1210              	.LCFI73:
 1211              	 .cfi_def_cfa_register 13
 1212              	 
 1213 0064 5DF8047B 	 ldr r7,[sp],#4
 1214              	.LCFI74:
 1215              	 .cfi_restore 7
 1216              	 .cfi_def_cfa_offset 0
 1217 0068 7047     	 bx lr
 1218              	.L51:
 1219 006a 00BF     	 .align 2
 1220              	.L50:
 1221 006c 0000FF3F 	 .word 1073676288
 1222              	 .cfi_endproc
 1223              	.LFE211:
 1225              	 .section .text.XMC_ETH_MAC_SetManagmentClockDivider,"ax",%progbits
 1226              	 .align 2
 1227              	 .global XMC_ETH_MAC_SetManagmentClockDivider
 1228              	 .thumb
 1229              	 .thumb_func
 1231              	XMC_ETH_MAC_SetManagmentClockDivider:
 1232              	.LFB212:
 466:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 467:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Set management clock divider */
 468:../Libraries/XMCLib/src/xmc_eth_mac.c **** XMC_ETH_MAC_STATUS_t XMC_ETH_MAC_SetManagmentClockDivider(XMC_ETH_MAC_t *const eth_mac)
 469:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 1233              	 .loc 3 469 0
 1234              	 .cfi_startproc
 1235              	 
 1236              	 
 1237 0000 80B5     	 push {r7,lr}
 1238              	.LCFI75:
 1239              	 .cfi_def_cfa_offset 8
 1240              	 .cfi_offset 7,-8
 1241              	 .cfi_offset 14,-4
 1242 0002 86B0     	 sub sp,sp,#24
 1243              	.LCFI76:
 1244              	 .cfi_def_cfa_offset 32
 1245 0004 00AF     	 add r7,sp,#0
 1246              	.LCFI77:
 1247              	 .cfi_def_cfa_register 7
 1248 0006 7860     	 str r0,[r7,#4]
 470:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint32_t eth_mac_clk;
 471:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ETH_MAC_STATUS_t status;
 472:../Libraries/XMCLib/src/xmc_eth_mac.c ****   __IO uint32_t *reg;
 473:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 474:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac_clk = XMC_SCU_CLOCK_GetEthernetClockFrequency();
 1249              	 .loc 3 474 0
 1250 0008 FFF7FEFF 	 bl XMC_SCU_CLOCK_GetEthernetClockFrequency
 1251 000c 3861     	 str r0,[r7,#16]
 475:../Libraries/XMCLib/src/xmc_eth_mac.c ****   status = XMC_ETH_MAC_STATUS_OK;
 1252              	 .loc 3 475 0
 1253 000e 0023     	 movs r3,#0
 1254 0010 FB75     	 strb r3,[r7,#23]
 476:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 477:../Libraries/XMCLib/src/xmc_eth_mac.c ****   reg = &(eth_mac->regs->GMII_ADDRESS);
 1255              	 .loc 3 477 0
 1256 0012 7B68     	 ldr r3,[r7,#4]
 1257 0014 1B68     	 ldr r3,[r3]
 1258 0016 1033     	 adds r3,r3,#16
 1259 0018 FB60     	 str r3,[r7,#12]
 478:../Libraries/XMCLib/src/xmc_eth_mac.c ****   if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_35MHZ)
 1260              	 .loc 3 478 0
 1261 001a 3B69     	 ldr r3,[r7,#16]
 1262 001c 1A4A     	 ldr r2,.L61
 1263 001e 9342     	 cmp r3,r2
 1264 0020 03D8     	 bhi .L53
 479:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 480:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	*reg = XMC_ETH_MAC_MDC_DIVIDER_16;
 1265              	 .loc 3 480 0
 1266 0022 FB68     	 ldr r3,[r7,#12]
 1267 0024 0822     	 movs r2,#8
 1268 0026 1A60     	 str r2,[r3]
 1269 0028 29E0     	 b .L54
 1270              	.L53:
 481:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 482:../Libraries/XMCLib/src/xmc_eth_mac.c ****   else if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_60MHZ)
 1271              	 .loc 3 482 0
 1272 002a 3B69     	 ldr r3,[r7,#16]
 1273 002c 174A     	 ldr r2,.L61+4
 1274 002e 9342     	 cmp r3,r2
 1275 0030 03D8     	 bhi .L55
 483:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 484:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	*reg = XMC_ETH_MAC_MDC_DIVIDER_26;
 1276              	 .loc 3 484 0
 1277 0032 FB68     	 ldr r3,[r7,#12]
 1278 0034 0C22     	 movs r2,#12
 1279 0036 1A60     	 str r2,[r3]
 1280 0038 21E0     	 b .L54
 1281              	.L55:
 485:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 486:../Libraries/XMCLib/src/xmc_eth_mac.c ****   else if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_100MHZ)
 1282              	 .loc 3 486 0
 1283 003a 3B69     	 ldr r3,[r7,#16]
 1284 003c 144A     	 ldr r2,.L61+8
 1285 003e 9342     	 cmp r3,r2
 1286 0040 03D8     	 bhi .L56
 487:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 488:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	*reg = XMC_ETH_MAC_MDC_DIVIDER_42;
 1287              	 .loc 3 488 0
 1288 0042 FB68     	 ldr r3,[r7,#12]
 1289 0044 0022     	 movs r2,#0
 1290 0046 1A60     	 str r2,[r3]
 1291 0048 19E0     	 b .L54
 1292              	.L56:
 489:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 490:../Libraries/XMCLib/src/xmc_eth_mac.c ****   else if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_150MHZ)
 1293              	 .loc 3 490 0
 1294 004a 3B69     	 ldr r3,[r7,#16]
 1295 004c 114A     	 ldr r2,.L61+12
 1296 004e 9342     	 cmp r3,r2
 1297 0050 03D8     	 bhi .L57
 491:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 492:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	*reg = XMC_ETH_MAC_MDC_DIVIDER_62;
 1298              	 .loc 3 492 0
 1299 0052 FB68     	 ldr r3,[r7,#12]
 1300 0054 0422     	 movs r2,#4
 1301 0056 1A60     	 str r2,[r3]
 1302 0058 11E0     	 b .L54
 1303              	.L57:
 493:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 494:../Libraries/XMCLib/src/xmc_eth_mac.c ****   else if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_200MHZ)
 1304              	 .loc 3 494 0
 1305 005a 3B69     	 ldr r3,[r7,#16]
 1306 005c 0E4A     	 ldr r2,.L61+16
 1307 005e 9342     	 cmp r3,r2
 1308 0060 03D8     	 bhi .L58
 495:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 496:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	*reg = XMC_ETH_MAC_MDC_DIVIDER_102;
 1309              	 .loc 3 496 0
 1310 0062 FB68     	 ldr r3,[r7,#12]
 1311 0064 1022     	 movs r2,#16
 1312 0066 1A60     	 str r2,[r3]
 1313 0068 09E0     	 b .L54
 1314              	.L58:
 497:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 498:../Libraries/XMCLib/src/xmc_eth_mac.c ****   else if (eth_mac_clk <= XMC_ETH_MAC_CLK_SPEED_250MHZ)
 1315              	 .loc 3 498 0
 1316 006a 3B69     	 ldr r3,[r7,#16]
 1317 006c 0B4A     	 ldr r2,.L61+20
 1318 006e 9342     	 cmp r3,r2
 1319 0070 03D8     	 bhi .L59
 499:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 500:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	*reg = XMC_ETH_MAC_MDC_DIVIDER_124;
 1320              	 .loc 3 500 0
 1321 0072 FB68     	 ldr r3,[r7,#12]
 1322 0074 1422     	 movs r2,#20
 1323 0076 1A60     	 str r2,[r3]
 1324 0078 01E0     	 b .L54
 1325              	.L59:
 501:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 502:../Libraries/XMCLib/src/xmc_eth_mac.c ****   else
 503:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 504:../Libraries/XMCLib/src/xmc_eth_mac.c ****     status = XMC_ETH_MAC_STATUS_ERROR;
 1326              	 .loc 3 504 0
 1327 007a 0223     	 movs r3,#2
 1328 007c FB75     	 strb r3,[r7,#23]
 1329              	.L54:
 505:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 506:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 507:../Libraries/XMCLib/src/xmc_eth_mac.c ****   return status;
 1330              	 .loc 3 507 0
 1331 007e FB7D     	 ldrb r3,[r7,#23]
 508:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 1332              	 .loc 3 508 0
 1333 0080 1846     	 mov r0,r3
 1334 0082 1837     	 adds r7,r7,#24
 1335              	.LCFI78:
 1336              	 .cfi_def_cfa_offset 8
 1337 0084 BD46     	 mov sp,r7
 1338              	.LCFI79:
 1339              	 .cfi_def_cfa_register 13
 1340              	 
 1341 0086 80BD     	 pop {r7,pc}
 1342              	.L62:
 1343              	 .align 2
 1344              	.L61:
 1345 0088 C00E1602 	 .word 35000000
 1346 008c 00879303 	 .word 60000000
 1347 0090 00E1F505 	 .word 100000000
 1348 0094 80D1F008 	 .word 150000000
 1349 0098 00C2EB0B 	 .word 200000000
 1350 009c 80B2E60E 	 .word 250000000
 1351              	 .cfi_endproc
 1352              	.LFE212:
 1354              	 .section .text.XMC_ETH_MAC_Enable,"ax",%progbits
 1355              	 .align 2
 1356              	 .global XMC_ETH_MAC_Enable
 1357              	 .thumb
 1358              	 .thumb_func
 1360              	XMC_ETH_MAC_Enable:
 1361              	.LFB213:
 509:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 510:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* ETH MAC enable */
 511:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_Enable(XMC_ETH_MAC_t *const eth_mac)
 512:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 1362              	 .loc 3 512 0
 1363              	 .cfi_startproc
 1364              	 
 1365              	 
 1366 0000 80B5     	 push {r7,lr}
 1367              	.LCFI80:
 1368              	 .cfi_def_cfa_offset 8
 1369              	 .cfi_offset 7,-8
 1370              	 .cfi_offset 14,-4
 1371 0002 82B0     	 sub sp,sp,#8
 1372              	.LCFI81:
 1373              	 .cfi_def_cfa_offset 16
 1374 0004 00AF     	 add r7,sp,#0
 1375              	.LCFI82:
 1376              	 .cfi_def_cfa_register 7
 1377 0006 7860     	 str r0,[r7,#4]
 513:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_ETH);
 1378              	 .loc 3 513 0
 1379 0008 0420     	 movs r0,#4
 1380 000a FFF7FEFF 	 bl XMC_SCU_CLOCK_EnableClock
 514:../Libraries/XMCLib/src/xmc_eth_mac.c **** #if UC_DEVICE != XMC4500
 515:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_ETH0);
 1381              	 .loc 3 515 0
 1382 000e 0448     	 ldr r0,.L64
 1383 0010 FFF7FEFF 	 bl XMC_SCU_CLOCK_UngatePeripheralClock
 516:../Libraries/XMCLib/src/xmc_eth_mac.c **** #endif
 517:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_ETH0);
 1384              	 .loc 3 517 0
 1385 0014 0248     	 ldr r0,.L64
 1386 0016 FFF7FEFF 	 bl XMC_SCU_RESET_DeassertPeripheralReset
 518:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 1387              	 .loc 3 518 0
 1388 001a 0837     	 adds r7,r7,#8
 1389              	.LCFI83:
 1390              	 .cfi_def_cfa_offset 8
 1391 001c BD46     	 mov sp,r7
 1392              	.LCFI84:
 1393              	 .cfi_def_cfa_register 13
 1394              	 
 1395 001e 80BD     	 pop {r7,pc}
 1396              	.L65:
 1397              	 .align 2
 1398              	.L64:
 1399 0020 04000020 	 .word 536870916
 1400              	 .cfi_endproc
 1401              	.LFE213:
 1403              	 .section .text.XMC_ETH_MAC_Disable,"ax",%progbits
 1404              	 .align 2
 1405              	 .global XMC_ETH_MAC_Disable
 1406              	 .thumb
 1407              	 .thumb_func
 1409              	XMC_ETH_MAC_Disable:
 1410              	.LFB214:
 519:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 520:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* ETH MAC disable */
 521:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_Disable(XMC_ETH_MAC_t *const eth_mac)
 522:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 1411              	 .loc 3 522 0
 1412              	 .cfi_startproc
 1413              	 
 1414              	 
 1415 0000 80B5     	 push {r7,lr}
 1416              	.LCFI85:
 1417              	 .cfi_def_cfa_offset 8
 1418              	 .cfi_offset 7,-8
 1419              	 .cfi_offset 14,-4
 1420 0002 82B0     	 sub sp,sp,#8
 1421              	.LCFI86:
 1422              	 .cfi_def_cfa_offset 16
 1423 0004 00AF     	 add r7,sp,#0
 1424              	.LCFI87:
 1425              	 .cfi_def_cfa_register 7
 1426 0006 7860     	 str r0,[r7,#4]
 523:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_SCU_RESET_AssertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_ETH0);
 1427              	 .loc 3 523 0
 1428 0008 0548     	 ldr r0,.L67
 1429 000a FFF7FEFF 	 bl XMC_SCU_RESET_AssertPeripheralReset
 524:../Libraries/XMCLib/src/xmc_eth_mac.c **** #if UC_DEVICE != XMC4500
 525:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_SCU_CLOCK_GatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_ETH0);
 1430              	 .loc 3 525 0
 1431 000e 0448     	 ldr r0,.L67
 1432 0010 FFF7FEFF 	 bl XMC_SCU_CLOCK_GatePeripheralClock
 526:../Libraries/XMCLib/src/xmc_eth_mac.c **** #endif
 527:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_SCU_CLOCK_DisableClock(XMC_SCU_CLOCK_ETH);
 1433              	 .loc 3 527 0
 1434 0014 0420     	 movs r0,#4
 1435 0016 FFF7FEFF 	 bl XMC_SCU_CLOCK_DisableClock
 528:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 1436              	 .loc 3 528 0
 1437 001a 0837     	 adds r7,r7,#8
 1438              	.LCFI88:
 1439              	 .cfi_def_cfa_offset 8
 1440 001c BD46     	 mov sp,r7
 1441              	.LCFI89:
 1442              	 .cfi_def_cfa_register 13
 1443              	 
 1444 001e 80BD     	 pop {r7,pc}
 1445              	.L68:
 1446              	 .align 2
 1447              	.L67:
 1448 0020 04000020 	 .word 536870916
 1449              	 .cfi_endproc
 1450              	.LFE214:
 1452              	 .section .text.XMC_ETH_MAC_ReadPhy,"ax",%progbits
 1453              	 .align 2
 1454              	 .global XMC_ETH_MAC_ReadPhy
 1455              	 .thumb
 1456              	 .thumb_func
 1458              	XMC_ETH_MAC_ReadPhy:
 1459              	.LFB215:
 529:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 530:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Read physical layer and obtain status */
 531:../Libraries/XMCLib/src/xmc_eth_mac.c **** XMC_ETH_MAC_STATUS_t XMC_ETH_MAC_ReadPhy(XMC_ETH_MAC_t *eth_mac, uint8_t phy_addr, uint8_t reg_addr
 532:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 1460              	 .loc 3 532 0
 1461              	 .cfi_startproc
 1462              	 
 1463              	 
 1464              	 
 1465 0000 80B4     	 push {r7}
 1466              	.LCFI90:
 1467              	 .cfi_def_cfa_offset 4
 1468              	 .cfi_offset 7,-4
 1469 0002 87B0     	 sub sp,sp,#28
 1470              	.LCFI91:
 1471              	 .cfi_def_cfa_offset 32
 1472 0004 00AF     	 add r7,sp,#0
 1473              	.LCFI92:
 1474              	 .cfi_def_cfa_register 7
 1475 0006 F860     	 str r0,[r7,#12]
 1476 0008 7B60     	 str r3,[r7,#4]
 1477 000a 0B46     	 mov r3,r1
 1478 000c FB72     	 strb r3,[r7,#11]
 1479 000e 1346     	 mov r3,r2
 1480 0010 BB72     	 strb r3,[r7,#10]
 533:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint32_t retries;
 534:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 535:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_PhyRead: Parameter error", data != NULL);
 536:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 537:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->GMII_ADDRESS = (uint32_t)((eth_mac->regs->GMII_ADDRESS & (uint32_t)ETH_GMII_ADDRES
 1481              	 .loc 3 537 0
 1482 0012 FB68     	 ldr r3,[r7,#12]
 1483 0014 1B68     	 ldr r3,[r3]
 1484 0016 FA68     	 ldr r2,[r7,#12]
 1485 0018 1268     	 ldr r2,[r2]
 1486 001a 1269     	 ldr r2,[r2,#16]
 1487 001c 02F03C01 	 and r1,r2,#60
 538:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                            (uint32_t)ETH_GMII_ADDRESS_MB_Msk |
 539:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                            (uint32_t)((uint32_t)phy_addr << ETH_GMII_ADDRESS_PA_Pos
 1488              	 .loc 3 539 0
 1489 0020 FA7A     	 ldrb r2,[r7,#11]
 1490 0022 D202     	 lsls r2,r2,#11
 538:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                            (uint32_t)ETH_GMII_ADDRESS_MB_Msk |
 1491              	 .loc 3 538 0
 1492 0024 1143     	 orrs r1,r1,r2
 540:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                            (uint32_t)((uint32_t)reg_addr << ETH_GMII_ADDRESS_MR_Pos
 1493              	 .loc 3 540 0
 1494 0026 BA7A     	 ldrb r2,[r7,#10]
 1495 0028 9201     	 lsls r2,r2,#6
 537:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                            (uint32_t)ETH_GMII_ADDRESS_MB_Msk |
 1496              	 .loc 3 537 0
 1497 002a 0A43     	 orrs r2,r2,r1
 1498 002c 42F00102 	 orr r2,r2,#1
 1499 0030 1A61     	 str r2,[r3,#16]
 541:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 542:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /* Poll busy bit during max PHY_TIMEOUT time */
 543:../Libraries/XMCLib/src/xmc_eth_mac.c ****   retries = 0U;
 1500              	 .loc 3 543 0
 1501 0032 0023     	 movs r3,#0
 1502 0034 7B61     	 str r3,[r7,#20]
 1503              	.L72:
 544:../Libraries/XMCLib/src/xmc_eth_mac.c ****   do
 545:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 546:../Libraries/XMCLib/src/xmc_eth_mac.c ****     if ((eth_mac->regs->GMII_ADDRESS & ETH_GMII_ADDRESS_MB_Msk) == 0U)
 1504              	 .loc 3 546 0
 1505 0036 FB68     	 ldr r3,[r7,#12]
 1506 0038 1B68     	 ldr r3,[r3]
 1507 003a 1B69     	 ldr r3,[r3,#16]
 1508 003c 03F00103 	 and r3,r3,#1
 1509 0040 002B     	 cmp r3,#0
 1510 0042 07D1     	 bne .L70
 547:../Libraries/XMCLib/src/xmc_eth_mac.c ****     {
 548:../Libraries/XMCLib/src/xmc_eth_mac.c ****       *data = (uint16_t)(eth_mac->regs->GMII_DATA & ETH_GMII_DATA_MD_Msk);
 1511              	 .loc 3 548 0
 1512 0044 FB68     	 ldr r3,[r7,#12]
 1513 0046 1B68     	 ldr r3,[r3]
 1514 0048 5B69     	 ldr r3,[r3,#20]
 1515 004a 9AB2     	 uxth r2,r3
 1516 004c 7B68     	 ldr r3,[r7,#4]
 1517 004e 1A80     	 strh r2,[r3]
 549:../Libraries/XMCLib/src/xmc_eth_mac.c ****       return XMC_ETH_MAC_STATUS_OK;
 1518              	 .loc 3 549 0
 1519 0050 0023     	 movs r3,#0
 1520 0052 08E0     	 b .L71
 1521              	.L70:
 550:../Libraries/XMCLib/src/xmc_eth_mac.c ****     }
 551:../Libraries/XMCLib/src/xmc_eth_mac.c ****     ++retries;
 1522              	 .loc 3 551 0
 1523 0054 7B69     	 ldr r3,[r7,#20]
 1524 0056 0133     	 adds r3,r3,#1
 1525 0058 7B61     	 str r3,[r7,#20]
 552:../Libraries/XMCLib/src/xmc_eth_mac.c ****   } while (retries < XMC_ETH_MAC_PHY_MAX_RETRIES);
 1526              	 .loc 3 552 0
 1527 005a 7B69     	 ldr r3,[r7,#20]
 1528 005c 4FF6FE72 	 movw r2,#65534
 1529 0060 9342     	 cmp r3,r2
 1530 0062 E8D9     	 bls .L72
 553:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 554:../Libraries/XMCLib/src/xmc_eth_mac.c ****   return XMC_ETH_MAC_STATUS_ERROR;
 1531              	 .loc 3 554 0
 1532 0064 0223     	 movs r3,#2
 1533              	.L71:
 555:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 1534              	 .loc 3 555 0
 1535 0066 1846     	 mov r0,r3
 1536 0068 1C37     	 adds r7,r7,#28
 1537              	.LCFI93:
 1538              	 .cfi_def_cfa_offset 4
 1539 006a BD46     	 mov sp,r7
 1540              	.LCFI94:
 1541              	 .cfi_def_cfa_register 13
 1542              	 
 1543 006c 5DF8047B 	 ldr r7,[sp],#4
 1544              	.LCFI95:
 1545              	 .cfi_restore 7
 1546              	 .cfi_def_cfa_offset 0
 1547 0070 7047     	 bx lr
 1548              	 .cfi_endproc
 1549              	.LFE215:
 1551 0072 00BF     	 .section .text.XMC_ETH_MAC_WritePhy,"ax",%progbits
 1552              	 .align 2
 1553              	 .global XMC_ETH_MAC_WritePhy
 1554              	 .thumb
 1555              	 .thumb_func
 1557              	XMC_ETH_MAC_WritePhy:
 1558              	.LFB216:
 556:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 557:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Write physical layer and return status */
 558:../Libraries/XMCLib/src/xmc_eth_mac.c **** XMC_ETH_MAC_STATUS_t XMC_ETH_MAC_WritePhy(XMC_ETH_MAC_t *eth_mac, uint8_t phy_addr, uint8_t reg_add
 559:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 1559              	 .loc 3 559 0
 1560              	 .cfi_startproc
 1561              	 
 1562              	 
 1563              	 
 1564 0000 80B4     	 push {r7}
 1565              	.LCFI96:
 1566              	 .cfi_def_cfa_offset 4
 1567              	 .cfi_offset 7,-4
 1568 0002 85B0     	 sub sp,sp,#20
 1569              	.LCFI97:
 1570              	 .cfi_def_cfa_offset 24
 1571 0004 00AF     	 add r7,sp,#0
 1572              	.LCFI98:
 1573              	 .cfi_def_cfa_register 7
 1574 0006 7860     	 str r0,[r7,#4]
 1575 0008 0846     	 mov r0,r1
 1576 000a 1146     	 mov r1,r2
 1577 000c 1A46     	 mov r2,r3
 1578 000e 0346     	 mov r3,r0
 1579 0010 FB70     	 strb r3,[r7,#3]
 1580 0012 0B46     	 mov r3,r1
 1581 0014 BB70     	 strb r3,[r7,#2]
 1582 0016 1346     	 mov r3,r2
 1583 0018 3B80     	 strh r3,[r7]
 560:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint32_t retries;
 561:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 562:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->GMII_DATA  = data;
 1584              	 .loc 3 562 0
 1585 001a 7B68     	 ldr r3,[r7,#4]
 1586 001c 1B68     	 ldr r3,[r3]
 1587 001e 3A88     	 ldrh r2,[r7]
 1588 0020 5A61     	 str r2,[r3,#20]
 563:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->GMII_ADDRESS = (uint32_t)((eth_mac->regs->GMII_ADDRESS & (uint32_t)ETH_GMII_ADDRES
 1589              	 .loc 3 563 0
 1590 0022 7B68     	 ldr r3,[r7,#4]
 1591 0024 1B68     	 ldr r3,[r3]
 1592 0026 7A68     	 ldr r2,[r7,#4]
 1593 0028 1268     	 ldr r2,[r2]
 1594 002a 1269     	 ldr r2,[r2,#16]
 1595 002c 02F03C01 	 and r1,r2,#60
 564:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                            (uint32_t)ETH_GMII_ADDRESS_MB_Msk |
 565:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                            (uint32_t)ETH_GMII_ADDRESS_MW_Msk |
 566:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                            (uint32_t)((uint32_t)phy_addr << ETH_GMII_ADDRESS_PA_Pos
 1596              	 .loc 3 566 0
 1597 0030 FA78     	 ldrb r2,[r7,#3]
 1598 0032 D202     	 lsls r2,r2,#11
 565:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                            (uint32_t)((uint32_t)phy_addr << ETH_GMII_ADDRESS_PA_Pos
 1599              	 .loc 3 565 0
 1600 0034 1143     	 orrs r1,r1,r2
 567:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                            (uint32_t)((uint32_t)reg_addr << ETH_GMII_ADDRESS_MR_Pos
 1601              	 .loc 3 567 0
 1602 0036 BA78     	 ldrb r2,[r7,#2]
 1603 0038 9201     	 lsls r2,r2,#6
 563:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                            (uint32_t)ETH_GMII_ADDRESS_MB_Msk |
 1604              	 .loc 3 563 0
 1605 003a 0A43     	 orrs r2,r2,r1
 1606 003c 42F00302 	 orr r2,r2,#3
 1607 0040 1A61     	 str r2,[r3,#16]
 568:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 569:../Libraries/XMCLib/src/xmc_eth_mac.c ****    /* Poll busy bit during max PHY_TIMEOUT time */
 570:../Libraries/XMCLib/src/xmc_eth_mac.c ****   retries = 0U;
 1608              	 .loc 3 570 0
 1609 0042 0023     	 movs r3,#0
 1610 0044 FB60     	 str r3,[r7,#12]
 1611              	.L76:
 571:../Libraries/XMCLib/src/xmc_eth_mac.c ****   do
 572:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 573:../Libraries/XMCLib/src/xmc_eth_mac.c ****     if ((eth_mac->regs->GMII_ADDRESS & ETH_GMII_ADDRESS_MB_Msk) == 0U)
 1612              	 .loc 3 573 0
 1613 0046 7B68     	 ldr r3,[r7,#4]
 1614 0048 1B68     	 ldr r3,[r3]
 1615 004a 1B69     	 ldr r3,[r3,#16]
 1616 004c 03F00103 	 and r3,r3,#1
 1617 0050 002B     	 cmp r3,#0
 1618 0052 01D1     	 bne .L74
 574:../Libraries/XMCLib/src/xmc_eth_mac.c ****     {
 575:../Libraries/XMCLib/src/xmc_eth_mac.c ****       return XMC_ETH_MAC_STATUS_OK;
 1619              	 .loc 3 575 0
 1620 0054 0023     	 movs r3,#0
 1621 0056 08E0     	 b .L75
 1622              	.L74:
 576:../Libraries/XMCLib/src/xmc_eth_mac.c ****     }
 577:../Libraries/XMCLib/src/xmc_eth_mac.c ****     ++retries;
 1623              	 .loc 3 577 0
 1624 0058 FB68     	 ldr r3,[r7,#12]
 1625 005a 0133     	 adds r3,r3,#1
 1626 005c FB60     	 str r3,[r7,#12]
 578:../Libraries/XMCLib/src/xmc_eth_mac.c ****   } while (retries < XMC_ETH_MAC_PHY_MAX_RETRIES);
 1627              	 .loc 3 578 0
 1628 005e FB68     	 ldr r3,[r7,#12]
 1629 0060 4FF6FE72 	 movw r2,#65534
 1630 0064 9342     	 cmp r3,r2
 1631 0066 EED9     	 bls .L76
 579:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 580:../Libraries/XMCLib/src/xmc_eth_mac.c ****   return XMC_ETH_MAC_STATUS_ERROR;
 1632              	 .loc 3 580 0
 1633 0068 0223     	 movs r3,#2
 1634              	.L75:
 581:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 1635              	 .loc 3 581 0
 1636 006a 1846     	 mov r0,r3
 1637 006c 1437     	 adds r7,r7,#20
 1638              	.LCFI99:
 1639              	 .cfi_def_cfa_offset 4
 1640 006e BD46     	 mov sp,r7
 1641              	.LCFI100:
 1642              	 .cfi_def_cfa_register 13
 1643              	 
 1644 0070 5DF8047B 	 ldr r7,[sp],#4
 1645              	.LCFI101:
 1646              	 .cfi_restore 7
 1647              	 .cfi_def_cfa_offset 0
 1648 0074 7047     	 bx lr
 1649              	 .cfi_endproc
 1650              	.LFE216:
 1652 0076 00BF     	 .section .text.XMC_ETH_MAC_FlushTx,"ax",%progbits
 1653              	 .align 2
 1654              	 .global XMC_ETH_MAC_FlushTx
 1655              	 .thumb
 1656              	 .thumb_func
 1658              	XMC_ETH_MAC_FlushTx:
 1659              	.LFB217:
 582:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 583:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Flush TX */
 584:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_FlushTx(XMC_ETH_MAC_t *const eth_mac)
 585:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 1660              	 .loc 3 585 0
 1661              	 .cfi_startproc
 1662              	 
 1663              	 
 1664 0000 80B5     	 push {r7,lr}
 1665              	.LCFI102:
 1666              	 .cfi_def_cfa_offset 8
 1667              	 .cfi_offset 7,-8
 1668              	 .cfi_offset 14,-4
 1669 0002 82B0     	 sub sp,sp,#8
 1670              	.LCFI103:
 1671              	 .cfi_def_cfa_offset 16
 1672 0004 00AF     	 add r7,sp,#0
 1673              	.LCFI104:
 1674              	 .cfi_def_cfa_register 7
 1675 0006 7860     	 str r0,[r7,#4]
 586:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->OPERATION_MODE &= (uint32_t)~ETH_OPERATION_MODE_ST_Msk;
 1676              	 .loc 3 586 0
 1677 0008 7B68     	 ldr r3,[r7,#4]
 1678 000a 1968     	 ldr r1,[r3]
 1679 000c 7B68     	 ldr r3,[r7,#4]
 1680 000e 1B68     	 ldr r3,[r3]
 1681 0010 03F58053 	 add r3,r3,#4096
 1682 0014 1833     	 adds r3,r3,#24
 1683 0016 1B68     	 ldr r3,[r3]
 1684 0018 23F40052 	 bic r2,r3,#8192
 1685 001c 01F58053 	 add r3,r1,#4096
 1686 0020 1833     	 adds r3,r3,#24
 1687 0022 1A60     	 str r2,[r3]
 587:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ETH_MAC_InitTxDescriptors(eth_mac);
 1688              	 .loc 3 587 0
 1689 0024 7868     	 ldr r0,[r7,#4]
 1690 0026 FFF7FEFF 	 bl XMC_ETH_MAC_InitTxDescriptors
 588:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->OPERATION_MODE |= (uint32_t)ETH_OPERATION_MODE_ST_Msk;
 1691              	 .loc 3 588 0
 1692 002a 7B68     	 ldr r3,[r7,#4]
 1693 002c 1968     	 ldr r1,[r3]
 1694 002e 7B68     	 ldr r3,[r7,#4]
 1695 0030 1B68     	 ldr r3,[r3]
 1696 0032 03F58053 	 add r3,r3,#4096
 1697 0036 1833     	 adds r3,r3,#24
 1698 0038 1B68     	 ldr r3,[r3]
 1699 003a 43F40052 	 orr r2,r3,#8192
 1700 003e 01F58053 	 add r3,r1,#4096
 1701 0042 1833     	 adds r3,r3,#24
 1702 0044 1A60     	 str r2,[r3]
 589:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 1703              	 .loc 3 589 0
 1704 0046 0837     	 adds r7,r7,#8
 1705              	.LCFI105:
 1706              	 .cfi_def_cfa_offset 8
 1707 0048 BD46     	 mov sp,r7
 1708              	.LCFI106:
 1709              	 .cfi_def_cfa_register 13
 1710              	 
 1711 004a 80BD     	 pop {r7,pc}
 1712              	 .cfi_endproc
 1713              	.LFE217:
 1715              	 .section .text.XMC_ETH_MAC_FlushRx,"ax",%progbits
 1716              	 .align 2
 1717              	 .global XMC_ETH_MAC_FlushRx
 1718              	 .thumb
 1719              	 .thumb_func
 1721              	XMC_ETH_MAC_FlushRx:
 1722              	.LFB218:
 590:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 591:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Flush RX */
 592:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_FlushRx(XMC_ETH_MAC_t *const eth_mac)
 593:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 1723              	 .loc 3 593 0
 1724              	 .cfi_startproc
 1725              	 
 1726              	 
 1727 0000 80B5     	 push {r7,lr}
 1728              	.LCFI107:
 1729              	 .cfi_def_cfa_offset 8
 1730              	 .cfi_offset 7,-8
 1731              	 .cfi_offset 14,-4
 1732 0002 82B0     	 sub sp,sp,#8
 1733              	.LCFI108:
 1734              	 .cfi_def_cfa_offset 16
 1735 0004 00AF     	 add r7,sp,#0
 1736              	.LCFI109:
 1737              	 .cfi_def_cfa_register 7
 1738 0006 7860     	 str r0,[r7,#4]
 594:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->OPERATION_MODE &= (uint32_t)~ETH_OPERATION_MODE_SR_Msk;
 1739              	 .loc 3 594 0
 1740 0008 7B68     	 ldr r3,[r7,#4]
 1741 000a 1968     	 ldr r1,[r3]
 1742 000c 7B68     	 ldr r3,[r7,#4]
 1743 000e 1B68     	 ldr r3,[r3]
 1744 0010 03F58053 	 add r3,r3,#4096
 1745 0014 1833     	 adds r3,r3,#24
 1746 0016 1B68     	 ldr r3,[r3]
 1747 0018 23F00202 	 bic r2,r3,#2
 1748 001c 01F58053 	 add r3,r1,#4096
 1749 0020 1833     	 adds r3,r3,#24
 1750 0022 1A60     	 str r2,[r3]
 595:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ETH_MAC_InitRxDescriptors(eth_mac);
 1751              	 .loc 3 595 0
 1752 0024 7868     	 ldr r0,[r7,#4]
 1753 0026 FFF7FEFF 	 bl XMC_ETH_MAC_InitRxDescriptors
 596:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->OPERATION_MODE |= (uint32_t)ETH_OPERATION_MODE_SR_Msk;
 1754              	 .loc 3 596 0
 1755 002a 7B68     	 ldr r3,[r7,#4]
 1756 002c 1968     	 ldr r1,[r3]
 1757 002e 7B68     	 ldr r3,[r7,#4]
 1758 0030 1B68     	 ldr r3,[r3]
 1759 0032 03F58053 	 add r3,r3,#4096
 1760 0036 1833     	 adds r3,r3,#24
 1761 0038 1B68     	 ldr r3,[r3]
 1762 003a 43F00202 	 orr r2,r3,#2
 1763 003e 01F58053 	 add r3,r1,#4096
 1764 0042 1833     	 adds r3,r3,#24
 1765 0044 1A60     	 str r2,[r3]
 597:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 1766              	 .loc 3 597 0
 1767 0046 0837     	 adds r7,r7,#8
 1768              	.LCFI110:
 1769              	 .cfi_def_cfa_offset 8
 1770 0048 BD46     	 mov sp,r7
 1771              	.LCFI111:
 1772              	 .cfi_def_cfa_register 13
 1773              	 
 1774 004a 80BD     	 pop {r7,pc}
 1775              	 .cfi_endproc
 1776              	.LFE218:
 1778              	 .section .text.XMC_ETH_MAC_SetWakeUpFrameFilter,"ax",%progbits
 1779              	 .align 2
 1780              	 .global XMC_ETH_MAC_SetWakeUpFrameFilter
 1781              	 .thumb
 1782              	 .thumb_func
 1784              	XMC_ETH_MAC_SetWakeUpFrameFilter:
 1785              	.LFB219:
 598:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 599:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Set wakeup frame filter */
 600:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_SetWakeUpFrameFilter(XMC_ETH_MAC_t *const eth_mac,
 601:../Libraries/XMCLib/src/xmc_eth_mac.c ****                                       const uint32_t (*const filter)[XMC_ETH_WAKEUP_REGISTER_LENGTH
 602:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 1786              	 .loc 3 602 0
 1787              	 .cfi_startproc
 1788              	 
 1789              	 
 1790              	 
 1791 0000 80B4     	 push {r7}
 1792              	.LCFI112:
 1793              	 .cfi_def_cfa_offset 4
 1794              	 .cfi_offset 7,-4
 1795 0002 85B0     	 sub sp,sp,#20
 1796              	.LCFI113:
 1797              	 .cfi_def_cfa_offset 24
 1798 0004 00AF     	 add r7,sp,#0
 1799              	.LCFI114:
 1800              	 .cfi_def_cfa_register 7
 1801 0006 7860     	 str r0,[r7,#4]
 1802 0008 3960     	 str r1,[r7]
 603:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint32_t i = 0U;
 1803              	 .loc 3 603 0
 1804 000a 0023     	 movs r3,#0
 1805 000c FB60     	 str r3,[r7,#12]
 604:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 605:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /* Fill Remote Wake-up frame filter register with buffer data */
 606:../Libraries/XMCLib/src/xmc_eth_mac.c ****   for (i = 0U; i < XMC_ETH_WAKEUP_REGISTER_LENGTH; i++)
 1806              	 .loc 3 606 0
 1807 000e 0023     	 movs r3,#0
 1808 0010 FB60     	 str r3,[r7,#12]
 1809 0012 09E0     	 b .L80
 1810              	.L81:
 607:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 608:../Libraries/XMCLib/src/xmc_eth_mac.c ****     /* Write each time to the same register */
 609:../Libraries/XMCLib/src/xmc_eth_mac.c ****     eth_mac->regs->REMOTE_WAKE_UP_FRAME_FILTER = (*filter)[i];
 1811              	 .loc 3 609 0 discriminator 3
 1812 0014 7B68     	 ldr r3,[r7,#4]
 1813 0016 1B68     	 ldr r3,[r3]
 1814 0018 3A68     	 ldr r2,[r7]
 1815 001a F968     	 ldr r1,[r7,#12]
 1816 001c 52F82120 	 ldr r2,[r2,r1,lsl#2]
 1817 0020 9A62     	 str r2,[r3,#40]
 606:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 1818              	 .loc 3 606 0 discriminator 3
 1819 0022 FB68     	 ldr r3,[r7,#12]
 1820 0024 0133     	 adds r3,r3,#1
 1821 0026 FB60     	 str r3,[r7,#12]
 1822              	.L80:
 606:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 1823              	 .loc 3 606 0 is_stmt 0 discriminator 1
 1824 0028 FB68     	 ldr r3,[r7,#12]
 1825 002a 072B     	 cmp r3,#7
 1826 002c F2D9     	 bls .L81
 610:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 611:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 1827              	 .loc 3 611 0 is_stmt 1
 1828 002e 1437     	 adds r7,r7,#20
 1829              	.LCFI115:
 1830              	 .cfi_def_cfa_offset 4
 1831 0030 BD46     	 mov sp,r7
 1832              	.LCFI116:
 1833              	 .cfi_def_cfa_register 13
 1834              	 
 1835 0032 5DF8047B 	 ldr r7,[sp],#4
 1836              	.LCFI117:
 1837              	 .cfi_restore 7
 1838              	 .cfi_def_cfa_offset 0
 1839 0036 7047     	 bx lr
 1840              	 .cfi_endproc
 1841              	.LFE219:
 1843              	 .section .text.XMC_ETH_MAC_EnableEvent,"ax",%progbits
 1844              	 .align 2
 1845              	 .global XMC_ETH_MAC_EnableEvent
 1846              	 .thumb
 1847              	 .thumb_func
 1849              	XMC_ETH_MAC_EnableEvent:
 1850              	.LFB220:
 612:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 613:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Enable event */
 614:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_EnableEvent(XMC_ETH_MAC_t *const eth_mac, uint32_t event)
 615:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 1851              	 .loc 3 615 0
 1852              	 .cfi_startproc
 1853              	 
 1854              	 
 1855 0000 80B5     	 push {r7,lr}
 1856              	.LCFI118:
 1857              	 .cfi_def_cfa_offset 8
 1858              	 .cfi_offset 7,-8
 1859              	 .cfi_offset 14,-4
 1860 0002 82B0     	 sub sp,sp,#8
 1861              	.LCFI119:
 1862              	 .cfi_def_cfa_offset 16
 1863 0004 00AF     	 add r7,sp,#0
 1864              	.LCFI120:
 1865              	 .cfi_def_cfa_register 7
 1866 0006 7860     	 str r0,[r7,#4]
 1867 0008 3960     	 str r1,[r7]
 616:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_EnableDMAEvent: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->r
 617:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 618:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->INTERRUPT_MASK &= ~(event >> 16U);
 1868              	 .loc 3 618 0
 1869 000a 7B68     	 ldr r3,[r7,#4]
 1870 000c 1B68     	 ldr r3,[r3]
 1871 000e 7A68     	 ldr r2,[r7,#4]
 1872 0010 1268     	 ldr r2,[r2]
 1873 0012 D16B     	 ldr r1,[r2,#60]
 1874 0014 3A68     	 ldr r2,[r7]
 1875 0016 120C     	 lsrs r2,r2,#16
 1876 0018 D243     	 mvns r2,r2
 1877 001a 0A40     	 ands r2,r2,r1
 1878 001c DA63     	 str r2,[r3,#60]
 619:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 620:../Libraries/XMCLib/src/xmc_eth_mac.c ****   event &= (uint16_t)0x7fffU;
 1879              	 .loc 3 620 0
 1880 001e 3B68     	 ldr r3,[r7]
 1881 0020 C3F30E03 	 ubfx r3,r3,#0,#15
 1882 0024 3B60     	 str r3,[r7]
 621:../Libraries/XMCLib/src/xmc_eth_mac.c ****   if (XCM_ETH_MAC_IsNormalEvent(event))
 1883              	 .loc 3 621 0
 1884 0026 3868     	 ldr r0,[r7]
 1885 0028 FFF7FEFF 	 bl XCM_ETH_MAC_IsNormalEvent
 1886 002c 0346     	 mov r3,r0
 1887 002e 002B     	 cmp r3,#0
 1888 0030 03D0     	 beq .L83
 622:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 623:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	event |= (uint32_t)ETH_INTERRUPT_ENABLE_NIE_Msk;
 1889              	 .loc 3 623 0
 1890 0032 3B68     	 ldr r3,[r7]
 1891 0034 43F48033 	 orr r3,r3,#65536
 1892 0038 3B60     	 str r3,[r7]
 1893              	.L83:
 624:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 625:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 626:../Libraries/XMCLib/src/xmc_eth_mac.c ****   if (XCM_ETH_MAC_IsAbnormalEvent(event))
 1894              	 .loc 3 626 0
 1895 003a 3868     	 ldr r0,[r7]
 1896 003c FFF7FEFF 	 bl XCM_ETH_MAC_IsAbnormalEvent
 1897 0040 0346     	 mov r3,r0
 1898 0042 002B     	 cmp r3,#0
 1899 0044 03D0     	 beq .L84
 627:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 628:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	event |= (uint32_t)ETH_INTERRUPT_ENABLE_AIE_Msk;
 1900              	 .loc 3 628 0
 1901 0046 3B68     	 ldr r3,[r7]
 1902 0048 43F40043 	 orr r3,r3,#32768
 1903 004c 3B60     	 str r3,[r7]
 1904              	.L84:
 629:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 630:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 631:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->INTERRUPT_ENABLE |= event;
 1905              	 .loc 3 631 0
 1906 004e 7B68     	 ldr r3,[r7,#4]
 1907 0050 1968     	 ldr r1,[r3]
 1908 0052 7B68     	 ldr r3,[r7,#4]
 1909 0054 1B68     	 ldr r3,[r3]
 1910 0056 03F58053 	 add r3,r3,#4096
 1911 005a 1C33     	 adds r3,r3,#28
 1912 005c 1A68     	 ldr r2,[r3]
 1913 005e 3B68     	 ldr r3,[r7]
 1914 0060 1A43     	 orrs r2,r2,r3
 1915 0062 01F58053 	 add r3,r1,#4096
 1916 0066 1C33     	 adds r3,r3,#28
 1917 0068 1A60     	 str r2,[r3]
 632:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 1918              	 .loc 3 632 0
 1919 006a 0837     	 adds r7,r7,#8
 1920              	.LCFI121:
 1921              	 .cfi_def_cfa_offset 8
 1922 006c BD46     	 mov sp,r7
 1923              	.LCFI122:
 1924              	 .cfi_def_cfa_register 13
 1925              	 
 1926 006e 80BD     	 pop {r7,pc}
 1927              	 .cfi_endproc
 1928              	.LFE220:
 1930              	 .section .text.XMC_ETH_MAC_DisableEvent,"ax",%progbits
 1931              	 .align 2
 1932              	 .global XMC_ETH_MAC_DisableEvent
 1933              	 .thumb
 1934              	 .thumb_func
 1936              	XMC_ETH_MAC_DisableEvent:
 1937              	.LFB221:
 633:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 634:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Disable event */
 635:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_DisableEvent(XMC_ETH_MAC_t *const eth_mac, uint32_t event)
 636:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 1938              	 .loc 3 636 0
 1939              	 .cfi_startproc
 1940              	 
 1941              	 
 1942              	 
 1943 0000 80B4     	 push {r7}
 1944              	.LCFI123:
 1945              	 .cfi_def_cfa_offset 4
 1946              	 .cfi_offset 7,-4
 1947 0002 83B0     	 sub sp,sp,#12
 1948              	.LCFI124:
 1949              	 .cfi_def_cfa_offset 16
 1950 0004 00AF     	 add r7,sp,#0
 1951              	.LCFI125:
 1952              	 .cfi_def_cfa_register 7
 1953 0006 7860     	 str r0,[r7,#4]
 1954 0008 3960     	 str r1,[r7]
 637:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_DisableDMAEvent: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->
 638:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 639:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->INTERRUPT_MASK |= event >> 16U;
 1955              	 .loc 3 639 0
 1956 000a 7B68     	 ldr r3,[r7,#4]
 1957 000c 1B68     	 ldr r3,[r3]
 1958 000e 7A68     	 ldr r2,[r7,#4]
 1959 0010 1268     	 ldr r2,[r2]
 1960 0012 D16B     	 ldr r1,[r2,#60]
 1961 0014 3A68     	 ldr r2,[r7]
 1962 0016 120C     	 lsrs r2,r2,#16
 1963 0018 0A43     	 orrs r2,r2,r1
 1964 001a DA63     	 str r2,[r3,#60]
 640:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 641:../Libraries/XMCLib/src/xmc_eth_mac.c ****   event &= (uint16_t)~0xffffU;
 1965              	 .loc 3 641 0
 1966 001c 0023     	 movs r3,#0
 1967 001e 3B60     	 str r3,[r7]
 642:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->INTERRUPT_ENABLE &= ~event;
 1968              	 .loc 3 642 0
 1969 0020 7B68     	 ldr r3,[r7,#4]
 1970 0022 1968     	 ldr r1,[r3]
 1971 0024 7B68     	 ldr r3,[r7,#4]
 1972 0026 1B68     	 ldr r3,[r3]
 1973 0028 03F58053 	 add r3,r3,#4096
 1974 002c 1C33     	 adds r3,r3,#28
 1975 002e 1A68     	 ldr r2,[r3]
 1976 0030 3B68     	 ldr r3,[r7]
 1977 0032 DB43     	 mvns r3,r3
 1978 0034 1A40     	 ands r2,r2,r3
 1979 0036 01F58053 	 add r3,r1,#4096
 1980 003a 1C33     	 adds r3,r3,#28
 1981 003c 1A60     	 str r2,[r3]
 643:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 1982              	 .loc 3 643 0
 1983 003e 0C37     	 adds r7,r7,#12
 1984              	.LCFI126:
 1985              	 .cfi_def_cfa_offset 4
 1986 0040 BD46     	 mov sp,r7
 1987              	.LCFI127:
 1988              	 .cfi_def_cfa_register 13
 1989              	 
 1990 0042 5DF8047B 	 ldr r7,[sp],#4
 1991              	.LCFI128:
 1992              	 .cfi_restore 7
 1993              	 .cfi_def_cfa_offset 0
 1994 0046 7047     	 bx lr
 1995              	 .cfi_endproc
 1996              	.LFE221:
 1998              	 .section .text.XMC_ETH_MAC_ClearEventStatus,"ax",%progbits
 1999              	 .align 2
 2000              	 .global XMC_ETH_MAC_ClearEventStatus
 2001              	 .thumb
 2002              	 .thumb_func
 2004              	XMC_ETH_MAC_ClearEventStatus:
 2005              	.LFB222:
 644:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 645:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Clear event status */
 646:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_ClearEventStatus(XMC_ETH_MAC_t *const eth_mac, uint32_t event)
 647:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 2006              	 .loc 3 647 0
 2007              	 .cfi_startproc
 2008              	 
 2009              	 
 2010              	 
 2011 0000 80B4     	 push {r7}
 2012              	.LCFI129:
 2013              	 .cfi_def_cfa_offset 4
 2014              	 .cfi_offset 7,-4
 2015 0002 83B0     	 sub sp,sp,#12
 2016              	.LCFI130:
 2017              	 .cfi_def_cfa_offset 16
 2018 0004 00AF     	 add r7,sp,#0
 2019              	.LCFI131:
 2020              	 .cfi_def_cfa_register 7
 2021 0006 7860     	 str r0,[r7,#4]
 2022 0008 3960     	 str r1,[r7]
 648:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_ClearDMAEventStatus: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_m
 649:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 650:../Libraries/XMCLib/src/xmc_eth_mac.c ****   if ((eth_mac->regs->STATUS & ETH_STATUS_NIS_Msk) != 0U)
 2023              	 .loc 3 650 0
 2024 000a 7B68     	 ldr r3,[r7,#4]
 2025 000c 1B68     	 ldr r3,[r3]
 2026 000e 03F58053 	 add r3,r3,#4096
 2027 0012 1433     	 adds r3,r3,#20
 2028 0014 1B68     	 ldr r3,[r3]
 2029 0016 03F48033 	 and r3,r3,#65536
 2030 001a 002B     	 cmp r3,#0
 2031 001c 03D0     	 beq .L87
 651:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 652:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	event |= (uint32_t)ETH_STATUS_NIS_Msk;
 2032              	 .loc 3 652 0
 2033 001e 3B68     	 ldr r3,[r7]
 2034 0020 43F48033 	 orr r3,r3,#65536
 2035 0024 3B60     	 str r3,[r7]
 2036              	.L87:
 653:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 654:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 655:../Libraries/XMCLib/src/xmc_eth_mac.c ****   if ((eth_mac->regs->STATUS & ETH_STATUS_AIS_Msk) != 0U)
 2037              	 .loc 3 655 0
 2038 0026 7B68     	 ldr r3,[r7,#4]
 2039 0028 1B68     	 ldr r3,[r3]
 2040 002a 03F58053 	 add r3,r3,#4096
 2041 002e 1433     	 adds r3,r3,#20
 2042 0030 1B68     	 ldr r3,[r3]
 2043 0032 03F40043 	 and r3,r3,#32768
 2044 0036 002B     	 cmp r3,#0
 2045 0038 03D0     	 beq .L88
 656:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 657:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	event |= (uint32_t)ETH_STATUS_AIS_Msk;
 2046              	 .loc 3 657 0
 2047 003a 3B68     	 ldr r3,[r7]
 2048 003c 43F40043 	 orr r3,r3,#32768
 2049 0040 3B60     	 str r3,[r7]
 2050              	.L88:
 658:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 659:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 660:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->STATUS = event;
 2051              	 .loc 3 660 0
 2052 0042 7B68     	 ldr r3,[r7,#4]
 2053 0044 1B68     	 ldr r3,[r3]
 2054 0046 03F58053 	 add r3,r3,#4096
 2055 004a 1433     	 adds r3,r3,#20
 2056 004c 3A68     	 ldr r2,[r7]
 2057 004e 1A60     	 str r2,[r3]
 661:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 2058              	 .loc 3 661 0
 2059 0050 0C37     	 adds r7,r7,#12
 2060              	.LCFI132:
 2061              	 .cfi_def_cfa_offset 4
 2062 0052 BD46     	 mov sp,r7
 2063              	.LCFI133:
 2064              	 .cfi_def_cfa_register 13
 2065              	 
 2066 0054 5DF8047B 	 ldr r7,[sp],#4
 2067              	.LCFI134:
 2068              	 .cfi_restore 7
 2069              	 .cfi_def_cfa_offset 0
 2070 0058 7047     	 bx lr
 2071              	 .cfi_endproc
 2072              	.LFE222:
 2074 005a 00BF     	 .section .text.XMC_ETH_MAC_GetEventStatus,"ax",%progbits
 2075              	 .align 2
 2076              	 .global XMC_ETH_MAC_GetEventStatus
 2077              	 .thumb
 2078              	 .thumb_func
 2080              	XMC_ETH_MAC_GetEventStatus:
 2081              	.LFB223:
 662:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 663:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Obtain event status */
 664:../Libraries/XMCLib/src/xmc_eth_mac.c **** uint32_t XMC_ETH_MAC_GetEventStatus(const XMC_ETH_MAC_t *const eth_mac)
 665:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 2082              	 .loc 3 665 0
 2083              	 .cfi_startproc
 2084              	 
 2085              	 
 2086              	 
 2087 0000 80B4     	 push {r7}
 2088              	.LCFI135:
 2089              	 .cfi_def_cfa_offset 4
 2090              	 .cfi_offset 7,-4
 2091 0002 85B0     	 sub sp,sp,#20
 2092              	.LCFI136:
 2093              	 .cfi_def_cfa_offset 24
 2094 0004 00AF     	 add r7,sp,#0
 2095              	.LCFI137:
 2096              	 .cfi_def_cfa_register 7
 2097 0006 7860     	 str r0,[r7,#4]
 666:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint32_t temp_status = 0;
 2098              	 .loc 3 666 0
 2099 0008 0023     	 movs r3,#0
 2100 000a FB60     	 str r3,[r7,#12]
 667:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_GetDMAEventStatus: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac
 668:../Libraries/XMCLib/src/xmc_eth_mac.c ****   
 669:../Libraries/XMCLib/src/xmc_eth_mac.c ****   temp_status =  (eth_mac->regs->STATUS & (uint32_t)0x7ffUL);
 2101              	 .loc 3 669 0
 2102 000c 7B68     	 ldr r3,[r7,#4]
 2103 000e 1B68     	 ldr r3,[r3]
 2104 0010 03F58053 	 add r3,r3,#4096
 2105 0014 1433     	 adds r3,r3,#20
 2106 0016 1B68     	 ldr r3,[r3]
 2107 0018 C3F30A03 	 ubfx r3,r3,#0,#11
 2108 001c FB60     	 str r3,[r7,#12]
 670:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 671:../Libraries/XMCLib/src/xmc_eth_mac.c ****   return ((uint32_t)((eth_mac->regs->INTERRUPT_STATUS & (ETH_INTERRUPT_MASK_PMTIM_Msk | ETH_INTERRU
 2109              	 .loc 3 671 0
 2110 001e 7B68     	 ldr r3,[r7,#4]
 2111 0020 1B68     	 ldr r3,[r3]
 2112 0022 9B6B     	 ldr r3,[r3,#56]
 2113 0024 03F40273 	 and r3,r3,#520
 2114 0028 1A04     	 lsls r2,r3,#16
 2115 002a FB68     	 ldr r3,[r7,#12]
 2116 002c 1343     	 orrs r3,r3,r2
 672:../Libraries/XMCLib/src/xmc_eth_mac.c **** 		  temp_status);
 673:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 2117              	 .loc 3 673 0
 2118 002e 1846     	 mov r0,r3
 2119 0030 1437     	 adds r7,r7,#20
 2120              	.LCFI138:
 2121              	 .cfi_def_cfa_offset 4
 2122 0032 BD46     	 mov sp,r7
 2123              	.LCFI139:
 2124              	 .cfi_def_cfa_register 13
 2125              	 
 2126 0034 5DF8047B 	 ldr r7,[sp],#4
 2127              	.LCFI140:
 2128              	 .cfi_restore 7
 2129              	 .cfi_def_cfa_offset 0
 2130 0038 7047     	 bx lr
 2131              	 .cfi_endproc
 2132              	.LFE223:
 2134 003a 00BF     	 .section .text.XMC_ETH_MAC_ReturnRxDescriptor,"ax",%progbits
 2135              	 .align 2
 2136              	 .global XMC_ETH_MAC_ReturnRxDescriptor
 2137              	 .thumb
 2138              	 .thumb_func
 2140              	XMC_ETH_MAC_ReturnRxDescriptor:
 2141              	.LFB224:
 674:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 675:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Return RX descriptor */
 676:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_ReturnRxDescriptor(XMC_ETH_MAC_t *const eth_mac)
 677:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 2142              	 .loc 3 677 0
 2143              	 .cfi_startproc
 2144              	 
 2145              	 
 2146              	 
 2147 0000 80B4     	 push {r7}
 2148              	.LCFI141:
 2149              	 .cfi_def_cfa_offset 4
 2150              	 .cfi_offset 7,-4
 2151 0002 83B0     	 sub sp,sp,#12
 2152              	.LCFI142:
 2153              	 .cfi_def_cfa_offset 16
 2154 0004 00AF     	 add r7,sp,#0
 2155              	.LCFI143:
 2156              	 .cfi_def_cfa_register 7
 2157 0006 7860     	 str r0,[r7,#4]
 678:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->rx_desc[eth_mac->rx_index].status |= ETH_MAC_DMA_RDES0_OWN;
 2158              	 .loc 3 678 0
 2159 0008 7B68     	 ldr r3,[r7,#4]
 2160 000a 1A69     	 ldr r2,[r3,#16]
 2161 000c 7B68     	 ldr r3,[r7,#4]
 2162 000e 93F82730 	 ldrb r3,[r3,#39]
 2163 0012 5B01     	 lsls r3,r3,#5
 2164 0014 1344     	 add r3,r3,r2
 2165 0016 7A68     	 ldr r2,[r7,#4]
 2166 0018 1169     	 ldr r1,[r2,#16]
 2167 001a 7A68     	 ldr r2,[r7,#4]
 2168 001c 92F82720 	 ldrb r2,[r2,#39]
 2169 0020 5201     	 lsls r2,r2,#5
 2170 0022 0A44     	 add r2,r2,r1
 2171 0024 1268     	 ldr r2,[r2]
 2172 0026 42F00042 	 orr r2,r2,#-2147483648
 2173 002a 1A60     	 str r2,[r3]
 679:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 2174              	 .loc 3 679 0
 2175 002c 0C37     	 adds r7,r7,#12
 2176              	.LCFI144:
 2177              	 .cfi_def_cfa_offset 4
 2178 002e BD46     	 mov sp,r7
 2179              	.LCFI145:
 2180              	 .cfi_def_cfa_register 13
 2181              	 
 2182 0030 5DF8047B 	 ldr r7,[sp],#4
 2183              	.LCFI146:
 2184              	 .cfi_restore 7
 2185              	 .cfi_def_cfa_offset 0
 2186 0034 7047     	 bx lr
 2187              	 .cfi_endproc
 2188              	.LFE224:
 2190 0036 00BF     	 .section .text.XMC_ETH_MAC_ReturnTxDescriptor,"ax",%progbits
 2191              	 .align 2
 2192              	 .global XMC_ETH_MAC_ReturnTxDescriptor
 2193              	 .thumb
 2194              	 .thumb_func
 2196              	XMC_ETH_MAC_ReturnTxDescriptor:
 2197              	.LFB225:
 680:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 681:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Return TX descriptor */
 682:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_ReturnTxDescriptor(XMC_ETH_MAC_t *const eth_mac)
 683:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 2198              	 .loc 3 683 0
 2199              	 .cfi_startproc
 2200              	 
 2201              	 
 2202              	 
 2203 0000 80B4     	 push {r7}
 2204              	.LCFI147:
 2205              	 .cfi_def_cfa_offset 4
 2206              	 .cfi_offset 7,-4
 2207 0002 83B0     	 sub sp,sp,#12
 2208              	.LCFI148:
 2209              	 .cfi_def_cfa_offset 16
 2210 0004 00AF     	 add r7,sp,#0
 2211              	.LCFI149:
 2212              	 .cfi_def_cfa_register 7
 2213 0006 7860     	 str r0,[r7,#4]
 684:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->tx_desc[eth_mac->tx_index].status |= ETH_MAC_DMA_TDES0_OWN;
 2214              	 .loc 3 684 0
 2215 0008 7B68     	 ldr r3,[r7,#4]
 2216 000a 5A69     	 ldr r2,[r3,#20]
 2217 000c 7B68     	 ldr r3,[r7,#4]
 2218 000e 93F82630 	 ldrb r3,[r3,#38]
 2219 0012 5B01     	 lsls r3,r3,#5
 2220 0014 1344     	 add r3,r3,r2
 2221 0016 7A68     	 ldr r2,[r7,#4]
 2222 0018 5169     	 ldr r1,[r2,#20]
 2223 001a 7A68     	 ldr r2,[r7,#4]
 2224 001c 92F82620 	 ldrb r2,[r2,#38]
 2225 0020 5201     	 lsls r2,r2,#5
 2226 0022 0A44     	 add r2,r2,r1
 2227 0024 1268     	 ldr r2,[r2]
 2228 0026 42F00042 	 orr r2,r2,#-2147483648
 2229 002a 1A60     	 str r2,[r3]
 685:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 2230              	 .loc 3 685 0
 2231 002c 0C37     	 adds r7,r7,#12
 2232              	.LCFI150:
 2233              	 .cfi_def_cfa_offset 4
 2234 002e BD46     	 mov sp,r7
 2235              	.LCFI151:
 2236              	 .cfi_def_cfa_register 13
 2237              	 
 2238 0030 5DF8047B 	 ldr r7,[sp],#4
 2239              	.LCFI152:
 2240              	 .cfi_restore 7
 2241              	 .cfi_def_cfa_offset 0
 2242 0034 7047     	 bx lr
 2243              	 .cfi_endproc
 2244              	.LFE225:
 2246 0036 00BF     	 .section .text.XMC_ETH_MAC_IsTxDescriptorOwnedByDma,"ax",%progbits
 2247              	 .align 2
 2248              	 .global XMC_ETH_MAC_IsTxDescriptorOwnedByDma
 2249              	 .thumb
 2250              	 .thumb_func
 2252              	XMC_ETH_MAC_IsTxDescriptorOwnedByDma:
 2253              	.LFB226:
 686:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 687:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Is TX descriptor owned by DMA? */
 688:../Libraries/XMCLib/src/xmc_eth_mac.c **** bool XMC_ETH_MAC_IsTxDescriptorOwnedByDma(XMC_ETH_MAC_t *const eth_mac)
 689:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 2254              	 .loc 3 689 0
 2255              	 .cfi_startproc
 2256              	 
 2257              	 
 2258              	 
 2259 0000 80B4     	 push {r7}
 2260              	.LCFI153:
 2261              	 .cfi_def_cfa_offset 4
 2262              	 .cfi_offset 7,-4
 2263 0002 83B0     	 sub sp,sp,#12
 2264              	.LCFI154:
 2265              	 .cfi_def_cfa_offset 16
 2266 0004 00AF     	 add r7,sp,#0
 2267              	.LCFI155:
 2268              	 .cfi_def_cfa_register 7
 2269 0006 7860     	 str r0,[r7,#4]
 690:../Libraries/XMCLib/src/xmc_eth_mac.c ****   return ((eth_mac->tx_desc[eth_mac->tx_index].status & ETH_MAC_DMA_TDES0_OWN) != 0U);
 2270              	 .loc 3 690 0
 2271 0008 7B68     	 ldr r3,[r7,#4]
 2272 000a 5A69     	 ldr r2,[r3,#20]
 2273 000c 7B68     	 ldr r3,[r7,#4]
 2274 000e 93F82630 	 ldrb r3,[r3,#38]
 2275 0012 5B01     	 lsls r3,r3,#5
 2276 0014 1344     	 add r3,r3,r2
 2277 0016 1B68     	 ldr r3,[r3]
 2278 0018 DB0F     	 lsrs r3,r3,#31
 2279 001a DBB2     	 uxtb r3,r3
 691:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 2280              	 .loc 3 691 0
 2281 001c 1846     	 mov r0,r3
 2282 001e 0C37     	 adds r7,r7,#12
 2283              	.LCFI156:
 2284              	 .cfi_def_cfa_offset 4
 2285 0020 BD46     	 mov sp,r7
 2286              	.LCFI157:
 2287              	 .cfi_def_cfa_register 13
 2288              	 
 2289 0022 5DF8047B 	 ldr r7,[sp],#4
 2290              	.LCFI158:
 2291              	 .cfi_restore 7
 2292              	 .cfi_def_cfa_offset 0
 2293 0026 7047     	 bx lr
 2294              	 .cfi_endproc
 2295              	.LFE226:
 2297              	 .section .text.XMC_ETH_MAC_SetVLANTag,"ax",%progbits
 2298              	 .align 2
 2299              	 .global XMC_ETH_MAC_SetVLANTag
 2300              	 .thumb
 2301              	 .thumb_func
 2303              	XMC_ETH_MAC_SetVLANTag:
 2304              	.LFB227:
 692:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 693:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Set VLAN tag */
 694:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_SetVLANTag(XMC_ETH_MAC_t *const eth_mac, uint16_t tag)
 695:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 2305              	 .loc 3 695 0
 2306              	 .cfi_startproc
 2307              	 
 2308              	 
 2309              	 
 2310 0000 80B4     	 push {r7}
 2311              	.LCFI159:
 2312              	 .cfi_def_cfa_offset 4
 2313              	 .cfi_offset 7,-4
 2314 0002 83B0     	 sub sp,sp,#12
 2315              	.LCFI160:
 2316              	 .cfi_def_cfa_offset 16
 2317 0004 00AF     	 add r7,sp,#0
 2318              	.LCFI161:
 2319              	 .cfi_def_cfa_register 7
 2320 0006 7860     	 str r0,[r7,#4]
 2321 0008 0B46     	 mov r3,r1
 2322 000a 7B80     	 strh r3,[r7,#2]
 696:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_SetVLANTag: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->regs)
 697:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 698:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->VLAN_TAG = (uint32_t)tag;
 2323              	 .loc 3 698 0
 2324 000c 7B68     	 ldr r3,[r7,#4]
 2325 000e 1B68     	 ldr r3,[r3]
 2326 0010 7A88     	 ldrh r2,[r7,#2]
 2327 0012 DA61     	 str r2,[r3,#28]
 699:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 2328              	 .loc 3 699 0
 2329 0014 0C37     	 adds r7,r7,#12
 2330              	.LCFI162:
 2331              	 .cfi_def_cfa_offset 4
 2332 0016 BD46     	 mov sp,r7
 2333              	.LCFI163:
 2334              	 .cfi_def_cfa_register 13
 2335              	 
 2336 0018 5DF8047B 	 ldr r7,[sp],#4
 2337              	.LCFI164:
 2338              	 .cfi_restore 7
 2339              	 .cfi_def_cfa_offset 0
 2340 001c 7047     	 bx lr
 2341              	 .cfi_endproc
 2342              	.LFE227:
 2344 001e 00BF     	 .section .text.XMC_ETH_MAC_InitPTP,"ax",%progbits
 2345              	 .align 2
 2346              	 .global XMC_ETH_MAC_InitPTP
 2347              	 .thumb
 2348              	 .thumb_func
 2350              	XMC_ETH_MAC_InitPTP:
 2351              	.LFB228:
 700:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 701:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Initialize PTP */
 702:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_InitPTP(XMC_ETH_MAC_t *const eth_mac, uint32_t config)
 703:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 2352              	 .loc 3 703 0
 2353              	 .cfi_startproc
 2354              	 
 2355              	 
 2356 0000 90B5     	 push {r4,r7,lr}
 2357              	.LCFI165:
 2358              	 .cfi_def_cfa_offset 12
 2359              	 .cfi_offset 4,-12
 2360              	 .cfi_offset 7,-8
 2361              	 .cfi_offset 14,-4
 2362 0002 83B0     	 sub sp,sp,#12
 2363              	.LCFI166:
 2364              	 .cfi_def_cfa_offset 24
 2365 0004 00AF     	 add r7,sp,#0
 2366              	.LCFI167:
 2367              	 .cfi_def_cfa_register 7
 2368 0006 7860     	 str r0,[r7,#4]
 2369 0008 3960     	 str r1,[r7]
 704:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_InitPTP: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->regs));
 705:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 706:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /* Mask the time stamp interrupt */
 707:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->INTERRUPT_MASK |= (uint32_t)ETH_INTERRUPT_MASK_TSIM_Msk;
 2370              	 .loc 3 707 0
 2371 000a 7B68     	 ldr r3,[r7,#4]
 2372 000c 1B68     	 ldr r3,[r3]
 2373 000e 7A68     	 ldr r2,[r7,#4]
 2374 0010 1268     	 ldr r2,[r2]
 2375 0012 D26B     	 ldr r2,[r2,#60]
 2376 0014 42F40072 	 orr r2,r2,#512
 2377 0018 DA63     	 str r2,[r3,#60]
 708:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 709:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /* Enable time stamp */
 710:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->TIMESTAMP_CONTROL = config | (uint32_t)ETH_TIMESTAMP_CONTROL_TSENA_Msk;
 2378              	 .loc 3 710 0
 2379 001a 7B68     	 ldr r3,[r7,#4]
 2380 001c 1B68     	 ldr r3,[r3]
 2381 001e 3A68     	 ldr r2,[r7]
 2382 0020 42F00102 	 orr r2,r2,#1
 2383 0024 C3F80027 	 str r2,[r3,#1792]
 711:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 712:../Libraries/XMCLib/src/xmc_eth_mac.c ****   if ((config & (uint32_t)XMC_ETH_MAC_TIMESTAMP_CONFIG_FINE_UPDATE) != 0U)
 2384              	 .loc 3 712 0
 2385 0028 3B68     	 ldr r3,[r7]
 2386 002a 03F00203 	 and r3,r3,#2
 2387 002e 002B     	 cmp r3,#0
 2388 0030 26D0     	 beq .L97
 713:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 714:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	/* Program addend register to obtain fSYS/2 from reference clock (fSYS) */
 715:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	eth_mac->regs->TIMESTAMP_ADDEND = (uint32_t)0x80000000U;
 2389              	 .loc 3 715 0
 2390 0032 7B68     	 ldr r3,[r7,#4]
 2391 0034 1B68     	 ldr r3,[r3]
 2392 0036 4FF00042 	 mov r2,#-2147483648
 2393 003a C3F81827 	 str r2,[r3,#1816]
 716:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	eth_mac->regs->TIMESTAMP_CONTROL |= (uint32_t)ETH_TIMESTAMP_CONTROL_TSADDREG_Msk;
 2394              	 .loc 3 716 0
 2395 003e 7B68     	 ldr r3,[r7,#4]
 2396 0040 1B68     	 ldr r3,[r3]
 2397 0042 7A68     	 ldr r2,[r7,#4]
 2398 0044 1268     	 ldr r2,[r2]
 2399 0046 D2F80027 	 ldr r2,[r2,#1792]
 2400 004a 42F02002 	 orr r2,r2,#32
 2401 004e C3F80027 	 str r2,[r3,#1792]
 717:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 718:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	/* Program sub-second increment register based on PTP clock frequency = fSYS/2 */
 719:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	/* the nanoseconds register has a resolution of ~0.465ns. */
 720:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	eth_mac->regs->SUB_SECOND_INCREMENT = (uint32_t)((1.0F / (0x80000000U)) * (2.0F / XMC_SCU_CLOCK_Ge
 2402              	 .loc 3 720 0
 2403 0052 7B68     	 ldr r3,[r7,#4]
 2404 0054 1C68     	 ldr r4,[r3]
 2405 0056 FFF7FEFF 	 bl XMC_SCU_CLOCK_GetSystemClockFrequency
 2406 005a 07EE900A 	 fmsr s15,r0
 2407 005e F8EE677A 	 fuitos s15,s15
 2408 0062 B0EE007A 	 fconsts s14,#0
 2409 0066 C7EE277A 	 fdivs s15,s14,s15
 2410 006a 9FED177A 	 flds s14,.L99
 2411 006e 67EE877A 	 fmuls s15,s15,s14
 2412 0072 FCEEE77A 	 ftouizs s15,s15
 2413 0076 17EE903A 	 fmrs r3,s15
 2414 007a C4F80437 	 str r3,[r4,#1796]
 2415 007e 15E0     	 b .L98
 2416              	.L97:
 721:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 722:../Libraries/XMCLib/src/xmc_eth_mac.c ****   else
 723:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 724:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	/* Program sub-second increment register based on PTP clock frequency = fSYS */
 725:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	/* the nanoseconds register has a resolution of ~0.465ns. */
 726:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	eth_mac->regs->SUB_SECOND_INCREMENT = (uint32_t)((1.0F / (0x80000000U)) * (1.0F / XMC_SCU_CLOCK_Ge
 2417              	 .loc 3 726 0
 2418 0080 7B68     	 ldr r3,[r7,#4]
 2419 0082 1C68     	 ldr r4,[r3]
 2420 0084 FFF7FEFF 	 bl XMC_SCU_CLOCK_GetSystemClockFrequency
 2421 0088 07EE900A 	 fmsr s15,r0
 2422 008c F8EE677A 	 fuitos s15,s15
 2423 0090 B7EE007A 	 fconsts s14,#112
 2424 0094 C7EE277A 	 fdivs s15,s14,s15
 2425 0098 9FED0B7A 	 flds s14,.L99
 2426 009c 67EE877A 	 fmuls s15,s15,s14
 2427 00a0 FCEEE77A 	 ftouizs s15,s15
 2428 00a4 17EE903A 	 fmrs r3,s15
 2429 00a8 C4F80437 	 str r3,[r4,#1796]
 2430              	.L98:
 727:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 728:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 729:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->TIMESTAMP_CONTROL |= (uint32_t)ETH_TIMESTAMP_CONTROL_TSINIT_Msk;
 2431              	 .loc 3 729 0
 2432 00ac 7B68     	 ldr r3,[r7,#4]
 2433 00ae 1B68     	 ldr r3,[r3]
 2434 00b0 7A68     	 ldr r2,[r7,#4]
 2435 00b2 1268     	 ldr r2,[r2]
 2436 00b4 D2F80027 	 ldr r2,[r2,#1792]
 2437 00b8 42F00402 	 orr r2,r2,#4
 2438 00bc C3F80027 	 str r2,[r3,#1792]
 730:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 2439              	 .loc 3 730 0
 2440 00c0 0C37     	 adds r7,r7,#12
 2441              	.LCFI168:
 2442              	 .cfi_def_cfa_offset 12
 2443 00c2 BD46     	 mov sp,r7
 2444              	.LCFI169:
 2445              	 .cfi_def_cfa_register 13
 2446              	 
 2447 00c4 90BD     	 pop {r4,r7,pc}
 2448              	.L100:
 2449 00c6 00BF     	 .align 2
 2450              	.L99:
 2451 00c8 00000030 	 .word 805306368
 2452              	 .cfi_endproc
 2453              	.LFE228:
 2455              	 .section .text.XMC_ETH_MAC_GetPTPTime,"ax",%progbits
 2456              	 .align 2
 2457              	 .global XMC_ETH_MAC_GetPTPTime
 2458              	 .thumb
 2459              	 .thumb_func
 2461              	XMC_ETH_MAC_GetPTPTime:
 2462              	.LFB229:
 731:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 732:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Get PTP time */
 733:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_GetPTPTime(XMC_ETH_MAC_t *const eth_mac, XMC_ETH_MAC_TIME_t *const time)
 734:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 2463              	 .loc 3 734 0
 2464              	 .cfi_startproc
 2465              	 
 2466              	 
 2467              	 
 2468 0000 80B4     	 push {r7}
 2469              	.LCFI170:
 2470              	 .cfi_def_cfa_offset 4
 2471              	 .cfi_offset 7,-4
 2472 0002 83B0     	 sub sp,sp,#12
 2473              	.LCFI171:
 2474              	 .cfi_def_cfa_offset 16
 2475 0004 00AF     	 add r7,sp,#0
 2476              	.LCFI172:
 2477              	 .cfi_def_cfa_register 7
 2478 0006 7860     	 str r0,[r7,#4]
 2479 0008 3960     	 str r1,[r7]
 735:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_GetPTPTime: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->regs)
 736:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 737:../Libraries/XMCLib/src/xmc_eth_mac.c ****   time->nanoseconds = (uint32_t)(eth_mac->regs->SYSTEM_TIME_NANOSECONDS * (0x80000000U / 1000000000
 2480              	 .loc 3 737 0
 2481 000a 7B68     	 ldr r3,[r7,#4]
 2482 000c 1B68     	 ldr r3,[r3]
 2483 000e D3F80C37 	 ldr r3,[r3,#1804]
 2484 0012 07EE903A 	 fmsr s15,r3
 2485 0016 F8EE677A 	 fuitos s15,s15
 2486 001a 9FED0A7A 	 flds s14,.L102
 2487 001e 67EE877A 	 fmuls s15,s15,s14
 2488 0022 FCEEE77A 	 ftouizs s15,s15
 2489 0026 17EE902A 	 fmrs r2,s15
 2490 002a 3B68     	 ldr r3,[r7]
 2491 002c 1A60     	 str r2,[r3]
 738:../Libraries/XMCLib/src/xmc_eth_mac.c ****   time->seconds = eth_mac->regs->SYSTEM_TIME_SECONDS;
 2492              	 .loc 3 738 0
 2493 002e 7B68     	 ldr r3,[r7,#4]
 2494 0030 1B68     	 ldr r3,[r3]
 2495 0032 D3F80827 	 ldr r2,[r3,#1800]
 2496 0036 3B68     	 ldr r3,[r7]
 2497 0038 5A60     	 str r2,[r3,#4]
 739:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 2498              	 .loc 3 739 0
 2499 003a 0C37     	 adds r7,r7,#12
 2500              	.LCFI173:
 2501              	 .cfi_def_cfa_offset 4
 2502 003c BD46     	 mov sp,r7
 2503              	.LCFI174:
 2504              	 .cfi_def_cfa_register 13
 2505              	 
 2506 003e 5DF8047B 	 ldr r7,[sp],#4
 2507              	.LCFI175:
 2508              	 .cfi_restore 7
 2509              	 .cfi_def_cfa_offset 0
 2510 0042 7047     	 bx lr
 2511              	.L103:
 2512              	 .align 2
 2513              	.L102:
 2514 0044 5F700940 	 .word 1074360415
 2515              	 .cfi_endproc
 2516              	.LFE229:
 2518              	 .section .text.XMC_ETH_MAC_UpdatePTPTime,"ax",%progbits
 2519              	 .align 2
 2520              	 .global XMC_ETH_MAC_UpdatePTPTime
 2521              	 .thumb
 2522              	 .thumb_func
 2524              	XMC_ETH_MAC_UpdatePTPTime:
 2525              	.LFB230:
 740:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 741:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Update PTP time */
 742:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_UpdatePTPTime(XMC_ETH_MAC_t *const eth_mac, const XMC_ETH_MAC_TIME_t *const time)
 743:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 2526              	 .loc 3 743 0
 2527              	 .cfi_startproc
 2528              	 
 2529              	 
 2530              	 
 2531 0000 80B4     	 push {r7}
 2532              	.LCFI176:
 2533              	 .cfi_def_cfa_offset 4
 2534              	 .cfi_offset 7,-4
 2535 0002 85B0     	 sub sp,sp,#20
 2536              	.LCFI177:
 2537              	 .cfi_def_cfa_offset 24
 2538 0004 00AF     	 add r7,sp,#0
 2539              	.LCFI178:
 2540              	 .cfi_def_cfa_register 7
 2541 0006 7860     	 str r0,[r7,#4]
 2542 0008 3960     	 str r1,[r7]
 744:../Libraries/XMCLib/src/xmc_eth_mac.c ****   uint32_t temp;
 745:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 746:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_UpdatePTPTime: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->re
 747:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 748:../Libraries/XMCLib/src/xmc_eth_mac.c ****   temp = (uint32_t)(abs(time->nanoseconds) * (100000000.0F / (0x80000000U)));
 2543              	 .loc 3 748 0
 2544 000a 3B68     	 ldr r3,[r7]
 2545 000c 1B68     	 ldr r3,[r3]
 2546 000e 002B     	 cmp r3,#0
 2547 0010 B8BF     	 it lt
 2548 0012 5B42     	 rsblt r3,r3,#0
 2549 0014 07EE903A 	 fmsr s15,r3
 2550 0018 F8EEE77A 	 fsitos s15,s15
 2551 001c 9FED157A 	 flds s14,.L106
 2552 0020 67EE877A 	 fmuls s15,s15,s14
 2553 0024 FCEEE77A 	 ftouizs s15,s15
 2554 0028 17EE903A 	 fmrs r3,s15
 2555 002c FB60     	 str r3,[r7,#12]
 749:../Libraries/XMCLib/src/xmc_eth_mac.c ****   if (time->nanoseconds >= 0)
 2556              	 .loc 3 749 0
 2557 002e 3B68     	 ldr r3,[r7]
 2558 0030 1B68     	 ldr r3,[r3]
 2559 0032 002B     	 cmp r3,#0
 2560 0034 03DB     	 blt .L105
 750:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 751:../Libraries/XMCLib/src/xmc_eth_mac.c **** 	temp |= (uint32_t)ETH_SYSTEM_TIME_NANOSECONDS_UPDATE_ADDSUB_Msk;
 2561              	 .loc 3 751 0
 2562 0036 FB68     	 ldr r3,[r7,#12]
 2563 0038 43F00043 	 orr r3,r3,#-2147483648
 2564 003c FB60     	 str r3,[r7,#12]
 2565              	.L105:
 752:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 753:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 754:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->SYSTEM_TIME_NANOSECONDS_UPDATE = temp;
 2566              	 .loc 3 754 0
 2567 003e 7B68     	 ldr r3,[r7,#4]
 2568 0040 1B68     	 ldr r3,[r3]
 2569 0042 FA68     	 ldr r2,[r7,#12]
 2570 0044 C3F81427 	 str r2,[r3,#1812]
 755:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->SYSTEM_TIME_SECONDS_UPDATE = time->seconds;
 2571              	 .loc 3 755 0
 2572 0048 7B68     	 ldr r3,[r7,#4]
 2573 004a 1B68     	 ldr r3,[r3]
 2574 004c 3A68     	 ldr r2,[r7]
 2575 004e 5268     	 ldr r2,[r2,#4]
 2576 0050 C3F81027 	 str r2,[r3,#1808]
 756:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 757:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->TIMESTAMP_CONTROL |= (uint32_t)ETH_TIMESTAMP_CONTROL_TSUPDT_Msk;
 2577              	 .loc 3 757 0
 2578 0054 7B68     	 ldr r3,[r7,#4]
 2579 0056 1B68     	 ldr r3,[r3]
 2580 0058 7A68     	 ldr r2,[r7,#4]
 2581 005a 1268     	 ldr r2,[r2]
 2582 005c D2F80027 	 ldr r2,[r2,#1792]
 2583 0060 42F00802 	 orr r2,r2,#8
 2584 0064 C3F80027 	 str r2,[r3,#1792]
 758:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 2585              	 .loc 3 758 0
 2586 0068 1437     	 adds r7,r7,#20
 2587              	.LCFI179:
 2588              	 .cfi_def_cfa_offset 4
 2589 006a BD46     	 mov sp,r7
 2590              	.LCFI180:
 2591              	 .cfi_def_cfa_register 13
 2592              	 
 2593 006c 5DF8047B 	 ldr r7,[sp],#4
 2594              	.LCFI181:
 2595              	 .cfi_restore 7
 2596              	 .cfi_def_cfa_offset 0
 2597 0070 7047     	 bx lr
 2598              	.L107:
 2599 0072 00BF     	 .align 2
 2600              	.L106:
 2601 0074 20BC3E3D 	 .word 1027521568
 2602              	 .cfi_endproc
 2603              	.LFE230:
 2605              	 .section .text.XMC_ETH_MAC_SetPTPAlarm,"ax",%progbits
 2606              	 .align 2
 2607              	 .global XMC_ETH_MAC_SetPTPAlarm
 2608              	 .thumb
 2609              	 .thumb_func
 2611              	XMC_ETH_MAC_SetPTPAlarm:
 2612              	.LFB231:
 759:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 760:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Set PTP alarm */
 761:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_SetPTPAlarm(XMC_ETH_MAC_t *const eth_mac, const XMC_ETH_MAC_TIME_t *const time)
 762:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 2613              	 .loc 3 762 0
 2614              	 .cfi_startproc
 2615              	 
 2616              	 
 2617              	 
 2618 0000 80B4     	 push {r7}
 2619              	.LCFI182:
 2620              	 .cfi_def_cfa_offset 4
 2621              	 .cfi_offset 7,-4
 2622 0002 83B0     	 sub sp,sp,#12
 2623              	.LCFI183:
 2624              	 .cfi_def_cfa_offset 16
 2625 0004 00AF     	 add r7,sp,#0
 2626              	.LCFI184:
 2627              	 .cfi_def_cfa_register 7
 2628 0006 7860     	 str r0,[r7,#4]
 2629 0008 3960     	 str r1,[r7]
 763:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_SetPTPAlarm: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->regs
 764:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 765:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->TARGET_TIME_NANOSECONDS = (uint32_t)(time->nanoseconds * (100000000.0F / (0x800000
 2630              	 .loc 3 765 0
 2631 000a 7B68     	 ldr r3,[r7,#4]
 2632 000c 1B68     	 ldr r3,[r3]
 2633 000e 3A68     	 ldr r2,[r7]
 2634 0010 1268     	 ldr r2,[r2]
 2635 0012 07EE902A 	 fmsr s15,r2
 2636 0016 F8EEE77A 	 fsitos s15,s15
 2637 001a 9FED0A7A 	 flds s14,.L109
 2638 001e 67EE877A 	 fmuls s15,s15,s14
 2639 0022 FCEEE77A 	 ftouizs s15,s15
 2640 0026 17EE902A 	 fmrs r2,s15
 2641 002a C3F82027 	 str r2,[r3,#1824]
 766:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->TARGET_TIME_SECONDS = time->seconds;
 2642              	 .loc 3 766 0
 2643 002e 7B68     	 ldr r3,[r7,#4]
 2644 0030 1B68     	 ldr r3,[r3]
 2645 0032 3A68     	 ldr r2,[r7]
 2646 0034 5268     	 ldr r2,[r2,#4]
 2647 0036 C3F81C27 	 str r2,[r3,#1820]
 767:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 2648              	 .loc 3 767 0
 2649 003a 0C37     	 adds r7,r7,#12
 2650              	.LCFI185:
 2651              	 .cfi_def_cfa_offset 4
 2652 003c BD46     	 mov sp,r7
 2653              	.LCFI186:
 2654              	 .cfi_def_cfa_register 13
 2655              	 
 2656 003e 5DF8047B 	 ldr r7,[sp],#4
 2657              	.LCFI187:
 2658              	 .cfi_restore 7
 2659              	 .cfi_def_cfa_offset 0
 2660 0042 7047     	 bx lr
 2661              	.L110:
 2662              	 .align 2
 2663              	.L109:
 2664 0044 20BC3E3D 	 .word 1027521568
 2665              	 .cfi_endproc
 2666              	.LFE231:
 2668              	 .section .text.XMC_ETH_MAC_AdjustPTPClock,"ax",%progbits
 2669              	 .align 2
 2670              	 .global XMC_ETH_MAC_AdjustPTPClock
 2671              	 .thumb
 2672              	 .thumb_func
 2674              	XMC_ETH_MAC_AdjustPTPClock:
 2675              	.LFB232:
 768:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 769:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Adjust PTP clock */
 770:../Libraries/XMCLib/src/xmc_eth_mac.c **** void XMC_ETH_MAC_AdjustPTPClock(XMC_ETH_MAC_t *const eth_mac, uint32_t correction)
 771:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 2676              	 .loc 3 771 0
 2677              	 .cfi_startproc
 2678              	 
 2679              	 
 2680 0000 F0B5     	 push {r4,r5,r6,r7,lr}
 2681              	.LCFI188:
 2682              	 .cfi_def_cfa_offset 20
 2683              	 .cfi_offset 4,-20
 2684              	 .cfi_offset 5,-16
 2685              	 .cfi_offset 6,-12
 2686              	 .cfi_offset 7,-8
 2687              	 .cfi_offset 14,-4
 2688 0002 83B0     	 sub sp,sp,#12
 2689              	.LCFI189:
 2690              	 .cfi_def_cfa_offset 32
 2691 0004 00AF     	 add r7,sp,#0
 2692              	.LCFI190:
 2693              	 .cfi_def_cfa_register 7
 2694 0006 7860     	 str r0,[r7,#4]
 2695 0008 3960     	 str r1,[r7]
 772:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_AdjustPTPClock: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->r
 773:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 774:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /* Correction factor is Q31 (0x80000000 = 1.000000000) */
 775:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->TIMESTAMP_ADDEND = (uint32_t)(((uint64_t)correction * eth_mac->regs->TIMESTAMP_ADD
 2696              	 .loc 3 775 0
 2697 000a 7B68     	 ldr r3,[r7,#4]
 2698 000c 1E68     	 ldr r6,[r3]
 2699 000e 3B68     	 ldr r3,[r7]
 2700 0010 1846     	 mov r0,r3
 2701 0012 4FF00001 	 mov r1,#0
 2702 0016 7B68     	 ldr r3,[r7,#4]
 2703 0018 1B68     	 ldr r3,[r3]
 2704 001a D3F81837 	 ldr r3,[r3,#1816]
 2705 001e 1A46     	 mov r2,r3
 2706 0020 4FF00003 	 mov r3,#0
 2707 0024 02FB01FC 	 mul ip,r2,r1
 2708 0028 00FB03FE 	 mul lr,r0,r3
 2709 002c E644     	 add lr,lr,ip
 2710 002e A0FB0223 	 umull r2,r3,r0,r2
 2711 0032 0EEB0301 	 add r1,lr,r3
 2712 0036 0B46     	 mov r3,r1
 2713 0038 D40F     	 lsrs r4,r2,#31
 2714 003a 44EA4304 	 orr r4,r4,r3,lsl#1
 2715 003e DD0F     	 lsrs r5,r3,#31
 2716 0040 2346     	 mov r3,r4
 2717 0042 C6F81837 	 str r3,[r6,#1816]
 776:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 777:../Libraries/XMCLib/src/xmc_eth_mac.c ****   /* Update addend register */
 778:../Libraries/XMCLib/src/xmc_eth_mac.c ****   eth_mac->regs->TIMESTAMP_CONTROL |= (uint32_t)ETH_TIMESTAMP_CONTROL_TSADDREG_Msk;
 2718              	 .loc 3 778 0
 2719 0046 7B68     	 ldr r3,[r7,#4]
 2720 0048 1B68     	 ldr r3,[r3]
 2721 004a 7A68     	 ldr r2,[r7,#4]
 2722 004c 1268     	 ldr r2,[r2]
 2723 004e D2F80027 	 ldr r2,[r2,#1792]
 2724 0052 42F02002 	 orr r2,r2,#32
 2725 0056 C3F80027 	 str r2,[r3,#1792]
 779:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 2726              	 .loc 3 779 0
 2727 005a 0C37     	 adds r7,r7,#12
 2728              	.LCFI191:
 2729              	 .cfi_def_cfa_offset 20
 2730 005c BD46     	 mov sp,r7
 2731              	.LCFI192:
 2732              	 .cfi_def_cfa_register 13
 2733              	 
 2734 005e F0BD     	 pop {r4,r5,r6,r7,pc}
 2735              	 .cfi_endproc
 2736              	.LFE232:
 2738              	 .section .text.XMC_ETH_MAC_GetPTPStatus,"ax",%progbits
 2739              	 .align 2
 2740              	 .global XMC_ETH_MAC_GetPTPStatus
 2741              	 .thumb
 2742              	 .thumb_func
 2744              	XMC_ETH_MAC_GetPTPStatus:
 2745              	.LFB233:
 780:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 781:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Set PTP status */
 782:../Libraries/XMCLib/src/xmc_eth_mac.c **** uint32_t XMC_ETH_MAC_GetPTPStatus(const XMC_ETH_MAC_t *const eth_mac)
 783:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 2746              	 .loc 3 783 0
 2747              	 .cfi_startproc
 2748              	 
 2749              	 
 2750              	 
 2751 0000 80B4     	 push {r7}
 2752              	.LCFI193:
 2753              	 .cfi_def_cfa_offset 4
 2754              	 .cfi_offset 7,-4
 2755 0002 83B0     	 sub sp,sp,#12
 2756              	.LCFI194:
 2757              	 .cfi_def_cfa_offset 16
 2758 0004 00AF     	 add r7,sp,#0
 2759              	.LCFI195:
 2760              	 .cfi_def_cfa_register 7
 2761 0006 7860     	 str r0,[r7,#4]
 784:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_GetPTPStatus: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->reg
 785:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 786:../Libraries/XMCLib/src/xmc_eth_mac.c ****   return (eth_mac->regs->TIMESTAMP_STATUS);
 2762              	 .loc 3 786 0
 2763 0008 7B68     	 ldr r3,[r7,#4]
 2764 000a 1B68     	 ldr r3,[r3]
 2765 000c D3F82837 	 ldr r3,[r3,#1832]
 787:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 2766              	 .loc 3 787 0
 2767 0010 1846     	 mov r0,r3
 2768 0012 0C37     	 adds r7,r7,#12
 2769              	.LCFI196:
 2770              	 .cfi_def_cfa_offset 4
 2771 0014 BD46     	 mov sp,r7
 2772              	.LCFI197:
 2773              	 .cfi_def_cfa_register 13
 2774              	 
 2775 0016 5DF8047B 	 ldr r7,[sp],#4
 2776              	.LCFI198:
 2777              	 .cfi_restore 7
 2778              	 .cfi_def_cfa_offset 0
 2779 001a 7047     	 bx lr
 2780              	 .cfi_endproc
 2781              	.LFE233:
 2783              	 .section .text.XMC_ETH_MAC_GetRxTimeStamp,"ax",%progbits
 2784              	 .align 2
 2785              	 .global XMC_ETH_MAC_GetRxTimeStamp
 2786              	 .thumb
 2787              	 .thumb_func
 2789              	XMC_ETH_MAC_GetRxTimeStamp:
 2790              	.LFB234:
 788:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 789:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Get TX time-stamp */
 790:../Libraries/XMCLib/src/xmc_eth_mac.c **** XMC_ETH_MAC_STATUS_t XMC_ETH_MAC_GetRxTimeStamp(XMC_ETH_MAC_t *const eth_mac, XMC_ETH_MAC_TIME_t *c
 791:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 2791              	 .loc 3 791 0
 2792              	 .cfi_startproc
 2793              	 
 2794              	 
 2795              	 
 2796 0000 80B4     	 push {r7}
 2797              	.LCFI199:
 2798              	 .cfi_def_cfa_offset 4
 2799              	 .cfi_offset 7,-4
 2800 0002 85B0     	 sub sp,sp,#20
 2801              	.LCFI200:
 2802              	 .cfi_def_cfa_offset 24
 2803 0004 00AF     	 add r7,sp,#0
 2804              	.LCFI201:
 2805              	 .cfi_def_cfa_register 7
 2806 0006 7860     	 str r0,[r7,#4]
 2807 0008 3960     	 str r1,[r7]
 792:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ETH_MAC_DMA_DESC_t *rx_desc;
 793:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ETH_MAC_STATUS_t status;
 794:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 795:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_GetRxTimeStamp: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->r
 796:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_GetRxTimeStamp: time is invalid", time != NULL);
 797:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 798:../Libraries/XMCLib/src/xmc_eth_mac.c ****   rx_desc = &eth_mac->rx_desc[eth_mac->rx_index];
 2808              	 .loc 3 798 0
 2809 000a 7B68     	 ldr r3,[r7,#4]
 2810 000c 1A69     	 ldr r2,[r3,#16]
 2811 000e 7B68     	 ldr r3,[r7,#4]
 2812 0010 93F82730 	 ldrb r3,[r3,#39]
 2813 0014 5B01     	 lsls r3,r3,#5
 2814 0016 1344     	 add r3,r3,r2
 2815 0018 BB60     	 str r3,[r7,#8]
 799:../Libraries/XMCLib/src/xmc_eth_mac.c ****   if (rx_desc->status & ETH_MAC_DMA_RDES0_OWN)
 2816              	 .loc 3 799 0
 2817 001a BB68     	 ldr r3,[r7,#8]
 2818 001c 1B68     	 ldr r3,[r3]
 2819 001e 002B     	 cmp r3,#0
 2820 0020 02DA     	 bge .L115
 800:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 801:../Libraries/XMCLib/src/xmc_eth_mac.c ****     status = XMC_ETH_MAC_STATUS_BUSY;
 2821              	 .loc 3 801 0
 2822 0022 0123     	 movs r3,#1
 2823 0024 FB73     	 strb r3,[r7,#15]
 2824 0026 0AE0     	 b .L116
 2825              	.L115:
 802:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 803:../Libraries/XMCLib/src/xmc_eth_mac.c ****   else
 804:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 805:../Libraries/XMCLib/src/xmc_eth_mac.c ****     time->nanoseconds = (int32_t)rx_desc->time_stamp_nanoseconds;
 2826              	 .loc 3 805 0
 2827 0028 BB68     	 ldr r3,[r7,#8]
 2828 002a DB69     	 ldr r3,[r3,#28]
 2829 002c 1A46     	 mov r2,r3
 2830 002e 3B68     	 ldr r3,[r7]
 2831 0030 1A60     	 str r2,[r3]
 806:../Libraries/XMCLib/src/xmc_eth_mac.c ****     time->seconds = rx_desc->time_stamp_seconds;
 2832              	 .loc 3 806 0
 2833 0032 BB68     	 ldr r3,[r7,#8]
 2834 0034 9A69     	 ldr r2,[r3,#24]
 2835 0036 3B68     	 ldr r3,[r7]
 2836 0038 5A60     	 str r2,[r3,#4]
 807:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 808:../Libraries/XMCLib/src/xmc_eth_mac.c ****     status = XMC_ETH_MAC_STATUS_OK;
 2837              	 .loc 3 808 0
 2838 003a 0023     	 movs r3,#0
 2839 003c FB73     	 strb r3,[r7,#15]
 2840              	.L116:
 809:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 810:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 811:../Libraries/XMCLib/src/xmc_eth_mac.c ****   return status;
 2841              	 .loc 3 811 0
 2842 003e FB7B     	 ldrb r3,[r7,#15]
 812:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 2843              	 .loc 3 812 0
 2844 0040 1846     	 mov r0,r3
 2845 0042 1437     	 adds r7,r7,#20
 2846              	.LCFI202:
 2847              	 .cfi_def_cfa_offset 4
 2848 0044 BD46     	 mov sp,r7
 2849              	.LCFI203:
 2850              	 .cfi_def_cfa_register 13
 2851              	 
 2852 0046 5DF8047B 	 ldr r7,[sp],#4
 2853              	.LCFI204:
 2854              	 .cfi_restore 7
 2855              	 .cfi_def_cfa_offset 0
 2856 004a 7047     	 bx lr
 2857              	 .cfi_endproc
 2858              	.LFE234:
 2860              	 .section .text.XMC_ETH_MAC_GetTxTimeStamp,"ax",%progbits
 2861              	 .align 2
 2862              	 .global XMC_ETH_MAC_GetTxTimeStamp
 2863              	 .thumb
 2864              	 .thumb_func
 2866              	XMC_ETH_MAC_GetTxTimeStamp:
 2867              	.LFB235:
 813:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 814:../Libraries/XMCLib/src/xmc_eth_mac.c **** /* Get TX time-stamp */
 815:../Libraries/XMCLib/src/xmc_eth_mac.c **** XMC_ETH_MAC_STATUS_t XMC_ETH_MAC_GetTxTimeStamp(XMC_ETH_MAC_t *const eth_mac, XMC_ETH_MAC_TIME_t *c
 816:../Libraries/XMCLib/src/xmc_eth_mac.c **** {
 2868              	 .loc 3 816 0
 2869              	 .cfi_startproc
 2870              	 
 2871              	 
 2872              	 
 2873 0000 80B4     	 push {r7}
 2874              	.LCFI205:
 2875              	 .cfi_def_cfa_offset 4
 2876              	 .cfi_offset 7,-4
 2877 0002 85B0     	 sub sp,sp,#20
 2878              	.LCFI206:
 2879              	 .cfi_def_cfa_offset 24
 2880 0004 00AF     	 add r7,sp,#0
 2881              	.LCFI207:
 2882              	 .cfi_def_cfa_register 7
 2883 0006 7860     	 str r0,[r7,#4]
 2884 0008 3960     	 str r1,[r7]
 817:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ETH_MAC_DMA_DESC_t *tx_desc;
 818:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ETH_MAC_STATUS_t status;
 819:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 820:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_GetTxTimeStamp: eth_mac is invalid", XMC_ETH_MAC_IsValidModule(eth_mac->r
 821:../Libraries/XMCLib/src/xmc_eth_mac.c ****   XMC_ASSERT("XMC_ETH_MAC_GetTxTimeStamp: time is invalid", time != NULL);
 822:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 823:../Libraries/XMCLib/src/xmc_eth_mac.c ****   tx_desc = &eth_mac->tx_desc[eth_mac->tx_ts_index];
 2885              	 .loc 3 823 0
 2886 000a 7B68     	 ldr r3,[r7,#4]
 2887 000c 5A69     	 ldr r2,[r3,#20]
 2888 000e 7B68     	 ldr r3,[r7,#4]
 2889 0010 93F82830 	 ldrb r3,[r3,#40]
 2890 0014 5B01     	 lsls r3,r3,#5
 2891 0016 1344     	 add r3,r3,r2
 2892 0018 BB60     	 str r3,[r7,#8]
 824:../Libraries/XMCLib/src/xmc_eth_mac.c ****   if (tx_desc->status & ETH_MAC_DMA_TDES0_OWN)
 2893              	 .loc 3 824 0
 2894 001a BB68     	 ldr r3,[r7,#8]
 2895 001c 1B68     	 ldr r3,[r3]
 2896 001e 002B     	 cmp r3,#0
 2897 0020 02DA     	 bge .L119
 825:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 826:../Libraries/XMCLib/src/xmc_eth_mac.c ****     status = XMC_ETH_MAC_STATUS_BUSY;
 2898              	 .loc 3 826 0
 2899 0022 0123     	 movs r3,#1
 2900 0024 FB73     	 strb r3,[r7,#15]
 2901 0026 0AE0     	 b .L120
 2902              	.L119:
 827:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 828:../Libraries/XMCLib/src/xmc_eth_mac.c ****   else
 829:../Libraries/XMCLib/src/xmc_eth_mac.c ****   {
 830:../Libraries/XMCLib/src/xmc_eth_mac.c ****     time->nanoseconds = (int32_t)tx_desc->time_stamp_nanoseconds;
 2903              	 .loc 3 830 0
 2904 0028 BB68     	 ldr r3,[r7,#8]
 2905 002a DB69     	 ldr r3,[r3,#28]
 2906 002c 1A46     	 mov r2,r3
 2907 002e 3B68     	 ldr r3,[r7]
 2908 0030 1A60     	 str r2,[r3]
 831:../Libraries/XMCLib/src/xmc_eth_mac.c ****     time->seconds = tx_desc->time_stamp_seconds;
 2909              	 .loc 3 831 0
 2910 0032 BB68     	 ldr r3,[r7,#8]
 2911 0034 9A69     	 ldr r2,[r3,#24]
 2912 0036 3B68     	 ldr r3,[r7]
 2913 0038 5A60     	 str r2,[r3,#4]
 832:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 833:../Libraries/XMCLib/src/xmc_eth_mac.c ****     status = XMC_ETH_MAC_STATUS_OK;
 2914              	 .loc 3 833 0
 2915 003a 0023     	 movs r3,#0
 2916 003c FB73     	 strb r3,[r7,#15]
 2917              	.L120:
 834:../Libraries/XMCLib/src/xmc_eth_mac.c ****   }
 835:../Libraries/XMCLib/src/xmc_eth_mac.c **** 
 836:../Libraries/XMCLib/src/xmc_eth_mac.c ****   return status;
 2918              	 .loc 3 836 0
 2919 003e FB7B     	 ldrb r3,[r7,#15]
 837:../Libraries/XMCLib/src/xmc_eth_mac.c **** }
 2920              	 .loc 3 837 0
 2921 0040 1846     	 mov r0,r3
 2922 0042 1437     	 adds r7,r7,#20
 2923              	.LCFI208:
 2924              	 .cfi_def_cfa_offset 4
 2925 0044 BD46     	 mov sp,r7
 2926              	.LCFI209:
 2927              	 .cfi_def_cfa_register 13
 2928              	 
 2929 0046 5DF8047B 	 ldr r7,[sp],#4
 2930              	.LCFI210:
 2931              	 .cfi_restore 7
 2932              	 .cfi_def_cfa_offset 0
 2933 004a 7047     	 bx lr
 2934              	 .cfi_endproc
 2935              	.LFE235:
 2937              	 .text
 2938              	.Letext0:
 2939              	 .file 4 "e:\\davev4\\dave-4.1.4\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 2940              	 .file 5 "e:\\davev4\\dave-4.1.4\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 2941              	 .file 6 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode/Libraries/CMSIS/Infineon/XMC4700_series/Include/XMC4700.h"
 2942              	 .file 7 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode/Libraries/CMSIS/Include/core_cm4.h"
 2943              	 .file 8 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode/Libraries/CMSIS/Infineon/XMC4700_series/Include/system_XMC4700.h"
DEFINED SYMBOLS
                            *ABS*:00000000 xmc_eth_mac.c
    {standard input}:20     .text.XMC_ETH_MAC_Reset:00000000 $t
    {standard input}:24     .text.XMC_ETH_MAC_Reset:00000000 XMC_ETH_MAC_Reset
    {standard input}:81     .text.XMC_ETH_MAC_SetAddress:00000000 $t
    {standard input}:85     .text.XMC_ETH_MAC_SetAddress:00000000 XMC_ETH_MAC_SetAddress
    {standard input}:138    .text.XMC_SCU_CLOCK_GetSystemClockFrequency:00000000 $t
    {standard input}:142    .text.XMC_SCU_CLOCK_GetSystemClockFrequency:00000000 XMC_SCU_CLOCK_GetSystemClockFrequency
    {standard input}:178    .text.XMC_SCU_CLOCK_GetSystemClockFrequency:00000020 $d
    {standard input}:184    .text.XMC_SCU_CLOCK_GetEthernetClockFrequency:00000000 $t
    {standard input}:188    .text.XMC_SCU_CLOCK_GetEthernetClockFrequency:00000000 XMC_SCU_CLOCK_GetEthernetClockFrequency
    {standard input}:213    .text.XCM_ETH_MAC_IsNormalEvent:00000000 $t
    {standard input}:217    .text.XCM_ETH_MAC_IsNormalEvent:00000000 XCM_ETH_MAC_IsNormalEvent
    {standard input}:263    .text.XCM_ETH_MAC_IsAbnormalEvent:00000000 $t
    {standard input}:267    .text.XCM_ETH_MAC_IsAbnormalEvent:00000000 XCM_ETH_MAC_IsAbnormalEvent
    {standard input}:312    .text.XMC_ETH_MAC_Init:00000000 $t
    {standard input}:317    .text.XMC_ETH_MAC_Init:00000000 XMC_ETH_MAC_Init
    {standard input}:1360   .text.XMC_ETH_MAC_Enable:00000000 XMC_ETH_MAC_Enable
    {standard input}:1231   .text.XMC_ETH_MAC_SetManagmentClockDivider:00000000 XMC_ETH_MAC_SetManagmentClockDivider
    {standard input}:416    .text.XMC_ETH_MAC_InitRxDescriptors:00000000 XMC_ETH_MAC_InitRxDescriptors
    {standard input}:541    .text.XMC_ETH_MAC_InitTxDescriptors:00000000 XMC_ETH_MAC_InitTxDescriptors
    {standard input}:411    .text.XMC_ETH_MAC_InitRxDescriptors:00000000 $t
    {standard input}:536    .text.XMC_ETH_MAC_InitTxDescriptors:00000000 $t
    {standard input}:652    .text.XMC_ETH_MAC_InitTxDescriptors:0000009c $d
    {standard input}:657    .text.XMC_ETH_MAC_SetAddressPerfectFilter:00000000 $t
    {standard input}:662    .text.XMC_ETH_MAC_SetAddressPerfectFilter:00000000 XMC_ETH_MAC_SetAddressPerfectFilter
    {standard input}:729    .text.XMC_ETH_MAC_SetAddressHashFilter:00000000 $t
    {standard input}:734    .text.XMC_ETH_MAC_SetAddressHashFilter:00000000 XMC_ETH_MAC_SetAddressHashFilter
    {standard input}:787    .text.XMC_ETH_MAC_SendFrame:00000000 $t
    {standard input}:792    .text.XMC_ETH_MAC_SendFrame:00000000 XMC_ETH_MAC_SendFrame
    {standard input}:1020   .text.XMC_ETH_MAC_ReadFrame:00000000 $t
    {standard input}:1025   .text.XMC_ETH_MAC_ReadFrame:00000000 XMC_ETH_MAC_ReadFrame
    {standard input}:1127   .text.XMC_ETH_MAC_GetRxFrameSize:00000000 $t
    {standard input}:1132   .text.XMC_ETH_MAC_GetRxFrameSize:00000000 XMC_ETH_MAC_GetRxFrameSize
    {standard input}:1221   .text.XMC_ETH_MAC_GetRxFrameSize:0000006c $d
    {standard input}:1226   .text.XMC_ETH_MAC_SetManagmentClockDivider:00000000 $t
    {standard input}:1345   .text.XMC_ETH_MAC_SetManagmentClockDivider:00000088 $d
    {standard input}:1355   .text.XMC_ETH_MAC_Enable:00000000 $t
    {standard input}:1399   .text.XMC_ETH_MAC_Enable:00000020 $d
    {standard input}:1404   .text.XMC_ETH_MAC_Disable:00000000 $t
    {standard input}:1409   .text.XMC_ETH_MAC_Disable:00000000 XMC_ETH_MAC_Disable
    {standard input}:1448   .text.XMC_ETH_MAC_Disable:00000020 $d
    {standard input}:1453   .text.XMC_ETH_MAC_ReadPhy:00000000 $t
    {standard input}:1458   .text.XMC_ETH_MAC_ReadPhy:00000000 XMC_ETH_MAC_ReadPhy
    {standard input}:1552   .text.XMC_ETH_MAC_WritePhy:00000000 $t
    {standard input}:1557   .text.XMC_ETH_MAC_WritePhy:00000000 XMC_ETH_MAC_WritePhy
    {standard input}:1653   .text.XMC_ETH_MAC_FlushTx:00000000 $t
    {standard input}:1658   .text.XMC_ETH_MAC_FlushTx:00000000 XMC_ETH_MAC_FlushTx
    {standard input}:1716   .text.XMC_ETH_MAC_FlushRx:00000000 $t
    {standard input}:1721   .text.XMC_ETH_MAC_FlushRx:00000000 XMC_ETH_MAC_FlushRx
    {standard input}:1779   .text.XMC_ETH_MAC_SetWakeUpFrameFilter:00000000 $t
    {standard input}:1784   .text.XMC_ETH_MAC_SetWakeUpFrameFilter:00000000 XMC_ETH_MAC_SetWakeUpFrameFilter
    {standard input}:1844   .text.XMC_ETH_MAC_EnableEvent:00000000 $t
    {standard input}:1849   .text.XMC_ETH_MAC_EnableEvent:00000000 XMC_ETH_MAC_EnableEvent
    {standard input}:1931   .text.XMC_ETH_MAC_DisableEvent:00000000 $t
    {standard input}:1936   .text.XMC_ETH_MAC_DisableEvent:00000000 XMC_ETH_MAC_DisableEvent
    {standard input}:1999   .text.XMC_ETH_MAC_ClearEventStatus:00000000 $t
    {standard input}:2004   .text.XMC_ETH_MAC_ClearEventStatus:00000000 XMC_ETH_MAC_ClearEventStatus
    {standard input}:2075   .text.XMC_ETH_MAC_GetEventStatus:00000000 $t
    {standard input}:2080   .text.XMC_ETH_MAC_GetEventStatus:00000000 XMC_ETH_MAC_GetEventStatus
    {standard input}:2135   .text.XMC_ETH_MAC_ReturnRxDescriptor:00000000 $t
    {standard input}:2140   .text.XMC_ETH_MAC_ReturnRxDescriptor:00000000 XMC_ETH_MAC_ReturnRxDescriptor
    {standard input}:2191   .text.XMC_ETH_MAC_ReturnTxDescriptor:00000000 $t
    {standard input}:2196   .text.XMC_ETH_MAC_ReturnTxDescriptor:00000000 XMC_ETH_MAC_ReturnTxDescriptor
    {standard input}:2247   .text.XMC_ETH_MAC_IsTxDescriptorOwnedByDma:00000000 $t
    {standard input}:2252   .text.XMC_ETH_MAC_IsTxDescriptorOwnedByDma:00000000 XMC_ETH_MAC_IsTxDescriptorOwnedByDma
    {standard input}:2298   .text.XMC_ETH_MAC_SetVLANTag:00000000 $t
    {standard input}:2303   .text.XMC_ETH_MAC_SetVLANTag:00000000 XMC_ETH_MAC_SetVLANTag
    {standard input}:2345   .text.XMC_ETH_MAC_InitPTP:00000000 $t
    {standard input}:2350   .text.XMC_ETH_MAC_InitPTP:00000000 XMC_ETH_MAC_InitPTP
    {standard input}:2451   .text.XMC_ETH_MAC_InitPTP:000000c8 $d
    {standard input}:2456   .text.XMC_ETH_MAC_GetPTPTime:00000000 $t
    {standard input}:2461   .text.XMC_ETH_MAC_GetPTPTime:00000000 XMC_ETH_MAC_GetPTPTime
    {standard input}:2514   .text.XMC_ETH_MAC_GetPTPTime:00000044 $d
    {standard input}:2519   .text.XMC_ETH_MAC_UpdatePTPTime:00000000 $t
    {standard input}:2524   .text.XMC_ETH_MAC_UpdatePTPTime:00000000 XMC_ETH_MAC_UpdatePTPTime
    {standard input}:2601   .text.XMC_ETH_MAC_UpdatePTPTime:00000074 $d
    {standard input}:2606   .text.XMC_ETH_MAC_SetPTPAlarm:00000000 $t
    {standard input}:2611   .text.XMC_ETH_MAC_SetPTPAlarm:00000000 XMC_ETH_MAC_SetPTPAlarm
    {standard input}:2664   .text.XMC_ETH_MAC_SetPTPAlarm:00000044 $d
    {standard input}:2669   .text.XMC_ETH_MAC_AdjustPTPClock:00000000 $t
    {standard input}:2674   .text.XMC_ETH_MAC_AdjustPTPClock:00000000 XMC_ETH_MAC_AdjustPTPClock
    {standard input}:2739   .text.XMC_ETH_MAC_GetPTPStatus:00000000 $t
    {standard input}:2744   .text.XMC_ETH_MAC_GetPTPStatus:00000000 XMC_ETH_MAC_GetPTPStatus
    {standard input}:2784   .text.XMC_ETH_MAC_GetRxTimeStamp:00000000 $t
    {standard input}:2789   .text.XMC_ETH_MAC_GetRxTimeStamp:00000000 XMC_ETH_MAC_GetRxTimeStamp
    {standard input}:2861   .text.XMC_ETH_MAC_GetTxTimeStamp:00000000 $t
    {standard input}:2866   .text.XMC_ETH_MAC_GetTxTimeStamp:00000000 XMC_ETH_MAC_GetTxTimeStamp
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
SystemCoreClock
memcpy
XMC_SCU_CLOCK_EnableClock
XMC_SCU_CLOCK_UngatePeripheralClock
XMC_SCU_RESET_DeassertPeripheralReset
XMC_SCU_RESET_AssertPeripheralReset
XMC_SCU_CLOCK_GatePeripheralClock
XMC_SCU_CLOCK_DisableClock
