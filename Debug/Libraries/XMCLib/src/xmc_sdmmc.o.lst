   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "xmc_sdmmc.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.XMC_SDMMC_SetDataLineTimeout,"ax",%progbits
  20              	 .align 2
  21              	 .thumb
  22              	 .thumb_func
  24              	XMC_SDMMC_SetDataLineTimeout:
  25              	.LFB160:
  26              	 .file 1 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Libraries\\XMCLib\\inc/xmc_sdmmc.h"
   1:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
   2:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
   3:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @file xmc_sdmmc.h
   4:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @date 2016-01-12
   5:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
   6:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @cond
   7:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  **************************************************************************************************
   8:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * XMClib v2.1.6 - XMC Peripheral Driver Library 
   9:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
  10:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  11:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * All rights reserved.                        
  12:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *                                             
  13:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  14:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * following conditions are met:   
  15:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *                                                                              
  16:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  17:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * disclaimer.                        
  18:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 
  19:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  20:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  21:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 
  22:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  23:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * products derived from this software without specific prior written permission.                  
  24:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *                                                                              
  25:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  26:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  27:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  28:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  29:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  30:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  31:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  32:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *                                                                              
  33:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  34:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  35:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  **************************************************************************************************
  36:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
  37:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Change History
  38:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * --------------
  39:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
  40:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 2015-02-20:
  41:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *     - Initial version
  42:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *     - Documentation updates
  43:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
  44:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 2015-06-20:
  45:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *     - Removed version macros and declaration of GetDriverVersion API <br>
  46:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
  47:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 2016-01-16:
  48:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *     - Added the following APIs to the XMC_SDMMC low level driver <br>
  49:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *         1) XMC_SDMMC_EnableDelayCmdDatLines <br>
  50:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *         2) XMC_SDMMC_DisableDelayCmdDatLines <br>
  51:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *         3) XMC_SDMMC_SetDelay <br>
  52:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *         4) XMC_SDMMC_EnableHighSpeed <br>
  53:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *         5) XMC_SDMMC_DisableHighSpeed <br>
  54:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
  55:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @endcond
  56:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
  57:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
  58:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #ifndef XMC_SDMMC_H
  59:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #define XMC_SDMMC_H
  60:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
  61:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /*******************************************************************************
  62:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * HEADER FILES
  63:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *******************************************************************************/
  64:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  
  65:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #include "xmc_common.h"
  66:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
  67:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #if defined (SDMMC)
  68:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
  69:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
  70:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @addtogroup XMClib XMC Peripheral Library
  71:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @{
  72:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
  73:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
  74:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
  75:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @addtogroup SDMMC
  76:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @brief Secure Digital/Multi Media Card (SDMMC) driver for the XMC4500 microcontroller
  77:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
  78:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The SDMMC peripheral provides an interface between SD/SDIO/MMC cards and the AHB. It handles
  79:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * the SD/SDIO protocol at transmission level. It automatically packs data and checks for CRC,
  80:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * start/end bits and format correctness. For SD cards, a maximum transfer rate of 24MB/sec is
  81:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * supported and for MMC cards, 48MB/sec.
  82:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
  83:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The peripheral can be used for applications that require large storage memory; e.g. Data logging
  84:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * firmware updates or an embedded database.
  85:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
  86:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The SDMMC low level driver provides functions to configure and initialize the SDMMC hardware
  87:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * peripheral.
  88:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @{
  89:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
  90:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
  91:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /*******************************************************************************
  92:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * MACROS
  93:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *******************************************************************************/
  94:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
  95:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
  96:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * A convenient symbol for the SDMMC peripheral base address
  97:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
  98:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #if defined (SDMMC)
  99:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** # define XMC_SDMMC ((XMC_SDMMC_t *)SDMMC_BASE)
 100:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #else
 101:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** # error 'SDMMC' base peripheral pointer not defined
 102:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #endif
 103:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 104:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /*
 105:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Check for valid ACMD errors <br>
 106:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 107:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * This macro is used in the LLD for assertion checks (XMC_ASSERT).
 108:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 109:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #define XMC_SDMMC_CHECK_MODULE_PTR(p) ((p) == XMC_SDMMC)
 110:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 111:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /*
 112:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Check for valid ACMD errors <br>
 113:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 114:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * This macro is used in the LLD for assertion checks (XMC_ASSERT).
 115:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 116:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #define XMC_SDMMC_CHECK_ACMD_ERR(v)\
 117:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   ((v == XMC_SDMMC_ACMD12_NOT_EXEC_ERR) ||\
 118:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (v == XMC_SDMMC_ACMD_TIMEOUT_ERR)    ||\
 119:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (v == XMC_SDMMC_ACMD_CRC_ERR)        ||\
 120:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (v == XMC_SDMMC_ACMD_END_BIT_ERR)    ||\
 121:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (v == XMC_SDMMC_ACMD_IND_ERR)        ||\
 122:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (v == XMC_SDMMC_CMD_NOT_ISSUED_BY_ACMD12_ERR))
 123:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 124:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /*
 125:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Check for valid SDCLK divider frequency <br>
 126:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 127:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * This macro is used in the LLD for assertion checks (XMC_ASSERT).
 128:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 129:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #define XMC_SDMMC_CHECK_SDCLK_FREQ(f)\
 130:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   ((f == XMC_SDMMC_CLK_DIV_1)           ||\
 131:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (f == XMC_SDMMC_CLK_DIV_2)           ||\
 132:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (f == XMC_SDMMC_CLK_DIV_4)           ||\
 133:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (f == XMC_SDMMC_CLK_DIV_8)           ||\
 134:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (f == XMC_SDMMC_CLK_DIV_16)          ||\
 135:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (f == XMC_SDMMC_CLK_DIV_32)          ||\
 136:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (f == XMC_SDMMC_CLK_DIV_64)          ||\
 137:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (f == XMC_SDMMC_CLK_DIV_128)         ||\
 138:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (f == XMC_SDMMC_CLK_DIV_256))
 139:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 140:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /*
 141:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Check for valid bus voltage levels <br>
 142:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 143:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * This macro is used in the LLD for assertion checks (XMC_ASSERT).
 144:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 145:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #define XMC_SDMMC_CHECK_BUS_VOLTAGE(v)\
 146:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   (v == XMC_SDMMC_BUS_VOLTAGE_3_3_VOLTS)
 147:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 148:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /*
 149:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Check for valid data timeout counter values <br>
 150:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 151:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * This macro is used in the LLD for assertion checks (XMC_ASSERT).
 152:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 153:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #define XMC_SDMMC_CHECK_DAT_TIMEOUT_COUNTER(c)\
 154:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   ((c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_13) ||\
 155:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_14) ||\
 156:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_15) ||\
 157:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_16) ||\
 158:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_17) ||\
 159:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_18) ||\
 160:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_19) ||\
 161:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_20) ||\
 162:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_21) ||\
 163:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_22) ||\
 164:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_23) ||\
 165:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_24) ||\
 166:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_25) ||\
 167:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_26) ||\
 168:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (c == XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_27))
 169:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 170:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /*
 171:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Valid number of data lines <br>
 172:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 173:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * This macro is used in the LLD for assertion checks (XMC_ASSERT).
 174:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 175:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #define XMC_SDMMC_CHECK_DATA_LINES(l)\
 176:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   ((l == XMC_SDMMC_DATA_LINES_1)        ||\
 177:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (l == XMC_SDMMC_DATA_LINES_4)        ||\
 178:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (l == XMC_SDMMC_DATA_LINES_8))
 179:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 180:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /*
 181:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Check data transfer dir: Host to card and vice-versa <br>
 182:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 183:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * This macro is used in the LLD for assertion checks (XMC_ASSERT).
 184:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 185:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #define XMC_SDMMC_CHECK_DATA_TRANSFER_DIR(d)\
 186:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   ((d == XMC_SDMMC_DATA_TRANSFER_HOST_TO_CARD)   ||\
 187:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****    (d == XMC_SDMMC_DATA_TRANSFER_CARD_TO_HOST))
 188:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 189:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /*
 190:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Min and max number of delay elements <br>
 191:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 192:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * This macro is used in the LLD for assertion checks (XMC_ASSERT).
 193:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 194:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #define XMC_SDMMC_MIN_DELAY_ELEMENTS (0U)
 195:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #define XMC_SDMMC_MAX_DELAY_ELEMENTS (15U)
 196:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 197:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /*******************************************************************************
 198:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * ENUMS
 199:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *******************************************************************************/
 200:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 201:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 202:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Number of data lines for SDMMC data transfer
 203:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 204:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef enum
 205:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 206:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DATA_LINES_1 = 0x00U, /**< Single data line mode */
 207:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DATA_LINES_4 = 0x02U, /**< 4-bit mode */
 208:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DATA_LINES_8 = 0x20U  /**< SD 8-bit mode */
 209:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_DATA_LINES_t;
 210:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 211:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 212:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Valid SD clock frequency divider selection
 213:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 214:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef enum
 215:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 216:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CLK_DIV_1   = 0x00U, /**< Base clock (10 Mhz -> 63 Mhz) */
 217:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CLK_DIV_2   = 0x01U, /**< Base clock divided by 2 */
 218:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CLK_DIV_4   = 0x02U, /**< Base clock divided by 4 */
 219:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CLK_DIV_8   = 0x04U, /**< Base clock divided by 8 */
 220:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CLK_DIV_16  = 0x08U, /**< Base clock divided by 16 */
 221:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CLK_DIV_32  = 0x10U, /**< Base clock divided by 32 */
 222:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CLK_DIV_64  = 0x20U, /**< Base clock divided by 64 */
 223:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CLK_DIV_128 = 0x40U, /**< Base clock divided by 128 */
 224:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CLK_DIV_256 = 0x80U  /**< Base clock divided by 256 */
 225:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_SDCLK_FREQ_SEL_t;
 226:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 227:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 228:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Status return values for the SDMMC low level driver
 229:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 230:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef enum
 231:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 232:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_STATUS_SUCCESS       = 0U, /**< Operation successful */
 233:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_STATUS_CMD_LINE_BUSY,      /**< Command line busy */
 234:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_STATUS_DAT_LINE_BUSY       /**< Data line busy */
 235:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_STATUS_t;
 236:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 237:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 238:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SDMMC events (Normal and error events)
 239:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 240:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef enum
 241:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 242:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CMD_COMPLETE       = 0x01U, /**< Command complete event */
 243:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_TX_COMPLETE        = 0x02U, /**< Transmit complete event */
 244:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_BLOCK_GAP_EVENT    = 0x04U, /**< Block gap event */
 245:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_BUFFER_WRITE_READY = 0x10U, /**< Buffer write ready event */
 246:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_BUFFER_READ_READY  = 0x20U, /**< Buffer read ready event */
 247:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CARD_INS           = 0x40U, /**< Card insert event */
 248:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CARD_REMOVAL       = 0x80U, /**< Card removal event */
 249:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CARD_INT           = 0x100U, /**< Card INT event */
 250:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CARD_ERR           = 0x8000U, /**< Card error interrupt */
 251:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CMD_TIMEOUT_ERR    = ((uint32_t)0x01 << 16U),   /**< Command time-out error */
 252:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CMD_CRC_ERR        = ((uint32_t)0x02U << 16U),  /**< Command CRC error */
 253:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CMD_END_BIT_ERR    = ((uint32_t)0x04U << 16U),  /**< Command end bit error */
 254:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CMD_IND_ERR        = ((uint32_t)0x08U << 16U),  /**< Command index error */
 255:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DATA_TIMEOUT_ERR   = ((uint32_t)0x10U << 16U),  /**< Data time-out error */
 256:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DATA_CRC_ERR       = ((uint32_t)0x20U << 16U),  /**< Data CRC error */
 257:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DATA_END_BIT_ERR   = ((uint32_t)0x40U << 16U),  /**< Data end bit error */
 258:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CURRENT_LIMIT_ERR  = ((uint32_t)0x80U << 16U),  /**< Current limit error */
 259:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_ACMD_ERR           = ((uint32_t)0x100U << 16U), /**< ACMD error */
 260:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_TARGET_RESP_ERR    = ((uint32_t)0x1000U << 16U) /**< Target response error */
 261:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_EVENT_t;
 262:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 263:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 264:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SDMMC wakeup events
 265:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 266:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef enum
 267:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 268:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_WAKEUP_EN_CARD_INT = SDMMC_WAKEUP_CTRL_WAKEUP_EVENT_EN_INT_Msk, /**< Wakeup on card int
 269:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_WAKEUP_EN_CARD_INS = SDMMC_WAKEUP_CTRL_WAKEUP_EVENT_EN_INS_Msk, /**< Wakeup on SD card 
 270:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_WAKEUP_EN_CARD_REM = SDMMC_WAKEUP_CTRL_WAKEUP_EVENT_EN_REM_Msk  /**< Wakeup SD card rem
 271:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_WAKEUP_EVENT_t;
 272:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 273:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 274:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SDMMC software reset modes
 275:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 276:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef enum
 277:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 278:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_SW_RESET_ALL    = SDMMC_SW_RESET_SW_RST_ALL_Msk,      /**< Software reset all */
 279:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_SW_RST_CMD_LINE = SDMMC_SW_RESET_SW_RST_CMD_LINE_Msk, /**< Software reset command line 
 280:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_SW_RST_DAT_LINE = SDMMC_SW_RESET_SW_RST_DAT_LINE_Msk  /**< Software reset data line */
 281:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_SW_RESET_t;
 282:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 283:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 284:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * CMD12 response errors of Auto CMD12
 285:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 286:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef enum
 287:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 288:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_ACMD12_NOT_EXEC_ERR = SDMMC_ACMD_ERR_STATUS_ACMD12_NOT_EXEC_ERR_Msk, /**< ACMD12 not ex
 289:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_ACMD_TIMEOUT_ERR    = SDMMC_ACMD_ERR_STATUS_ACMD_TIMEOUT_ERR_Msk,    /**< ACMD timeout 
 290:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_ACMD_CRC_ERR        = SDMMC_ACMD_ERR_STATUS_ACMD_CRC_ERR_Msk,        /**< ACMD CRC erro
 291:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_ACMD_END_BIT_ERR    = SDMMC_ACMD_ERR_STATUS_ACMD_END_BIT_ERR_Msk,    /**< ACMD end bit 
 292:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_ACMD_IND_ERR        = SDMMC_ACMD_ERR_STATUS_ACMD_IND_ERR_Msk,        /**< ACMD IND erro
 293:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_CMD_NOT_ISSUED_BY_ACMD12_ERR = SDMMC_ACMD_ERR_STATUS_CMD_NOT_ISSUED_BY_ACMD12_ERR_Msk /
 294:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_ACMD_ERR_t;
 295:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 296:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 297:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SDMMC response types
 298:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 299:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef enum
 300:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 301:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_RESPONSE_TYPE_NO_RESPONSE = 0U, /**< No response */
 302:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_RESPONSE_TYPE_R1,               /**< Response type: R1 */
 303:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_RESPONSE_TYPE_R1b,              /**< Response type: R1b */
 304:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_RESPONSE_TYPE_R2,               /**< Response type: R2 */
 305:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_RESPONSE_TYPE_R3,               /**< Response type: R3 */
 306:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_RESPONSE_TYPE_R6,               /**< Response type: R6 */
 307:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_RESPONSE_TYPE_R7                /**< Response type: R7 */
 308:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_RESPONSE_TYPE_t;
 309:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 310:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 311:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Types of SDMMC commands
 312:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 313:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef enum
 314:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 315:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_COMMAND_TYPE_NORMAL  = 0U, /**< Command normal */
 316:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_COMMAND_TYPE_SUSPEND,      /**< Command suspend */
 317:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_COMMAND_TYPE_RESUME,       /**< Command resume */
 318:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_COMMAND_TYPE_ABORT         /**< Command abort */
 319:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_COMMAND_TYPE_t;
 320:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 321:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 322:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SDMMC transfer modes
 323:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 324:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef enum
 325:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 326:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_TRANSFER_MODE_TYPE_SINGLE        = 0x00U, /**< Transfer mode type: single */
 327:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_TRANSFER_MODE_TYPE_INFINITE      = 0x20U, /**< Transfer mode type: infinite */
 328:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_TRANSFER_MODE_TYPE_MULTIPLE      = 0x22U, /**< Transfer mode type: multiple */
 329:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_TRANSFER_MODE_TYPE_STOP_MULTIPLE = 0x22U  /**< Transfer mode type: multiple stop */
 330:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_TRANSFER_MODE_TYPE_t;
 331:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 332:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 333:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Auto command transfer modes
 334:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 335:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef enum
 336:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 337:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_TRANSFER_MODE_AUTO_CMD_DISABLED = 0x00U, /**< ACMD mode disabled */
 338:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_TRANSFER_MODE_AUTO_CMD_12                /**< ACMD12 mode */
 339:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_TRANSFER_MODE_AUTO_CMD_t;
 340:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 341:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 342:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SDMMC bus voltage level
 343:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 344:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef enum
 345:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 346:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_BUS_VOLTAGE_3_3_VOLTS = 0x07U
 347:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_BUS_VOLTAGE_t;
 348:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 349:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 350:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Data line timeout counter values
 351:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 352:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef enum
 353:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 354:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_13 = 0U, /** SDCLK * (2 ^ 13) */
 355:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_14 = 1U, /** SDCLK * (2 ^ 14) */
 356:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_15 = 2U, /** SDCLK * (2 ^ 15) */
 357:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_16 = 3U, /** SDCLK * (2 ^ 16) */
 358:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_17 = 4U, /** SDCLK * (2 ^ 17) */
 359:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_18 = 5U, /** SDCLK * (2 ^ 18) */
 360:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_19 = 6U, /** SDCLK * (2 ^ 19) */
 361:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_20 = 7U, /** SDCLK * (2 ^ 20) */
 362:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_21 = 8U, /** SDCLK * (2 ^ 21) */
 363:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_22 = 9U, /** SDCLK * (2 ^ 22) */
 364:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_23 = 10U, /** SDCLK * (2 ^ 23) */
 365:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_24 = 11U, /** SDCLK * (2 ^ 24) */
 366:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_25 = 12U, /** SDCLK * (2 ^ 25) */
 367:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_26 = 13U, /** SDCLK * (2 ^ 26) */
 368:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_27 = 14U, /** SDCLK * (2 ^ 27) */
 369:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_DAT_TIMEOUT_COUNTER_t;
 370:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 371:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 372:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SDMMC data transfer direction
 373:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 374:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef enum
 375:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 376:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DATA_TRANSFER_HOST_TO_CARD = 0U, /** Host to card */
 377:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DATA_TRANSFER_CARD_TO_HOST       /** Card to host */
 378:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_DATA_TRANSFER_DIR_t;
 379:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 380:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /*******************************************************************************
 381:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * DATA STRUCTURES
 382:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *******************************************************************************/
 383:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 384:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 385:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SDMMC device structure <br>
 386:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 387:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The structure represents a collection of all hardware registers used
 388:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * to configure the SDMMC peripheral on the XMC4500 microcontroller. The
 389:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * registers can be accessed with ::XMC_SDMMC.
 390:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 391:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef struct
 392:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 393:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __I  uint32_t  RESERVED0;
 394:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint16_t  BLOCK_SIZE;
 395:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint16_t  BLOCK_COUNT;
 396:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint32_t  ARGUMENT1;
 397:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint16_t  TRANSFER_MODE;
 398:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint16_t  COMMAND;
 399:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __I  uint32_t  RESPONSE[4];
 400:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint32_t  DATA_BUFFER;
 401:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __I  uint32_t  PRESENT_STATE;
 402:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint8_t   HOST_CTRL;
 403:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint8_t   POWER_CTRL;
 404:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint8_t   BLOCK_GAP_CTRL;
 405:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint8_t   WAKEUP_CTRL;
 406:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint16_t  CLOCK_CTRL;
 407:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint8_t   TIMEOUT_CTRL;
 408:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint8_t   SW_RESET;
 409:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint16_t  INT_STATUS_NORM;
 410:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint16_t  INT_STATUS_ERR;
 411:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint16_t  EN_INT_STATUS_NORM;
 412:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint16_t  EN_INT_STATUS_ERR;
 413:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint16_t  EN_INT_SIGNAL_NORM;
 414:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint16_t  EN_INT_SIGNAL_ERR;
 415:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __I  uint16_t  ACMD_ERR_STATUS;
 416:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __I  uint16_t  RESERVED1[9];
 417:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __O  uint16_t  FORCE_EVENT_ACMD_ERR_STATUS;
 418:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __O  uint16_t  FORCE_EVENT_ERR_STATUS;
 419:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __I  uint32_t  RESERVED2[8];
 420:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __O  uint32_t  DEBUG_SEL;
 421:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __I  uint32_t  RESERVED3[30];
 422:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __IO uint32_t  SPI;
 423:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __I  uint32_t  RESERVED4[2];
 424:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   __I  uint16_t  SLOT_INT_STATUS;
 425:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_t;
 426:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 427:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /* Anonymous structure/union guard start */
 428:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #if defined (__CC_ARM)
 429:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   #pragma push
 430:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   #pragma anon_unions
 431:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #elif defined (__TASKING__)
 432:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   #pragma warning 586
 433:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #endif
 434:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 435:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 436:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Present state of the SDMMC host controller <br>
 437:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 438:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The structure presents a convenient way to obtain the SDMMC peripheral's
 439:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * present state information (for example, the write protect pin level). The
 440:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * XMC_SDMMC_GetPresentState() API can be used to populate the structure
 441:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * with the state of the SD host controller.
 442:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 443:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef union
 444:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 445:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   struct
 446:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   {
 447:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****     uint32_t command_inihibit_cmd 	 : 1; /**< Command: Inhibit command */
 448:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t command_inihibit_dat 	 : 1; /**< Command: Inhibit data */
 449:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t dat_line_active 		 : 1; /**< Data line active */
 450:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t 						 : 5;
 451:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t write_transfer_active 	 : 1; /**< Write transfer active */
 452:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t read_transfer_active 	 : 1; /**< Read transfer active */
 453:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t buffer_write_enable 	 : 1; /**< Buffer write enable */
 454:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t buffer_read_enable 	 : 1; /**< Buffer read enable */
 455:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t 						 : 4;
 456:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t card_inserted 			 : 1; /**< Card inserted */
 457:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t card_state_stable 		 : 1; /**< Card state stable */
 458:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t card_detect_pin_level 	 : 1; /**< Card detect pin level */
 459:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t write_protect_pin_level : 1; /**< Write protect pin level */
 460:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t dat_3_0_pin_level 		 : 4; /**< Data 3_0 pin level */
 461:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t cmd_line_level          : 1; /**< Command line level */
 462:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t dat7_4_pin_level        : 4; /**< Data 7_4 pin level */
 463:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 	uint32_t                         : 3;
 464:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   };
 465:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   uint32_t b32;
 466:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_PRESENT_STATE_t;
 467:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 468:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 469:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SDMMC transfer mode configuration
 470:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 471:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef struct
 472:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 473:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   uint32_t block_size;
 474:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   uint32_t num_blocks;
 475:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_TRANSFER_MODE_TYPE_t type;
 476:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_TRANSFER_MODE_AUTO_CMD_t auto_cmd;
 477:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_DATA_TRANSFER_DIR_t direction;
 478:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_TRANSFER_MODE_t;
 479:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 480:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 481:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Represent an SDMMC command <br>
 482:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 483:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The structure holds the configuration for an SDMMC command. The SDMMC
 484:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * COMMAND register is a 16-bit register which is responsible for enabling
 485:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * configuration parameters like command type, response type, index check
 486:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * enable (and a few more). Once SDMMC.COMMAND is configured, the
 487:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * XMC_SDMMC_SendCommand() function can be used to send the command.
 488:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 489:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef union
 490:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 491:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   struct
 492:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   {
 493:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****     uint16_t response_type_sel : 2; /**< Response type select */
 494:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****     uint16_t                   : 1; /**< Reserved bit */
 495:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****     uint16_t crc_check_en      : 1; /**< Command CRC check enable */
 496:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****     uint16_t index_check_en    : 1; /**< Command index check enable */
 497:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****     uint16_t dat_present_sel   : 1; /**< Data present select */
 498:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****     uint16_t cmd_type          : 2; /**< Command type */
 499:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****     uint16_t cmd_index         : 6; /**< Command index */
 500:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****     uint16_t                   : 2; /**< Reserved bits */
 501:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   };
 502:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   uint16_t cmd;
 503:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_COMMAND_t;
 504:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 505:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /* Anonymous structure/union guard end */
 506:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #if defined (__CC_ARM)
 507:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   #pragma pop
 508:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #elif defined (__TASKING__)
 509:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   #pragma warning restore
 510:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #endif
 511:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 512:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 513:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Card response structure
 514:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 515:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef struct
 516:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 517:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   uint32_t response_0;
 518:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   uint32_t response_2;
 519:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   uint32_t response_4;
 520:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   uint32_t response_6;
 521:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_RESPONSE_t;
 522:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 523:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 524:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SDMMC configuration data structure <br>
 525:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 526:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The structure is used to configure the bus width and the clock divider.
 527:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 528:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** typedef struct
 529:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 530:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   uint8_t bus_width; /**< SDMMC bus width */
 531:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_SDCLK_FREQ_SEL_t clock_divider; /**< SDMMC clock divider */
 532:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** } XMC_SDMMC_CONFIG_t;
 533:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 534:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /*******************************************************************************
 535:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * API PROTOTYPES
 536:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *******************************************************************************/
 537:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 538:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #ifdef __cplusplus
 539:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** extern "C" {
 540:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** #endif
 541:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 542:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 543:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 544:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return bool
 545:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 546:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 547:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Get power status of the SDMMC peripheral <br>
 548:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 549:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 550:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function checks the SD_BUS_POWER bit-field of the POWER_CTRL register and returns
 551:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * a boolean value - "on" or "off".
 552:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 553:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** bool XMC_SDMMC_GetPowerStatus(XMC_SDMMC_t *const sdmmc);
 554:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 555:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 556:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 557:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 558:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 559:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 560:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Enable SDMMC peripheral <br>
 561:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 562:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 563:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function de-asserts the peripheral reset. The peripheral needs to be initialized.
 564:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 565:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** void XMC_SDMMC_Enable(XMC_SDMMC_t *const sdmmc);
 566:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 567:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 568:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 569:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 570:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 571:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 572:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Disable SDMMC peripheral <br>
 573:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 574:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 575:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function asserts the peripheral reset.
 576:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 577:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** void XMC_SDMMC_Disable(XMC_SDMMC_t *const sdmmc);
 578:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 579:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 580:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 581:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param config A pointer to a constant XMC_SDMMC_CONFIG_t structure containing the
 582:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *               bus width and clock divider configuration
 583:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return ::XMC_SDMMC_STATUS_SUCCESS
 584:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 585:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 586:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Initialize the SDMMC peripheral <br>
 587:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 588:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 589:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function enables the SDMMC peripheral, sets the internal clock divider register
 590:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * and sets the bus width.
 591:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 592:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** XMC_SDMMC_STATUS_t XMC_SDMMC_Init(XMC_SDMMC_t *const sdmmc, const XMC_SDMMC_CONFIG_t *config);
 593:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 594:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 595:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 596:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param event A valid SDMMC event (XMC_SDMMC_EVENT_t) or a valid combination of
 597:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *              logically OR'd events
 598:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 599:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 600:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 601:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Enable SDMMC normal and error event(s) <br>
 602:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 603:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 604:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function first sets the bit-fields of EN_INT_STATUS_NORM and EN_INT_STATUS_ERR
 605:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * registers to enable interrupt status for requested normal/error SDMMC events. It then
 606:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * sets the bit-fields of EN_INT_SIGNAL_NORM and EN_INT_SIGNAL_ERR to enable the
 607:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * interrupt generation for the requested events.
 608:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 609:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** void XMC_SDMMC_EnableEvent(XMC_SDMMC_t *const sdmmc, uint32_t event);
 610:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 611:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 612:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 613:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param event A valid SDMMC event (XMC_SDMMC_EVENT_t) or a valid combination of
 614:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *              logically OR'd events
 615:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 616:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 617:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 618:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Disable normal and error SDMMC event(s) <br>
 619:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 620:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 621:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function disables the interrupt generation for the requested events by clearing
 622:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * the bit-fields of EN_INT_SIGNAL_NORM and EN_INT_SIGNAL_ERR registers.
 623:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 624:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Note:</b><br>
 625:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The XMC_SDMMC_DisableEvent() function doesn't reset the the interrupt status. One
 626:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * may still use XMC_SDMMC_GetEvent() to check the status of requested events even if
 627:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * the interrupt generation is already disabled.
 628:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 629:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** void XMC_SDMMC_DisableEvent(XMC_SDMMC_t *const sdmmc, uint32_t event);
 630:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 631:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 632:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 633:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param event A valid SDMMC event (XMC_SDMMC_EVENT_t) or a valid combination of
 634:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *              logically OR'd events
 635:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 636:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 637:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 638:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Clear SDMMC event(s) <br>
 639:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 640:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 641:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function clears requested normal/error events by settings the bit-fields of
 642:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * the INT_STATUS register. Please check SDMMC_INT_STATUS_NORM in the XMC45000
 643:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * manual for more details.
 644:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 645:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** void XMC_SDMMC_ClearEvent(XMC_SDMMC_t *const sdmmc, uint32_t event);
 646:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 647:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 648:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 649:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param event A valid SDMMC event (XMC_SDMMC_EVENT_t)
 650:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return bool
 651:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 652:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 653:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Get SDMMC event status <br>
 654:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 655:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 656:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function returns the status of a single requested (normal/error) event by
 657:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * reading the appropriate bit-fields of the INT_STATUS register.
 658:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 659:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** bool XMC_SDMMC_GetEvent(XMC_SDMMC_t *const sdmmc, XMC_SDMMC_EVENT_t event);
 660:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 661:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 662:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 663:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param event A valid SDMMC event (XMC_SDMMC_EVENT_t) or a valid combination of
 664:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *              logically OR'd events
 665:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 666:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 667:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 668:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Enable event status <br>
 669:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 670:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 671:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function sets the bit-fields of EN_INT_STATUS_NORM and EN_INT_STATUS_ERR
 672:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * registers to enable interrupt status for requested normal/error SDMMC events.
 673:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 674:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** void XMC_SDMMC_EnableEventStatus(XMC_SDMMC_t *const sdmmc, uint32_t event);
 675:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 676:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 677:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 678:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param event A valid SDMMC event (XMC_SDMMC_EVENT_t) or a valid combination of
 679:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *              logically OR'd events
 680:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 681:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 682:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 683:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Disable event status <br>
 684:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 685:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 686:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function resets the bit-fields of EN_INT_STATUS_NORM and EN_INT_STATUS_ERR
 687:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * registers to disable interrupt status for requested normal/error SDMMC events.
 688:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 689:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** void XMC_SDMMC_DisableEventStatus(XMC_SDMMC_t *const sdmmc, uint32_t event);
 690:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 691:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 692:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 693:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param event A valid SDMMC event (::XMC_SDMMC_EVENT_t) or a valid combination of
 694:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *              logically OR'd events
 695:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 696:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 697:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 698:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Trigger SDMMC error events <br>
 699:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 700:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 701:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The SDMMC peripheral supports triggering of following error events: <br>
 702:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 703:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * ::XMC_SDMMC_CMD_TIMEOUT_ERR, ::XMC_SDMMC_CMD_CRC_ERR, ::XMC_SDMMC_CMD_END_BIT_ERR,
 704:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * ::XMC_SDMMC_CMD_IND_ERR, ::XMC_SDMMC_DATA_TIMEOUT_ERR, ::XMC_SDMMC_DATA_CRC_ERR,
 705:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * ::XMC_SDMMC_DATA_END_BIT_ERR, ::XMC_SDMMC_CURRENT_LIMIT_ERR, ::XMC_SDMMC_ACMD_ERR,
 706:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * ::XMC_SDMMC_TARGET_RESP_ERR
 707:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 708:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * For triggering Auto CMD12 error, see XMC_SDMMC_TriggerACMDErr()
 709:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 710:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_TriggerEvent(XMC_SDMMC_t *const sdmmc, uint32_t event)
 711:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 712:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_TriggerEvent: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 713:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   
 714:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->FORCE_EVENT_ERR_STATUS |= (uint16_t)(event >> 16U);
 715:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 716:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 717:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 718:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 719:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return bool
 720:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 721:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 722:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Check if any error event has occured <br>
 723:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 724:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 725:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function can typically be used for writing an error interrupt recovery routine.
 726:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Should any error be indicated (If XMC_SDMMC_IsAnyErrorEvent() returns true), the
 727:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * routine may then clear the event after indicating the error event and reset the
 728:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SDMMC command and data lines.
 729:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 730:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE bool XMC_SDMMC_IsAnyErrorEvent(XMC_SDMMC_t *const sdmmc)
 731:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 732:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_IsAnyErrorEvent: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc)
 733:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 734:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   return (bool)(sdmmc->INT_STATUS_ERR);
 735:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 736:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 737:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 738:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 739:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param event A valid SDMMC wakeup event (::XMC_SDMMC_WAKEUP_EVENT_t) or a valid combination
 740:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *              of logically OR'd wakeup events
 741:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 742:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 743:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 744:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Enable wakeup event(s) <br>
 745:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 746:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 747:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function enables SDMMC wakeup events by setting appropriate bit-fields of the WAKEUP_CTRL
 748:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * register. <br>
 749:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 750:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * List of supported wakeup events -> Wakeup on: <br>
 751:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 1) Card interrupt <br>
 752:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 2) SD card insertion <br>
 753:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 3) SD card removal <br>
 754:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 755:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_EnableWakeupEvent(XMC_SDMMC_t *const sdmmc, uint32_t event)
 756:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 757:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_EnableWakeupEvent: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmm
 758:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   
 759:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->WAKEUP_CTRL |= (uint8_t)event;
 760:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 761:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 762:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 763:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 764:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param event A valid SDMMC wakeup event (::XMC_SDMMC_WAKEUP_EVENT_t) or a valid combination
 765:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *              of logically OR'd wakeup events
 766:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 767:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 768:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 769:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Disable wakeup event(s) <br>
 770:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 771:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 772:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function disables SDMMC wakeup events by clearing appropriate bit-fields of the WAKEUP_CTRL
 773:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * register. <br>
 774:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 775:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * List of supported wakeup events -> Wakeup on: <br>
 776:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 1) Card interrupt <br>
 777:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 2) SD card insertion <br>
 778:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 3) SD card removal <br>
 779:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 780:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_DisableWakeupEvent(XMC_SDMMC_t *const sdmmc, uint32_t event)
 781:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 782:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_DisableWakeupEvent: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdm
 783:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   
 784:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->WAKEUP_CTRL &= (uint8_t)~event;
 785:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 786:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 787:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 788:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 789:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param error A valid SDMMC ACMD error (::XMC_SDMMC_ACMD_ERR_t)
 790:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return bool
 791:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 792:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 793:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Get status of Auto CMD12 errors <br>
 794:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 795:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 796:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function detects the presence of an Auto CMD12 error. A boolean is returned to
 797:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * indicate if an error is detected.
 798:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 799:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE bool XMC_SDMMC_GetACMDErrStatus(XMC_SDMMC_t *const sdmmc, XMC_SDMMC_ACMD_ERR_t erro
 800:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 801:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_GetACMDErrStatus: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc
 802:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_GetACMDErrStatus: Invalid ACMD response error", XMC_SDMMC_CHECK_ACMD_ERR(er
 803:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   
 804:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   return (bool)(sdmmc->ACMD_ERR_STATUS & (uint16_t)error);
 805:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 806:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 807:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 808:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 809:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param error A valid SDMMC ACMD error (::XMC_SDMMC_ACMD_ERR_t) or a valid combination
 810:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *              of logically OR'd ACMD error events
 811:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 812:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 813:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 814:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Triggers Auto CMD12 error(s) <br>
 815:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 816:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 817:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * This function triggers Auto CMD12 error(s) by setting appropriate bit-fields of the
 818:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * FORCE_EVENT_ACMD_ERR_STATUS register.
 819:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 820:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Related APIs: </b><br>
 821:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * XMC_SDMMC_TriggerEvent()
 822:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 823:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_TriggerACMDErr(XMC_SDMMC_t *const sdmmc, uint32_t error)
 824:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 825:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_TriggerACMDErr: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc))
 826:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   
 827:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->FORCE_EVENT_ACMD_ERR_STATUS |= (uint16_t)error;
 828:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 829:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 830:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 831:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 832:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return uint32_t The value held in the SDMMC FIFO
 833:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 834:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 835:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Use this function to read a single word (32 bits) from the SDMMC FIFO. <br>
 836:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 837:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE uint32_t XMC_SDMMC_ReadFIFO(XMC_SDMMC_t *const sdmmc)
 838:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 839:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_ReadFIFO: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 840:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 841:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   return (sdmmc->DATA_BUFFER);
 842:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 843:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 844:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 845:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 846:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param data Pointer to a data word (32 bits) that needs to be written to the FIFO
 847:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 848:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 849:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 850:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Use this function to write a single word (32 bits) to the SDMMC FIFO. <br>
 851:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 852:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_WriteFIFO(XMC_SDMMC_t *const sdmmc, uint32_t *data)
 853:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 854:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_WriteFIFO: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 855:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 856:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->DATA_BUFFER = *data;
 857:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 858:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 859:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 860:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 861:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 862:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 863:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 864:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Enable SDMMC bus power <br>
 865:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 866:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 867:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function sets the SD_BUS_POWER bit-field in the POWER_CTRL register, enabling the
 868:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * bus power. It may be invoked after enabling the SD clock (XMC_SDMMC_SDClockEnable()).
 869:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 870:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_BusPowerOn(XMC_SDMMC_t *const sdmmc)
 871:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 872:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_BusPowerOn: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 873:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 874:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->POWER_CTRL |= (uint8_t)(SDMMC_POWER_CTRL_SD_BUS_POWER_Msk);
 875:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 876:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 877:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 878:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 879:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 880:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 881:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 882:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Disable SDMMC bus power <br>
 883:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 884:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 885:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function resets the SD_BUS_POWER bit-field in the POWER_CTRL register, disabling the
 886:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * bus power.
 887:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 888:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_BusPowerOff(XMC_SDMMC_t *const sdmmc)
 889:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 890:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_BusPowerOff: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 891:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 892:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->POWER_CTRL &= (uint8_t)~SDMMC_POWER_CTRL_SD_BUS_POWER_Msk;
 893:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 894:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 895:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 896:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 897:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 898:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 899:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 900:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Enable the internal SDMMC clock <br>
 901:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 902:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 903:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function enables the internal clock of the SDMMC peripheral. To check if the
 904:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * clock is stable, use XMC_SDMMC_GetClockStability().
 905:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 906:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Note: </b><br>
 907:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Invoke XMC_SDMMC_Init() before using this function.
 908:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 909:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_Start(XMC_SDMMC_t *const sdmmc)
 910:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 911:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_Start: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 912:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   
 913:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   /* Enable internal clock */
 914:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->CLOCK_CTRL |= (uint16_t)SDMMC_CLOCK_CTRL_INTERNAL_CLOCK_EN_Msk;
 915:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 916:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 917:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 918:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 919:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return bool
 920:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 921:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 922:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Check internal clock stability <br>
 923:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 924:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 925:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Use this function to check the internal SDMMC clock stability. The function returns a
 926:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * boolean value indicating internal clock stability (true = stable)
 927:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 928:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE bool XMC_SDMMC_GetClockStability(XMC_SDMMC_t *const sdmmc)
 929:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 930:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_GetClockStability: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmm
 931:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   
 932:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   /* Return clock stability */
 933:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   return (bool)(sdmmc->CLOCK_CTRL & SDMMC_CLOCK_CTRL_INTERNAL_CLOCK_STABLE_Msk);
 934:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 935:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 936:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 937:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 938:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 939:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 940:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 941:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Disable internal SDMMC clock <br>
 942:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 943:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 944:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function disables the internal clock of the SDMMC peripheral. The SDMMC registers
 945:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * can still be read and written even if the internal clock is disabled.
 946:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 947:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_Stop(XMC_SDMMC_t *const sdmmc)
 948:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 949:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_Stop: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 950:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 951:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->CLOCK_CTRL &= (uint16_t)~SDMMC_CLOCK_CTRL_INTERNAL_CLOCK_EN_Msk;
 952:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 953:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 954:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 955:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 956:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 957:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 958:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 959:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Enable the SD clock <br>
 960:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 961:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 962:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function sets the SDCLOCK_EN bit-field of the CLOCK_CTRL register, enabling the
 963:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SD clock. It can be invoked after the internal clock has achieved stability. SD card
 964:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * initialization process may then follow.
 965:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 966:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_SDClockEnable(XMC_SDMMC_t *const sdmmc)
 967:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 968:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_SDClockEnable: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 969:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 970:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->CLOCK_CTRL |= (uint16_t)SDMMC_CLOCK_CTRL_SDCLOCK_EN_Msk;
 971:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 972:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 973:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 974:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 975:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 976:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 977:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 978:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Disable the SD clock <br>
 979:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 980:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
 981:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function resets the SDCLOCK_EN bit-field of the CLOCK_CTRL register, disabling the
 982:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SD clock. It can be used alongside a SD card information reset routine (if required).
 983:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
 984:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_SDClockDisable(XMC_SDMMC_t *const sdmmc)
 985:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
 986:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_SDClockDisable: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc))
 987:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 988:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->CLOCK_CTRL &= (uint16_t)~SDMMC_CLOCK_CTRL_SDCLOCK_EN_Msk;
 989:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
 990:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
 991:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
 992:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
 993:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param reset_mode Reset mode or a bitwise combination of modes
 994:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
 995:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 996:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
 997:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Set SDMMC software reset request <br>
 998:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
 999:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1000:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function sets in the SDMMC SW_RESET register: <br>
1001:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 1) bit 0 to reset all <br>
1002:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 2) bit 1 to reset CMD line <br>
1003:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 3) bit 2 reset DAT line <br>
1004:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1005:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * It is typically used to reset the SD HOST controller's registers.
1006:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1007:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_SetSWReset(XMC_SDMMC_t *const sdmmc, uint32_t reset_mode)
1008:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1009:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_SetSWReset: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
1010:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1011:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->SW_RESET |= (uint8_t)reset_mode;
1012:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1013:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1014:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1015:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1016:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return Software reset status
1017:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1018:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1019:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Get SDMMC software reset status <br>
1020:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1021:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1022:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The SD host takes some time to reset its registers after invoking XMC_SDMMC_SetSWReset().
1023:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Since XMC_SDMMC_SetSWReset() is a non-blocking function, XMC_SDMMC_GetSWResetStatus() has
1024:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * been provided to check the software reset status. The return value needs to be masked
1025:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * with the reset mode (XMC_SDMMC_SW_RESET_t) to get a specific software reset status value.
1026:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1027:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE uint32_t XMC_SDMMC_GetSWResetStatus(XMC_SDMMC_t *const sdmmc)
1028:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1029:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_GetSWResetStatus: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc
1030:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   
1031:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   return (uint32_t)(sdmmc->SW_RESET);
1032:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1033:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1034:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1035:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1036:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return XMC_SDMMC_PRESENT_STATE_t A structure storing the present state of the host controller
1037:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1038:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1039:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Get the present state of the SDMMC host controller <br>
1040:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1041:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1042:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Get the values of each bit-field in SDMMC_PRESENT_STATE register
1043:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function call populates an instance of the XMC_SDMMC_PRESENT_STATE_t structure with
1044:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * the state of the SD host controller and returns it to the caller.
1045:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1046:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE XMC_SDMMC_PRESENT_STATE_t XMC_SDMMC_GetPresentState(const XMC_SDMMC_t *const sdmmc)
1047:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1048:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_SDMMC_PRESENT_STATE_t result;
1049:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1050:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_GetPresentState: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc)
1051:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1052:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   result.b32 = (uint32_t)sdmmc->PRESENT_STATE;
1053:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1054:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   return result;
1055:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1056:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1057:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1058:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1059:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return bool SDMMC command line status
1060:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1061:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1062:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Check if the command line is busy <br>
1063:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1064:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1065:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function reads the SDMMC PRESENT_STATE register and returns "true" if the command
1066:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * line is busy ("false" otherwise). The command line must be free before sending an SDMMC
1067:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * command with XMC_SDMMC_SendCommand().
1068:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1069:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE bool XMC_SDMMC_IsCommandLineBusy(XMC_SDMMC_t *const sdmmc)
1070:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1071:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_IsCommandLineBusy: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmm
1072:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1073:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   return (bool)(sdmmc->PRESENT_STATE & SDMMC_PRESENT_STATE_COMMAND_INHIBIT_CMD_Msk);
1074:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1075:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1076:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1077:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1078:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return bool SDMMC data line status
1079:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1080:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1081:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Check if the data line is busy <br>
1082:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1083:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1084:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function reads the SDMMC PRESENT_STATE register and returns "true" if the data
1085:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * line is busy ("false" otherwise). The data line must be free before sending an SDMMC
1086:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * command with XMC_SDMMC_SendCommand().
1087:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1088:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE bool XMC_SDMMC_IsDataLineBusy(XMC_SDMMC_t *const sdmmc)
1089:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1090:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_IsDataLineBusy: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc))
1091:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1092:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   return (bool)(sdmmc->PRESENT_STATE & SDMMC_PRESENT_STATE_COMMAND_INHIBIT_DAT_Msk);
1093:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1094:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1095:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1096:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1097:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return bool Status of all data lines
1098:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1099:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1100:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Check if all data line are high <br>
1101:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1102:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1103:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function reads the SDMMC PRESENT_STATE register and returns "true" if all data
1104:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * lines are high. It can be used to handle SDMMC error conditions. For example, if an
1105:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * error event (XMC_SDMMC_IsAnyErrorEvent()) is detected and all data lines are high,
1106:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * the user code can conclude that the error is of a "recoverable" type.
1107:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1108:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE bool XMC_SDMMC_IsAllDataLinesHigh(XMC_SDMMC_t *const sdmmc)
1109:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1110:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_IsAllDataLinesHigh: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdm
1111:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1112:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   return ((((sdmmc->PRESENT_STATE & SDMMC_PRESENT_STATE_DAT_3_0_PIN_LEVEL_Msk) >>
1113:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 		    SDMMC_PRESENT_STATE_DAT_3_0_PIN_LEVEL_Pos) == 0x0FU) ? true : false);
1114:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1115:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1116:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1117:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1118:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param command A pointer to a constant of type XMC_SDMMC_COMMAND_t, pointing to the command conf
1119:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param arg Command argument
1120:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return ::XMC_SDMMC_STATUS_SUCCESS
1121:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1122:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1123:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Send normal SDMMC command <br>
1124:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1125:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1126:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Use this function to send a normal SDMMC command. This non-blocking function sets the
1127:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * ARGUMENT1 and COMMAND registers. It is the user's responsibility to check if the command
1128:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * and data lines are busy (XMC_SDMMC_IsDataLineBusy(), XMC_SDMMC_IsCommandLineBusy()).
1129:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1130:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** XMC_SDMMC_STATUS_t XMC_SDMMC_SendCommand(XMC_SDMMC_t *const sdmmc, const XMC_SDMMC_COMMAND_t *comma
1131:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1132:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1133:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1134:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return uint32_t SDMMC command response
1135:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1136:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1137:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Get card response (no Auto command) <br>
1138:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1139:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1140:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * This function returns [39:8] bits of the card response. The others are checked automatically
1141:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * by the peripheral. This function can be used with response type R1, R1b, R3, R4, R5, R5b, R6
1142:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * but it doesn't support the retrieving of R1 of Auto CMD 23 and R1b of Auto CMD 12. To get
1143:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * these responses, use XMC_SDMMC_GetAutoCommandResponse().
1144:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1145:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE uint32_t XMC_SDMMC_GetCommandResponse(XMC_SDMMC_t *const sdmmc)
1146:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1147:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_GetCommandResponse: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdm
1148:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   
1149:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   return (sdmmc->RESPONSE[0]);
1150:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1151:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1152:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1153:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1154:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return uint32_t Auto command response value
1155:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1156:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1157:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Get card response of Auto commands <br>
1158:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1159:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1160:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * This function returns card response [39:8] bits of auto commands: R1 of Auto CMD 23 and
1161:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * R1b of Auto CMD 12.
1162:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1163:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE uint32_t XMC_SDMMC_GetAutoCommandResponse(const XMC_SDMMC_t *const sdmmc)
1164:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1165:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_GetAutoCommandResponse: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR
1166:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1167:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   return (sdmmc->RESPONSE[3]);
1168:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1169:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1170:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1171:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1172:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param response Pointer to structure type XMC_SDMMC_RESPONSE_t to store the full response
1173:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
1174:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1175:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1176:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Get card R2 response <br>
1177:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1178:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1179:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The R2 response is 120 bits wide. The function reads all peripheral registers and store in
1180:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * the response data structure.
1181:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1182:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** void XMC_SDMMC_GetR2Response(XMC_SDMMC_t *const sdmmc, XMC_SDMMC_RESPONSE_t *const response);
1183:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1184:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1185:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1186:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param transfer_mode Transfer mode configuration
1187:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
1188:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1189:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1190:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Configure data transfer mode <br>
1191:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1192:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1193:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function configures block size, block count, type of data transfer, response type
1194:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * and sets the auto command configuration. Use this function to configure a multi-block
1195:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * SDMMC transfer.
1196:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1197:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** void XMC_SDMMC_SetDataTransferMode(XMC_SDMMC_t *const sdmmc, XMC_SDMMC_TRANSFER_MODE_t *const trans
1198:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1199:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1200:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1201:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return uint32_t Number of blocks that need to be transferred
1202:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1203:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1204:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Get the number of blocks that need to be transferred <br>
1205:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1206:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1207:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * This function is valid only for multiple block transfers. The host controller
1208:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * decrements the block count after each block transfer and stops when the count reaches
1209:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * zero. It can only be accessed when no transaction is happening (i.e after a transaction
1210:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * has stopped). This function returns an invalid value during the transfer. <br>
1211:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1212:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * When saving transfer context as a result of the suspend command, the number of blocks
1213:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * yet to be transferred can be determined by using this function.
1214:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1215:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE uint32_t XMC_SDMMC_GetTransferBlocksNum(XMC_SDMMC_t *const sdmmc)
1216:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1217:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_GetTransferBlocksNum: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(s
1218:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1219:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   return (uint32_t)(sdmmc->BLOCK_COUNT);
1220:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1221:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1222:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1223:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1224:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param enabled "true" to enable read wait control, "false" to disable read wait control.
1225:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
1226:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1227:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1228:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Configure read wait control <br>
1229:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1230:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1231:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The read wait function is optional for SDIO cards. If the card supports read wait and
1232:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * XMC_SDMMC_GetTransferBlocksNum() is executed, the SDMMC peripheral will stop read data
1233:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * using DAT[2] line. If this feature is not enabled the peripheral has to stop the SD
1234:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * clock to hold read data, restricting commands generation. <br>
1235:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1236:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * When the host driver detects an SD card insertion, it sets this bit according to the
1237:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * CCCR of the SDIO card. If the card does not support read wait, this feature shall
1238:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * never be enabled otherwise a DAT line conflict may occur. If this feature is disabled,
1239:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Suspend/Resume cannot be supported.
1240:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1241:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_SetReadWaitControl(XMC_SDMMC_t *const sdmmc, bool enabled)
1242:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1243:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_SetReadWaitControl: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdm
1244:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1245:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->BLOCK_GAP_CTRL = (uint8_t)((sdmmc->BLOCK_GAP_CTRL & (uint8_t)~SDMMC_BLOCK_GAP_CTRL_READ_WA
1246:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****                                     (uint8_t)((uint8_t)enabled << SDMMC_BLOCK_GAP_CTRL_READ_WAIT_CT
1247:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1248:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1249:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1250:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1251:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param enabled "true" to set stop at block gap, "false" for transfer
1252:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
1253:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1254:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1255:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Stop at block gap request <br>
1256:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1257:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1258:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function is used to terminate a transaction execution at the next block gap for
1259:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * non-DMA transfers.
1260:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1261:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_SetStopAtBlockGap(XMC_SDMMC_t *const sdmmc, bool enabled)
1262:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1263:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_SetStopAtBlockGap: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmm
1264:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1265:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->BLOCK_GAP_CTRL = (uint8_t)((sdmmc->BLOCK_GAP_CTRL & (uint8_t)~SDMMC_BLOCK_GAP_CTRL_STOP_AT
1266:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****                                     (uint8_t)((uint8_t)enabled << SDMMC_BLOCK_GAP_CTRL_STOP_AT_BLOC
1267:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1268:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1269:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1270:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1271:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param enabled "true" to restart transaction, "false" is ignored
1272:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
1273:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1274:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1275:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Issue a continue request <br>
1276:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1277:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1278:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function is used to restart a transaction which was stopped using the "Stop at
1279:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * block gap" request. (XMC_SDMMC_SetStopAtBlockGap())
1280:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1281:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_SetContinueRequest(XMC_SDMMC_t *const sdmmc, bool enabled)
1282:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1283:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_SetContinueRequest: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdm
1284:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1285:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->BLOCK_GAP_CTRL = ((sdmmc->BLOCK_GAP_CTRL & (uint8_t)~SDMMC_BLOCK_GAP_CTRL_CONTINUE_REQ_Msk
1286:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****                            (uint8_t)((uint8_t)enabled << SDMMC_BLOCK_GAP_CTRL_CONTINUE_REQ_Pos));
1287:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1288:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1289:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1290:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1291:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return bool
1292:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1293:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1294:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Get continue request <br>
1295:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1296:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1297:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function returns the status of the BLOCK_GAP_CTRL.CONTINUE_REQ bit-field. It
1298:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * returns "true" if the transaction is restarted after a "stop at block gap" request.
1299:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1300:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE bool XMC_SDMMC_GetContinueRequest(XMC_SDMMC_t *const sdmmc)
1301:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1302:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_GetContinueRequest: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdm
1303:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1304:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   return (bool)(sdmmc->BLOCK_GAP_CTRL & (uint8_t)(1U << SDMMC_BLOCK_GAP_CTRL_CONTINUE_REQ_Pos));
1305:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1306:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1307:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1308:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1309:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param config A pointer to the SDMMC configuration structure (::XMC_SDMMC_CONFIG_t)
1310:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
1311:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1312:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1313:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Enable interrupt at block gap <br>
1314:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1315:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1316:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function sets the BLOCK_GAP_CTRL.INT_AT_BLOCK_GAP bit-field to enable interrupt
1317:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * at block gap for a multi-block transfer. This bit is only valid in a 4-bit mode of
1318:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * the SDIO card.
1319:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1320:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_EnableInterruptAtBlockGap(XMC_SDMMC_t *const sdmmc, const XMC_SDMMC_
1321:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1322:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_EnableInterruptAtBlockGap: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_
1323:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_EnableInterruptAtBlockGap: This operation is only valid in 4-bit mode",
1324:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****              (config->bus_width == XMC_SDMMC_DATA_LINES_1));
1325:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1326:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->BLOCK_GAP_CTRL |= (uint8_t)SDMMC_BLOCK_GAP_CTRL_INT_AT_BLOCK_GAP_Msk;
1327:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1328:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1329:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1330:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1331:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param config A pointer to the SDMMC configuration structure (::XMC_SDMMC_CONFIG_t)
1332:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
1333:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1334:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1335:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Disable interrupt at block gap <br>
1336:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1337:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1338:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function resets the BLOCK_GAP_CTRL.INT_AT_BLOCK_GAP bit-field to disable interrupt
1339:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * at block gap. This bit is only valid in a 4-bit mode of the SDIO card.
1340:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1341:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_DisableInterruptAtBlockGap(XMC_SDMMC_t *const sdmmc,
1342:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****                                                           const XMC_SDMMC_CONFIG_t *config)
1343:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1344:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1345:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_EnableInterruptAtBlockGap: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_
1346:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_EnableInterruptAtBlockGap: This operation is only valid in 4-bit mode",
1347:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****              (config->bus_width == XMC_SDMMC_DATA_LINES_1));
1348:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1349:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->BLOCK_GAP_CTRL &= (uint8_t)~SDMMC_BLOCK_GAP_CTRL_INT_AT_BLOCK_GAP_Msk;
1350:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1351:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1352:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1353:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1354:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param clk Desired clock frequency (::XMC_SDMMC_SDCLK_FREQ_SEL_t)
1355:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
1356:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1357:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1358:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Set SD clock frequency <br>
1359:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1360:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1361:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function sets the CLOCK_CTRL register to configure the frequency of the SD clock
1362:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * pin. The register is programmed with the divisor of the base clock frequency (clk).
1363:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1364:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The following settings are permitted (8-bit divided clock mode): <br>
1365:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 00H: base clock (10MHz->63MHz) <br>
1366:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 01H: base clock divided by 2   <br>
1367:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 10H: base clock divided by 32  <br>
1368:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 02H: base clock divided by 4   <br>
1369:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 04H: base clock divided by 8   <br>
1370:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 08H: base clock divided by 16  <br>
1371:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 20H: base clock divided by 64  <br>
1372:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 40H: base clock divided by 128 <br>
1373:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 80H: base clock divided by 256 <br>
1374:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1375:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Note: </b><br>
1376:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The internal clock should be disabled before updating frequency clock select. Please
1377:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * see section 2.2.14 -> "Clock Control Register" in the SD HOST specification for more
1378:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * information.
1379:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1380:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_SDClockFreqSelect(XMC_SDMMC_t *const sdmmc, XMC_SDMMC_SDCLK_FREQ_SEL
1381:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1382:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_SDClockFreqSelect: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmm
1383:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_SDClockFreqSelect: Invalid clock frequency selection", XMC_SDMMC_CHECK_SDCL
1384:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1385:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->CLOCK_CTRL |= (uint16_t)((uint32_t)SDMMC_CLOCK_CTRL_SDCLK_FREQ_SEL_Msk &
1386:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****                                   (uint32_t)((uint32_t)clk << SDMMC_CLOCK_CTRL_SDCLK_FREQ_SEL_Pos))
1387:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1388:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1389:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1390:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1391:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param bus_voltage Desired bus voltage (::XMC_SDMMC_BUS_VOLTAGE_t)
1392:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
1393:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1394:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1395:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Set SDMMC bus voltage <br>
1396:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1397:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1398:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * The function sets the CLOCK_CTRL register to configure the bus voltage. Currently,
1399:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * 3.3 volts is the supported voltage level. This function is relevant within the host
1400:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * controller initialization routine.
1401:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1402:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_SetBusVoltage(XMC_SDMMC_t *const sdmmc, XMC_SDMMC_BUS_VOLTAGE_t bus_
1403:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
1404:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_SetBusVoltage: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
1405:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_SetBusVoltage: Invalid bus voltage", XMC_SDMMC_CHECK_BUS_VOLTAGE(bus_voltag
1406:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1407:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->POWER_CTRL |= (uint8_t)((uint32_t)bus_voltage << SDMMC_POWER_CTRL_SD_BUS_VOLTAGE_SEL_Pos);
1408:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
1409:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1410:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** /**
1411:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param sdmmc A constant pointer to XMC_SDMMC_t, pointing to the SDMMC base address
1412:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @param timeout Data line timeout value
1413:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * @return None
1414:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1415:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par<b>Description: </b><br>
1416:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Set data line timeout <br>
1417:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  *
1418:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * \par
1419:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * Use the function to set the interval by which the data line timeouts are detected. The
1420:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * timeout clock frequency is generated by dividing the SD clock (TMCLK) by the timeout argument.
1421:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  * This function must be called before setting the bus voltage (XMC_SDMMC_SetBusVoltage()).
1422:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****  */
1423:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** __STATIC_INLINE void XMC_SDMMC_SetDataLineTimeout(XMC_SDMMC_t *const sdmmc, XMC_SDMMC_DAT_TIMEOUT_C
1424:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** {
  27              	 .loc 1 1424 0
  28              	 .cfi_startproc
  29              	 
  30              	 
  31              	 
  32 0000 80B4     	 push {r7}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 4
  35              	 .cfi_offset 7,-4
  36 0002 83B0     	 sub sp,sp,#12
  37              	.LCFI1:
  38              	 .cfi_def_cfa_offset 16
  39 0004 00AF     	 add r7,sp,#0
  40              	.LCFI2:
  41              	 .cfi_def_cfa_register 7
  42 0006 7860     	 str r0,[r7,#4]
  43 0008 0B46     	 mov r3,r1
  44 000a FB70     	 strb r3,[r7,#3]
1425:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_SetDataLineTimeout: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdm
1426:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   XMC_ASSERT("XMC_SDMMC_SetDataLineTimeout: Invalid timeout", XMC_SDMMC_CHECK_DAT_TIMEOUT_COUNTER(t
1427:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** 
1428:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****   sdmmc->TIMEOUT_CTRL |= (uint8_t)(((uint32_t)timeout << SDMMC_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL_Pos
  45              	 .loc 1 1428 0
  46 000c 7B68     	 ldr r3,[r7,#4]
  47 000e 93F82E30 	 ldrb r3,[r3,#46]
  48 0012 DBB2     	 uxtb r3,r3
  49 0014 DAB2     	 uxtb r2,r3
  50 0016 FB78     	 ldrb r3,[r7,#3]
  51 0018 03F00F03 	 and r3,r3,#15
  52 001c DBB2     	 uxtb r3,r3
  53 001e 1343     	 orrs r3,r3,r2
  54 0020 DBB2     	 uxtb r3,r3
  55 0022 DAB2     	 uxtb r2,r3
  56 0024 7B68     	 ldr r3,[r7,#4]
  57 0026 83F82E20 	 strb r2,[r3,#46]
1429:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h ****                                    (uint32_t)SDMMC_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL_Msk);
1430:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_sdmmc.h **** }
  58              	 .loc 1 1430 0
  59 002a 0C37     	 adds r7,r7,#12
  60              	.LCFI3:
  61              	 .cfi_def_cfa_offset 4
  62 002c BD46     	 mov sp,r7
  63              	.LCFI4:
  64              	 .cfi_def_cfa_register 13
  65              	 
  66 002e 5DF8047B 	 ldr r7,[sp],#4
  67              	.LCFI5:
  68              	 .cfi_restore 7
  69              	 .cfi_def_cfa_offset 0
  70 0032 7047     	 bx lr
  71              	 .cfi_endproc
  72              	.LFE160:
  74              	 .section .text.XMC_SDMMC_GetPowerStatus,"ax",%progbits
  75              	 .align 2
  76              	 .global XMC_SDMMC_GetPowerStatus
  77              	 .thumb
  78              	 .thumb_func
  80              	XMC_SDMMC_GetPowerStatus:
  81              	.LFB193:
  82              	 .file 2 "../Libraries/XMCLib/src/xmc_sdmmc.c"
   1:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
   2:../Libraries/XMCLib/src/xmc_sdmmc.c **** /**
   3:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * @file xmc_sdmmc.c
   4:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * @date 2016-01-12
   5:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *
   6:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * @cond
   7:../Libraries/XMCLib/src/xmc_sdmmc.c ****  **************************************************************************************************
   8:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * XMClib v2.1.6 - XMC Peripheral Driver Library 
   9:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *
  10:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  11:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * All rights reserved.                        
  12:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *                                             
  13:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  14:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * following conditions are met:   
  15:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *                                                                              
  16:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  17:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * disclaimer.                        
  18:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * 
  19:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  20:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  21:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * 
  22:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  23:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * products derived from this software without specific prior written permission.                  
  24:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *                                                                              
  25:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  26:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  27:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  28:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  29:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  30:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  31:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  32:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *                                                                              
  33:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  34:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * Infineon Technologies AG dave@infineon.com).                                                    
  35:../Libraries/XMCLib/src/xmc_sdmmc.c ****  **************************************************************************************************
  36:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *
  37:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * Change History
  38:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * --------------
  39:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *
  40:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * 2015-02-20:
  41:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *     - Initial <br>
  42:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *     - Removed GetDriverVersion API <br>
  43:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *
  44:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * 2015-06-20:
  45:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *     - Removed definition of GetDriverVersion API <br>
  46:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *
  47:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * @endcond
  48:../Libraries/XMCLib/src/xmc_sdmmc.c ****  */
  49:../Libraries/XMCLib/src/xmc_sdmmc.c ****  
  50:../Libraries/XMCLib/src/xmc_sdmmc.c **** /**
  51:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * @addtogroup XMClib
  52:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * @{
  53:../Libraries/XMCLib/src/xmc_sdmmc.c ****  */
  54:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
  55:../Libraries/XMCLib/src/xmc_sdmmc.c **** /**
  56:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * @addtogroup SDMMC
  57:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * @brief SDMMC driver
  58:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * @{
  59:../Libraries/XMCLib/src/xmc_sdmmc.c ****  */
  60:../Libraries/XMCLib/src/xmc_sdmmc.c ****  
  61:../Libraries/XMCLib/src/xmc_sdmmc.c **** /*******************************************************************************
  62:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * HEADER FILES
  63:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *******************************************************************************/
  64:../Libraries/XMCLib/src/xmc_sdmmc.c ****  
  65:../Libraries/XMCLib/src/xmc_sdmmc.c **** #include "xmc_sdmmc.h"
  66:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
  67:../Libraries/XMCLib/src/xmc_sdmmc.c **** /*
  68:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * The SDMMC peripheral is only available on the
  69:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * XMC4500. The SDMMC definition can be found in
  70:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * the XMC4500.h (device header file).
  71:../Libraries/XMCLib/src/xmc_sdmmc.c ****  */
  72:../Libraries/XMCLib/src/xmc_sdmmc.c **** #if defined (SDMMC)
  73:../Libraries/XMCLib/src/xmc_sdmmc.c **** #include "xmc_scu.h"
  74:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
  75:../Libraries/XMCLib/src/xmc_sdmmc.c **** /*******************************************************************************
  76:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * MACROS
  77:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *******************************************************************************/
  78:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
  79:../Libraries/XMCLib/src/xmc_sdmmc.c **** /*
  80:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * Check for valid SDMMC error events <br>
  81:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *
  82:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * This macro is used in the LLD for assertion checks (XMC_ASSERT).
  83:../Libraries/XMCLib/src/xmc_sdmmc.c ****  */
  84:../Libraries/XMCLib/src/xmc_sdmmc.c **** #define XMC_SDMMC_CHECK_ERROR_EVENT(e)\
  85:../Libraries/XMCLib/src/xmc_sdmmc.c ****   ((e == XMC_SDMMC_CMD_TIMEOUT_ERR)     ||\
  86:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_CMD_CRC_ERR)         ||\
  87:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_CMD_END_BIT_ERR)     ||\
  88:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_CMD_IND_ERR)         ||\
  89:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_DATA_TIMEOUT_ERR)    ||\
  90:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_DATA_CRC_ERR)        ||\
  91:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_DATA_END_BIT_ERR)    ||\
  92:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_CURRENT_LIMIT_ERR)   ||\
  93:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_ACMD_ERR)            ||\
  94:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_TARGET_RESP_ERR))
  95:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
  96:../Libraries/XMCLib/src/xmc_sdmmc.c **** /*
  97:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * Check for valid SDMMC normal events <br>
  98:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *
  99:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * This macro is used in the LLD for assertion checks (XMC_ASSERT).
 100:../Libraries/XMCLib/src/xmc_sdmmc.c ****  */
 101:../Libraries/XMCLib/src/xmc_sdmmc.c **** #define XMC_SDMMC_CHECK_NORMAL_EVENT(e)\
 102:../Libraries/XMCLib/src/xmc_sdmmc.c ****   ((e == XMC_SDMMC_CMD_COMPLETE)        ||\
 103:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_TX_COMPLETE)         ||\
 104:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_BLOCK_GAP_EVENT)     ||\
 105:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_BUFFER_WRITE_READY)  ||\
 106:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_BUFFER_READ_READY)   ||\
 107:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_CARD_INS)            ||\
 108:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_CARD_REMOVAL)        ||\
 109:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (e == XMC_SDMMC_CARD_INT))
 110:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 111:../Libraries/XMCLib/src/xmc_sdmmc.c **** /*
 112:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * Check for both normal and error events <br>
 113:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *
 114:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * This macro is used in the LLD for assertion checks (XMC_ASSERT).
 115:../Libraries/XMCLib/src/xmc_sdmmc.c ****  */
 116:../Libraries/XMCLib/src/xmc_sdmmc.c **** #define XMC_SDMMC_CHECK_EVENT(e)\
 117:../Libraries/XMCLib/src/xmc_sdmmc.c ****   ((XMC_SDMMC_CHECK_NORMAL_EVENT(e))    ||\
 118:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (XMC_SDMMC_CHECK_ERROR_EVENT(e)))
 119:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 120:../Libraries/XMCLib/src/xmc_sdmmc.c **** /*
 121:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * Check for valid SDMMC wakeup events <br>
 122:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *
 123:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * This macro is used in the LLD for assertion checks (XMC_ASSERT).
 124:../Libraries/XMCLib/src/xmc_sdmmc.c ****  */
 125:../Libraries/XMCLib/src/xmc_sdmmc.c **** #define XMC_SDMMC_CHECK_WAKEUP_EVENT(w)\
 126:../Libraries/XMCLib/src/xmc_sdmmc.c ****   ((w == XMC_SDMMC_WAKEUP_EN_CARD_INT)  ||\
 127:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (w == XMC_SDMMC_WAKEUP_EN_CARD_INS)  ||\
 128:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (w == XMC_SDMMC_WAKEUP_EN_CARD_REM))
 129:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 130:../Libraries/XMCLib/src/xmc_sdmmc.c **** /*
 131:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * Check for valid SDMMC software reset modes <br>
 132:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *
 133:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * This macro is used in the LLD for assertion checks (XMC_ASSERT).
 134:../Libraries/XMCLib/src/xmc_sdmmc.c ****  */
 135:../Libraries/XMCLib/src/xmc_sdmmc.c **** #define XMC_SDMMC_CHECK_SW_RESET_MODE(m)\
 136:../Libraries/XMCLib/src/xmc_sdmmc.c ****   ((m == XMC_SDMMC_SW_RESET_ALL)        ||\
 137:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (m == XMC_SDMMC_SW_RST_CMD_LINE)     ||\
 138:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (m == XMC_SDMMC_SW_RST_DAT_LINE))
 139:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 140:../Libraries/XMCLib/src/xmc_sdmmc.c **** /*
 141:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * Check for valid SDMMC transfer modes <br>
 142:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *
 143:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * This macro is used in the LLD for assertion checks (XMC_ASSERT).
 144:../Libraries/XMCLib/src/xmc_sdmmc.c ****  */
 145:../Libraries/XMCLib/src/xmc_sdmmc.c **** #define XMC_SDMMC_CHECK_TRANSFER_MODE(m)\
 146:../Libraries/XMCLib/src/xmc_sdmmc.c ****   ((m == XMC_SDMMC_TRANSFER_MODE_TYPE_SINGLE)    ||\
 147:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (m == XMC_SDMMC_TRANSFER_MODE_TYPE_INFINITE)  ||\
 148:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (m == XMC_SDMMC_TRANSFER_MODE_TYPE_MULTIPLE)  ||\
 149:../Libraries/XMCLib/src/xmc_sdmmc.c ****    (m == XMC_SDMMC_TRANSFER_MODE_TYPE_STOP_MULTIPLE))
 150:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 151:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 152:../Libraries/XMCLib/src/xmc_sdmmc.c **** /*******************************************************************************
 153:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * API IMPLEMENTATION
 154:../Libraries/XMCLib/src/xmc_sdmmc.c ****  *******************************************************************************/
 155:../Libraries/XMCLib/src/xmc_sdmmc.c ****  
 156:../Libraries/XMCLib/src/xmc_sdmmc.c **** /* Get power status of the SDMMC peripheral */
 157:../Libraries/XMCLib/src/xmc_sdmmc.c **** bool XMC_SDMMC_GetPowerStatus(XMC_SDMMC_t *const sdmmc)
 158:../Libraries/XMCLib/src/xmc_sdmmc.c **** {
  83              	 .loc 2 158 0
  84              	 .cfi_startproc
  85              	 
  86              	 
  87              	 
  88 0000 80B4     	 push {r7}
  89              	.LCFI6:
  90              	 .cfi_def_cfa_offset 4
  91              	 .cfi_offset 7,-4
  92 0002 83B0     	 sub sp,sp,#12
  93              	.LCFI7:
  94              	 .cfi_def_cfa_offset 16
  95 0004 00AF     	 add r7,sp,#0
  96              	.LCFI8:
  97              	 .cfi_def_cfa_register 7
  98 0006 7860     	 str r0,[r7,#4]
 159:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_GetPowerStatus: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc))
 160:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 161:../Libraries/XMCLib/src/xmc_sdmmc.c ****   return (bool)(sdmmc->POWER_CTRL & SDMMC_POWER_CTRL_SD_BUS_POWER_Msk);
  99              	 .loc 2 161 0
 100 0008 7B68     	 ldr r3,[r7,#4]
 101 000a 93F82930 	 ldrb r3,[r3,#41]
 102 000e DBB2     	 uxtb r3,r3
 103 0010 03F00103 	 and r3,r3,#1
 104 0014 002B     	 cmp r3,#0
 105 0016 14BF     	 ite ne
 106 0018 0123     	 movne r3,#1
 107 001a 0023     	 moveq r3,#0
 108 001c DBB2     	 uxtb r3,r3
 162:../Libraries/XMCLib/src/xmc_sdmmc.c **** }
 109              	 .loc 2 162 0
 110 001e 1846     	 mov r0,r3
 111 0020 0C37     	 adds r7,r7,#12
 112              	.LCFI9:
 113              	 .cfi_def_cfa_offset 4
 114 0022 BD46     	 mov sp,r7
 115              	.LCFI10:
 116              	 .cfi_def_cfa_register 13
 117              	 
 118 0024 5DF8047B 	 ldr r7,[sp],#4
 119              	.LCFI11:
 120              	 .cfi_restore 7
 121              	 .cfi_def_cfa_offset 0
 122 0028 7047     	 bx lr
 123              	 .cfi_endproc
 124              	.LFE193:
 126 002a 00BF     	 .section .text.XMC_SDMMC_Enable,"ax",%progbits
 127              	 .align 2
 128              	 .global XMC_SDMMC_Enable
 129              	 .thumb
 130              	 .thumb_func
 132              	XMC_SDMMC_Enable:
 133              	.LFB194:
 163:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 164:../Libraries/XMCLib/src/xmc_sdmmc.c **** /*
 165:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * De-assert the peripheral reset. The SDMMC peripheral
 166:../Libraries/XMCLib/src/xmc_sdmmc.c ****  * needs to be initialized
 167:../Libraries/XMCLib/src/xmc_sdmmc.c ****  */
 168:../Libraries/XMCLib/src/xmc_sdmmc.c **** void XMC_SDMMC_Enable(XMC_SDMMC_t *const sdmmc)
 169:../Libraries/XMCLib/src/xmc_sdmmc.c **** {
 134              	 .loc 2 169 0
 135              	 .cfi_startproc
 136              	 
 137              	 
 138 0000 80B5     	 push {r7,lr}
 139              	.LCFI12:
 140              	 .cfi_def_cfa_offset 8
 141              	 .cfi_offset 7,-8
 142              	 .cfi_offset 14,-4
 143 0002 82B0     	 sub sp,sp,#8
 144              	.LCFI13:
 145              	 .cfi_def_cfa_offset 16
 146 0004 00AF     	 add r7,sp,#0
 147              	.LCFI14:
 148              	 .cfi_def_cfa_register 7
 149 0006 7860     	 str r0,[r7,#4]
 170:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_Enable: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 171:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 172:../Libraries/XMCLib/src/xmc_sdmmc.c **** #if defined(CLOCK_GATING_SUPPORTED)
 173:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_SDMMC);
 150              	 .loc 2 173 0
 151 0008 0448     	 ldr r0,.L5
 152 000a FFF7FEFF 	 bl XMC_SCU_CLOCK_UngatePeripheralClock
 174:../Libraries/XMCLib/src/xmc_sdmmc.c **** #endif
 175:../Libraries/XMCLib/src/xmc_sdmmc.c **** #if defined(PERIPHERAL_RESET_SUPPORTED)
 176:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_SDMMC);
 153              	 .loc 2 176 0
 154 000e 0348     	 ldr r0,.L5
 155 0010 FFF7FEFF 	 bl XMC_SCU_RESET_DeassertPeripheralReset
 177:../Libraries/XMCLib/src/xmc_sdmmc.c **** #endif  
 178:../Libraries/XMCLib/src/xmc_sdmmc.c **** }
 156              	 .loc 2 178 0
 157 0014 0837     	 adds r7,r7,#8
 158              	.LCFI15:
 159              	 .cfi_def_cfa_offset 8
 160 0016 BD46     	 mov sp,r7
 161              	.LCFI16:
 162              	 .cfi_def_cfa_register 13
 163              	 
 164 0018 80BD     	 pop {r7,pc}
 165              	.L6:
 166 001a 00BF     	 .align 2
 167              	.L5:
 168 001c 40000010 	 .word 268435520
 169              	 .cfi_endproc
 170              	.LFE194:
 172              	 .section .text.XMC_SDMMC_Disable,"ax",%progbits
 173              	 .align 2
 174              	 .global XMC_SDMMC_Disable
 175              	 .thumb
 176              	 .thumb_func
 178              	XMC_SDMMC_Disable:
 179              	.LFB195:
 179:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 180:../Libraries/XMCLib/src/xmc_sdmmc.c **** /* Assert the peripheral reset */
 181:../Libraries/XMCLib/src/xmc_sdmmc.c **** void XMC_SDMMC_Disable(XMC_SDMMC_t *const sdmmc)
 182:../Libraries/XMCLib/src/xmc_sdmmc.c **** {
 180              	 .loc 2 182 0
 181              	 .cfi_startproc
 182              	 
 183              	 
 184 0000 80B5     	 push {r7,lr}
 185              	.LCFI17:
 186              	 .cfi_def_cfa_offset 8
 187              	 .cfi_offset 7,-8
 188              	 .cfi_offset 14,-4
 189 0002 82B0     	 sub sp,sp,#8
 190              	.LCFI18:
 191              	 .cfi_def_cfa_offset 16
 192 0004 00AF     	 add r7,sp,#0
 193              	.LCFI19:
 194              	 .cfi_def_cfa_register 7
 195 0006 7860     	 str r0,[r7,#4]
 183:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_Disable: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 184:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 185:../Libraries/XMCLib/src/xmc_sdmmc.c **** #if defined(PERIPHERAL_RESET_SUPPORTED)
 186:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_SCU_RESET_AssertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_SDMMC);
 196              	 .loc 2 186 0
 197 0008 0448     	 ldr r0,.L8
 198 000a FFF7FEFF 	 bl XMC_SCU_RESET_AssertPeripheralReset
 187:../Libraries/XMCLib/src/xmc_sdmmc.c **** #endif  
 188:../Libraries/XMCLib/src/xmc_sdmmc.c **** #if defined(CLOCK_GATING_SUPPORTED)
 189:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_SCU_CLOCK_GatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_SDMMC);
 199              	 .loc 2 189 0
 200 000e 0348     	 ldr r0,.L8
 201 0010 FFF7FEFF 	 bl XMC_SCU_CLOCK_GatePeripheralClock
 190:../Libraries/XMCLib/src/xmc_sdmmc.c **** #endif
 191:../Libraries/XMCLib/src/xmc_sdmmc.c **** }
 202              	 .loc 2 191 0
 203 0014 0837     	 adds r7,r7,#8
 204              	.LCFI20:
 205              	 .cfi_def_cfa_offset 8
 206 0016 BD46     	 mov sp,r7
 207              	.LCFI21:
 208              	 .cfi_def_cfa_register 13
 209              	 
 210 0018 80BD     	 pop {r7,pc}
 211              	.L9:
 212 001a 00BF     	 .align 2
 213              	.L8:
 214 001c 40000010 	 .word 268435520
 215              	 .cfi_endproc
 216              	.LFE195:
 218              	 .section .text.XMC_SDMMC_Init,"ax",%progbits
 219              	 .align 2
 220              	 .global XMC_SDMMC_Init
 221              	 .thumb
 222              	 .thumb_func
 224              	XMC_SDMMC_Init:
 225              	.LFB196:
 192:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 193:../Libraries/XMCLib/src/xmc_sdmmc.c **** /* Initialize SDMMC peripheral */
 194:../Libraries/XMCLib/src/xmc_sdmmc.c **** XMC_SDMMC_STATUS_t XMC_SDMMC_Init(XMC_SDMMC_t *const sdmmc, const XMC_SDMMC_CONFIG_t *config)
 195:../Libraries/XMCLib/src/xmc_sdmmc.c **** {
 226              	 .loc 2 195 0
 227              	 .cfi_startproc
 228              	 
 229              	 
 230 0000 80B5     	 push {r7,lr}
 231              	.LCFI22:
 232              	 .cfi_def_cfa_offset 8
 233              	 .cfi_offset 7,-8
 234              	 .cfi_offset 14,-4
 235 0002 82B0     	 sub sp,sp,#8
 236              	.LCFI23:
 237              	 .cfi_def_cfa_offset 16
 238 0004 00AF     	 add r7,sp,#0
 239              	.LCFI24:
 240              	 .cfi_def_cfa_register 7
 241 0006 7860     	 str r0,[r7,#4]
 242 0008 3960     	 str r1,[r7]
 196:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_Init: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 197:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_Init: Invalid clock divider value", XMC_SDMMC_CHECK_SDCLK_FREQ(config->cloc
 198:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_Init: Invalid bus width", XMC_SDMMC_CHECK_DATA_LINES(config->bus_width));
 199:../Libraries/XMCLib/src/xmc_sdmmc.c ****   
 200:../Libraries/XMCLib/src/xmc_sdmmc.c ****   /* Enable SDMMC peripheral */
 201:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_SDMMC_Enable(sdmmc);
 243              	 .loc 2 201 0
 244 000a 7868     	 ldr r0,[r7,#4]
 245 000c FFF7FEFF 	 bl XMC_SDMMC_Enable
 202:../Libraries/XMCLib/src/xmc_sdmmc.c ****   
 203:../Libraries/XMCLib/src/xmc_sdmmc.c ****   /* Write internal clock divider register */
 204:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->CLOCK_CTRL |= (uint16_t)((uint32_t)config->clock_divider << SDMMC_CLOCK_CTRL_SDCLK_FREQ_SE
 246              	 .loc 2 204 0
 247 0010 7B68     	 ldr r3,[r7,#4]
 248 0012 9B8D     	 ldrh r3,[r3,#44]
 249 0014 9AB2     	 uxth r2,r3
 250 0016 3B68     	 ldr r3,[r7]
 251 0018 5B78     	 ldrb r3,[r3,#1]
 252 001a 9BB2     	 uxth r3,r3
 253 001c 1B02     	 lsls r3,r3,#8
 254 001e 9BB2     	 uxth r3,r3
 255 0020 1343     	 orrs r3,r3,r2
 256 0022 9AB2     	 uxth r2,r3
 257 0024 7B68     	 ldr r3,[r7,#4]
 258 0026 9A85     	 strh r2,[r3,#44]
 205:../Libraries/XMCLib/src/xmc_sdmmc.c ****   
 206:../Libraries/XMCLib/src/xmc_sdmmc.c ****   /* Set bus width */
 207:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->HOST_CTRL = (uint8_t)((sdmmc->HOST_CTRL & (uint8_t)~SDMMC_HOST_CTRL_DATA_TX_WIDTH_Msk) |
 259              	 .loc 2 207 0
 260 0028 7B68     	 ldr r3,[r7,#4]
 261 002a 93F82830 	 ldrb r3,[r3,#40]
 262 002e DBB2     	 uxtb r3,r3
 263 0030 DBB2     	 uxtb r3,r3
 264 0032 23F00203 	 bic r3,r3,#2
 265 0036 DAB2     	 uxtb r2,r3
 208:../Libraries/XMCLib/src/xmc_sdmmc.c ****                                ((uint8_t)config->bus_width << SDMMC_HOST_CTRL_DATA_TX_WIDTH_Pos));
 266              	 .loc 2 208 0
 267 0038 3B68     	 ldr r3,[r7]
 268 003a 1B78     	 ldrb r3,[r3]
 269 003c 5B00     	 lsls r3,r3,#1
 207:../Libraries/XMCLib/src/xmc_sdmmc.c ****                                ((uint8_t)config->bus_width << SDMMC_HOST_CTRL_DATA_TX_WIDTH_Pos));
 270              	 .loc 2 207 0
 271 003e DBB2     	 uxtb r3,r3
 272 0040 1343     	 orrs r3,r3,r2
 273 0042 DBB2     	 uxtb r3,r3
 274 0044 DAB2     	 uxtb r2,r3
 275 0046 7B68     	 ldr r3,[r7,#4]
 276 0048 83F82820 	 strb r2,[r3,#40]
 209:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 210:../Libraries/XMCLib/src/xmc_sdmmc.c ****   return XMC_SDMMC_STATUS_SUCCESS;
 277              	 .loc 2 210 0
 278 004c 0023     	 movs r3,#0
 211:../Libraries/XMCLib/src/xmc_sdmmc.c **** }
 279              	 .loc 2 211 0
 280 004e 1846     	 mov r0,r3
 281 0050 0837     	 adds r7,r7,#8
 282              	.LCFI25:
 283              	 .cfi_def_cfa_offset 8
 284 0052 BD46     	 mov sp,r7
 285              	.LCFI26:
 286              	 .cfi_def_cfa_register 13
 287              	 
 288 0054 80BD     	 pop {r7,pc}
 289              	 .cfi_endproc
 290              	.LFE196:
 292 0056 00BF     	 .section .text.XMC_SDMMC_EnableEventStatus,"ax",%progbits
 293              	 .align 2
 294              	 .global XMC_SDMMC_EnableEventStatus
 295              	 .thumb
 296              	 .thumb_func
 298              	XMC_SDMMC_EnableEventStatus:
 299              	.LFB197:
 212:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 213:../Libraries/XMCLib/src/xmc_sdmmc.c **** /* Enable event status */
 214:../Libraries/XMCLib/src/xmc_sdmmc.c **** void XMC_SDMMC_EnableEventStatus(XMC_SDMMC_t *const sdmmc, uint32_t event)
 215:../Libraries/XMCLib/src/xmc_sdmmc.c **** {
 300              	 .loc 2 215 0
 301              	 .cfi_startproc
 302              	 
 303              	 
 304              	 
 305 0000 80B4     	 push {r7}
 306              	.LCFI27:
 307              	 .cfi_def_cfa_offset 4
 308              	 .cfi_offset 7,-4
 309 0002 83B0     	 sub sp,sp,#12
 310              	.LCFI28:
 311              	 .cfi_def_cfa_offset 16
 312 0004 00AF     	 add r7,sp,#0
 313              	.LCFI29:
 314              	 .cfi_def_cfa_register 7
 315 0006 7860     	 str r0,[r7,#4]
 316 0008 3960     	 str r1,[r7]
 216:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_EnableEventStatus: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmm
 217:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 218:../Libraries/XMCLib/src/xmc_sdmmc.c ****   /* Set INT status enable register */
 219:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->EN_INT_STATUS_NORM |= (uint16_t)event;
 317              	 .loc 2 219 0
 318 000a 7B68     	 ldr r3,[r7,#4]
 319 000c 9B8E     	 ldrh r3,[r3,#52]
 320 000e 9AB2     	 uxth r2,r3
 321 0010 3B68     	 ldr r3,[r7]
 322 0012 9BB2     	 uxth r3,r3
 323 0014 1343     	 orrs r3,r3,r2
 324 0016 9AB2     	 uxth r2,r3
 325 0018 7B68     	 ldr r3,[r7,#4]
 326 001a 9A86     	 strh r2,[r3,#52]
 220:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->EN_INT_STATUS_ERR |= (uint16_t)(event >> 16U);
 327              	 .loc 2 220 0
 328 001c 7B68     	 ldr r3,[r7,#4]
 329 001e DB8E     	 ldrh r3,[r3,#54]
 330 0020 9AB2     	 uxth r2,r3
 331 0022 3B68     	 ldr r3,[r7]
 332 0024 1B0C     	 lsrs r3,r3,#16
 333 0026 9BB2     	 uxth r3,r3
 334 0028 1343     	 orrs r3,r3,r2
 335 002a 9AB2     	 uxth r2,r3
 336 002c 7B68     	 ldr r3,[r7,#4]
 337 002e DA86     	 strh r2,[r3,#54]
 221:../Libraries/XMCLib/src/xmc_sdmmc.c **** }
 338              	 .loc 2 221 0
 339 0030 0C37     	 adds r7,r7,#12
 340              	.LCFI30:
 341              	 .cfi_def_cfa_offset 4
 342 0032 BD46     	 mov sp,r7
 343              	.LCFI31:
 344              	 .cfi_def_cfa_register 13
 345              	 
 346 0034 5DF8047B 	 ldr r7,[sp],#4
 347              	.LCFI32:
 348              	 .cfi_restore 7
 349              	 .cfi_def_cfa_offset 0
 350 0038 7047     	 bx lr
 351              	 .cfi_endproc
 352              	.LFE197:
 354 003a 00BF     	 .section .text.XMC_SDMMC_DisableEventStatus,"ax",%progbits
 355              	 .align 2
 356              	 .global XMC_SDMMC_DisableEventStatus
 357              	 .thumb
 358              	 .thumb_func
 360              	XMC_SDMMC_DisableEventStatus:
 361              	.LFB198:
 222:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 223:../Libraries/XMCLib/src/xmc_sdmmc.c **** /* Disable event status */
 224:../Libraries/XMCLib/src/xmc_sdmmc.c **** void XMC_SDMMC_DisableEventStatus(XMC_SDMMC_t *const sdmmc, uint32_t event)
 225:../Libraries/XMCLib/src/xmc_sdmmc.c **** {
 362              	 .loc 2 225 0
 363              	 .cfi_startproc
 364              	 
 365              	 
 366              	 
 367 0000 80B4     	 push {r7}
 368              	.LCFI33:
 369              	 .cfi_def_cfa_offset 4
 370              	 .cfi_offset 7,-4
 371 0002 83B0     	 sub sp,sp,#12
 372              	.LCFI34:
 373              	 .cfi_def_cfa_offset 16
 374 0004 00AF     	 add r7,sp,#0
 375              	.LCFI35:
 376              	 .cfi_def_cfa_register 7
 377 0006 7860     	 str r0,[r7,#4]
 378 0008 3960     	 str r1,[r7]
 226:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_DisableEventStatus: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdm
 227:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 228:../Libraries/XMCLib/src/xmc_sdmmc.c ****   /* Clear INT status enable register */
 229:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->EN_INT_STATUS_NORM &= (uint16_t)~event;
 379              	 .loc 2 229 0
 380 000a 7B68     	 ldr r3,[r7,#4]
 381 000c 9B8E     	 ldrh r3,[r3,#52]
 382 000e 9AB2     	 uxth r2,r3
 383 0010 3B68     	 ldr r3,[r7]
 384 0012 9BB2     	 uxth r3,r3
 385 0014 DB43     	 mvns r3,r3
 386 0016 9BB2     	 uxth r3,r3
 387 0018 1340     	 ands r3,r3,r2
 388 001a 9AB2     	 uxth r2,r3
 389 001c 7B68     	 ldr r3,[r7,#4]
 390 001e 9A86     	 strh r2,[r3,#52]
 230:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->EN_INT_STATUS_ERR &= (uint16_t)~(event >> 16U);
 391              	 .loc 2 230 0
 392 0020 7B68     	 ldr r3,[r7,#4]
 393 0022 DB8E     	 ldrh r3,[r3,#54]
 394 0024 9AB2     	 uxth r2,r3
 395 0026 3B68     	 ldr r3,[r7]
 396 0028 1B0C     	 lsrs r3,r3,#16
 397 002a 9BB2     	 uxth r3,r3
 398 002c DB43     	 mvns r3,r3
 399 002e 9BB2     	 uxth r3,r3
 400 0030 1340     	 ands r3,r3,r2
 401 0032 9AB2     	 uxth r2,r3
 402 0034 7B68     	 ldr r3,[r7,#4]
 403 0036 DA86     	 strh r2,[r3,#54]
 231:../Libraries/XMCLib/src/xmc_sdmmc.c **** }
 404              	 .loc 2 231 0
 405 0038 0C37     	 adds r7,r7,#12
 406              	.LCFI36:
 407              	 .cfi_def_cfa_offset 4
 408 003a BD46     	 mov sp,r7
 409              	.LCFI37:
 410              	 .cfi_def_cfa_register 13
 411              	 
 412 003c 5DF8047B 	 ldr r7,[sp],#4
 413              	.LCFI38:
 414              	 .cfi_restore 7
 415              	 .cfi_def_cfa_offset 0
 416 0040 7047     	 bx lr
 417              	 .cfi_endproc
 418              	.LFE198:
 420 0042 00BF     	 .section .text.XMC_SDMMC_EnableEvent,"ax",%progbits
 421              	 .align 2
 422              	 .global XMC_SDMMC_EnableEvent
 423              	 .thumb
 424              	 .thumb_func
 426              	XMC_SDMMC_EnableEvent:
 427              	.LFB199:
 232:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 233:../Libraries/XMCLib/src/xmc_sdmmc.c **** /* Enable SDMMC event */
 234:../Libraries/XMCLib/src/xmc_sdmmc.c **** void XMC_SDMMC_EnableEvent(XMC_SDMMC_t *const sdmmc, uint32_t event)
 235:../Libraries/XMCLib/src/xmc_sdmmc.c **** {
 428              	 .loc 2 235 0
 429              	 .cfi_startproc
 430              	 
 431              	 
 432 0000 80B5     	 push {r7,lr}
 433              	.LCFI39:
 434              	 .cfi_def_cfa_offset 8
 435              	 .cfi_offset 7,-8
 436              	 .cfi_offset 14,-4
 437 0002 82B0     	 sub sp,sp,#8
 438              	.LCFI40:
 439              	 .cfi_def_cfa_offset 16
 440 0004 00AF     	 add r7,sp,#0
 441              	.LCFI41:
 442              	 .cfi_def_cfa_register 7
 443 0006 7860     	 str r0,[r7,#4]
 444 0008 3960     	 str r1,[r7]
 236:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_EnableEvent: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 237:../Libraries/XMCLib/src/xmc_sdmmc.c ****   
 238:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_SDMMC_EnableEventStatus(sdmmc, event);
 445              	 .loc 2 238 0
 446 000a 7868     	 ldr r0,[r7,#4]
 447 000c 3968     	 ldr r1,[r7]
 448 000e FFF7FEFF 	 bl XMC_SDMMC_EnableEventStatus
 239:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 240:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->EN_INT_SIGNAL_NORM |= (uint16_t)event;
 449              	 .loc 2 240 0
 450 0012 7B68     	 ldr r3,[r7,#4]
 451 0014 1B8F     	 ldrh r3,[r3,#56]
 452 0016 9AB2     	 uxth r2,r3
 453 0018 3B68     	 ldr r3,[r7]
 454 001a 9BB2     	 uxth r3,r3
 455 001c 1343     	 orrs r3,r3,r2
 456 001e 9AB2     	 uxth r2,r3
 457 0020 7B68     	 ldr r3,[r7,#4]
 458 0022 1A87     	 strh r2,[r3,#56]
 241:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->EN_INT_SIGNAL_ERR |= (uint16_t)(event >> 16U);
 459              	 .loc 2 241 0
 460 0024 7B68     	 ldr r3,[r7,#4]
 461 0026 5B8F     	 ldrh r3,[r3,#58]
 462 0028 9AB2     	 uxth r2,r3
 463 002a 3B68     	 ldr r3,[r7]
 464 002c 1B0C     	 lsrs r3,r3,#16
 465 002e 9BB2     	 uxth r3,r3
 466 0030 1343     	 orrs r3,r3,r2
 467 0032 9AB2     	 uxth r2,r3
 468 0034 7B68     	 ldr r3,[r7,#4]
 469 0036 5A87     	 strh r2,[r3,#58]
 242:../Libraries/XMCLib/src/xmc_sdmmc.c **** }
 470              	 .loc 2 242 0
 471 0038 0837     	 adds r7,r7,#8
 472              	.LCFI42:
 473              	 .cfi_def_cfa_offset 8
 474 003a BD46     	 mov sp,r7
 475              	.LCFI43:
 476              	 .cfi_def_cfa_register 13
 477              	 
 478 003c 80BD     	 pop {r7,pc}
 479              	 .cfi_endproc
 480              	.LFE199:
 482 003e 00BF     	 .section .text.XMC_SDMMC_DisableEvent,"ax",%progbits
 483              	 .align 2
 484              	 .global XMC_SDMMC_DisableEvent
 485              	 .thumb
 486              	 .thumb_func
 488              	XMC_SDMMC_DisableEvent:
 489              	.LFB200:
 243:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 244:../Libraries/XMCLib/src/xmc_sdmmc.c **** /* Disable SDMMC event without disabling event status */
 245:../Libraries/XMCLib/src/xmc_sdmmc.c **** void XMC_SDMMC_DisableEvent(XMC_SDMMC_t *const sdmmc, uint32_t event)
 246:../Libraries/XMCLib/src/xmc_sdmmc.c **** {
 490              	 .loc 2 246 0
 491              	 .cfi_startproc
 492              	 
 493              	 
 494              	 
 495 0000 80B4     	 push {r7}
 496              	.LCFI44:
 497              	 .cfi_def_cfa_offset 4
 498              	 .cfi_offset 7,-4
 499 0002 83B0     	 sub sp,sp,#12
 500              	.LCFI45:
 501              	 .cfi_def_cfa_offset 16
 502 0004 00AF     	 add r7,sp,#0
 503              	.LCFI46:
 504              	 .cfi_def_cfa_register 7
 505 0006 7860     	 str r0,[r7,#4]
 506 0008 3960     	 str r1,[r7]
 247:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_DisableEvent: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 248:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 249:../Libraries/XMCLib/src/xmc_sdmmc.c ****   /* Clear INT signal enable register */
 250:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->EN_INT_SIGNAL_NORM &= (uint16_t)~event;
 507              	 .loc 2 250 0
 508 000a 7B68     	 ldr r3,[r7,#4]
 509 000c 1B8F     	 ldrh r3,[r3,#56]
 510 000e 9AB2     	 uxth r2,r3
 511 0010 3B68     	 ldr r3,[r7]
 512 0012 9BB2     	 uxth r3,r3
 513 0014 DB43     	 mvns r3,r3
 514 0016 9BB2     	 uxth r3,r3
 515 0018 1340     	 ands r3,r3,r2
 516 001a 9AB2     	 uxth r2,r3
 517 001c 7B68     	 ldr r3,[r7,#4]
 518 001e 1A87     	 strh r2,[r3,#56]
 251:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->EN_INT_SIGNAL_ERR &= (uint16_t)~(event >> 16U);
 519              	 .loc 2 251 0
 520 0020 7B68     	 ldr r3,[r7,#4]
 521 0022 5B8F     	 ldrh r3,[r3,#58]
 522 0024 9AB2     	 uxth r2,r3
 523 0026 3B68     	 ldr r3,[r7]
 524 0028 1B0C     	 lsrs r3,r3,#16
 525 002a 9BB2     	 uxth r3,r3
 526 002c DB43     	 mvns r3,r3
 527 002e 9BB2     	 uxth r3,r3
 528 0030 1340     	 ands r3,r3,r2
 529 0032 9AB2     	 uxth r2,r3
 530 0034 7B68     	 ldr r3,[r7,#4]
 531 0036 5A87     	 strh r2,[r3,#58]
 252:../Libraries/XMCLib/src/xmc_sdmmc.c **** }
 532              	 .loc 2 252 0
 533 0038 0C37     	 adds r7,r7,#12
 534              	.LCFI47:
 535              	 .cfi_def_cfa_offset 4
 536 003a BD46     	 mov sp,r7
 537              	.LCFI48:
 538              	 .cfi_def_cfa_register 13
 539              	 
 540 003c 5DF8047B 	 ldr r7,[sp],#4
 541              	.LCFI49:
 542              	 .cfi_restore 7
 543              	 .cfi_def_cfa_offset 0
 544 0040 7047     	 bx lr
 545              	 .cfi_endproc
 546              	.LFE200:
 548 0042 00BF     	 .section .text.XMC_SDMMC_ClearEvent,"ax",%progbits
 549              	 .align 2
 550              	 .global XMC_SDMMC_ClearEvent
 551              	 .thumb
 552              	 .thumb_func
 554              	XMC_SDMMC_ClearEvent:
 555              	.LFB201:
 253:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 254:../Libraries/XMCLib/src/xmc_sdmmc.c **** /* Clear SDMMC event(s) */
 255:../Libraries/XMCLib/src/xmc_sdmmc.c **** void XMC_SDMMC_ClearEvent(XMC_SDMMC_t *const sdmmc, uint32_t event)
 256:../Libraries/XMCLib/src/xmc_sdmmc.c **** {
 556              	 .loc 2 256 0
 557              	 .cfi_startproc
 558              	 
 559              	 
 560              	 
 561 0000 80B4     	 push {r7}
 562              	.LCFI50:
 563              	 .cfi_def_cfa_offset 4
 564              	 .cfi_offset 7,-4
 565 0002 83B0     	 sub sp,sp,#12
 566              	.LCFI51:
 567              	 .cfi_def_cfa_offset 16
 568 0004 00AF     	 add r7,sp,#0
 569              	.LCFI52:
 570              	 .cfi_def_cfa_register 7
 571 0006 7860     	 str r0,[r7,#4]
 572 0008 3960     	 str r1,[r7]
 257:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_ClearEvent: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 258:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_ClearEvent: Invalid bit-field", !(event & XMC_SDMMC_TARGET_RESP_ERR));
 259:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 260:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->INT_STATUS_NORM |= (uint16_t)event;
 573              	 .loc 2 260 0
 574 000a 7B68     	 ldr r3,[r7,#4]
 575 000c 1B8E     	 ldrh r3,[r3,#48]
 576 000e 9AB2     	 uxth r2,r3
 577 0010 3B68     	 ldr r3,[r7]
 578 0012 9BB2     	 uxth r3,r3
 579 0014 1343     	 orrs r3,r3,r2
 580 0016 9AB2     	 uxth r2,r3
 581 0018 7B68     	 ldr r3,[r7,#4]
 582 001a 1A86     	 strh r2,[r3,#48]
 261:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->INT_STATUS_ERR |= (uint16_t)(event >> 16U);
 583              	 .loc 2 261 0
 584 001c 7B68     	 ldr r3,[r7,#4]
 585 001e 5B8E     	 ldrh r3,[r3,#50]
 586 0020 9AB2     	 uxth r2,r3
 587 0022 3B68     	 ldr r3,[r7]
 588 0024 1B0C     	 lsrs r3,r3,#16
 589 0026 9BB2     	 uxth r3,r3
 590 0028 1343     	 orrs r3,r3,r2
 591 002a 9AB2     	 uxth r2,r3
 592 002c 7B68     	 ldr r3,[r7,#4]
 593 002e 5A86     	 strh r2,[r3,#50]
 262:../Libraries/XMCLib/src/xmc_sdmmc.c **** }
 594              	 .loc 2 262 0
 595 0030 0C37     	 adds r7,r7,#12
 596              	.LCFI53:
 597              	 .cfi_def_cfa_offset 4
 598 0032 BD46     	 mov sp,r7
 599              	.LCFI54:
 600              	 .cfi_def_cfa_register 13
 601              	 
 602 0034 5DF8047B 	 ldr r7,[sp],#4
 603              	.LCFI55:
 604              	 .cfi_restore 7
 605              	 .cfi_def_cfa_offset 0
 606 0038 7047     	 bx lr
 607              	 .cfi_endproc
 608              	.LFE201:
 610 003a 00BF     	 .section .text.XMC_SDMMC_GetEvent,"ax",%progbits
 611              	 .align 2
 612              	 .global XMC_SDMMC_GetEvent
 613              	 .thumb
 614              	 .thumb_func
 616              	XMC_SDMMC_GetEvent:
 617              	.LFB202:
 263:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 264:../Libraries/XMCLib/src/xmc_sdmmc.c **** /* Get the status of an SDMMC event */
 265:../Libraries/XMCLib/src/xmc_sdmmc.c **** bool XMC_SDMMC_GetEvent(XMC_SDMMC_t *const sdmmc, XMC_SDMMC_EVENT_t event)
 266:../Libraries/XMCLib/src/xmc_sdmmc.c **** {  
 618              	 .loc 2 266 0
 619              	 .cfi_startproc
 620              	 
 621              	 
 622              	 
 623 0000 80B4     	 push {r7}
 624              	.LCFI56:
 625              	 .cfi_def_cfa_offset 4
 626              	 .cfi_offset 7,-4
 627 0002 85B0     	 sub sp,sp,#20
 628              	.LCFI57:
 629              	 .cfi_def_cfa_offset 24
 630 0004 00AF     	 add r7,sp,#0
 631              	.LCFI58:
 632              	 .cfi_def_cfa_register 7
 633 0006 7860     	 str r0,[r7,#4]
 634 0008 3960     	 str r1,[r7]
 267:../Libraries/XMCLib/src/xmc_sdmmc.c ****   bool status;
 268:../Libraries/XMCLib/src/xmc_sdmmc.c ****   
 269:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_GetEvent: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 270:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_GetEvent: Invalid SDMMC event", XMC_SDMMC_CHECK_EVENT(event));
 271:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 272:../Libraries/XMCLib/src/xmc_sdmmc.c ****   if (event < XMC_SDMMC_CMD_TIMEOUT_ERR)
 635              	 .loc 2 272 0
 636 000a 3B68     	 ldr r3,[r7]
 637 000c B3F5803F 	 cmp r3,#65536
 638 0010 0CD2     	 bcs .L18
 273:../Libraries/XMCLib/src/xmc_sdmmc.c ****   {
 274:../Libraries/XMCLib/src/xmc_sdmmc.c ****     status = (bool)(sdmmc->INT_STATUS_NORM & (uint16_t)event);
 639              	 .loc 2 274 0
 640 0012 7B68     	 ldr r3,[r7,#4]
 641 0014 1B8E     	 ldrh r3,[r3,#48]
 642 0016 9AB2     	 uxth r2,r3
 643 0018 3B68     	 ldr r3,[r7]
 644 001a 9BB2     	 uxth r3,r3
 645 001c 1340     	 ands r3,r3,r2
 646 001e 9BB2     	 uxth r3,r3
 647 0020 002B     	 cmp r3,#0
 648 0022 14BF     	 ite ne
 649 0024 0123     	 movne r3,#1
 650 0026 0023     	 moveq r3,#0
 651 0028 FB73     	 strb r3,[r7,#15]
 652 002a 0CE0     	 b .L19
 653              	.L18:
 275:../Libraries/XMCLib/src/xmc_sdmmc.c ****   }
 276:../Libraries/XMCLib/src/xmc_sdmmc.c ****   else
 277:../Libraries/XMCLib/src/xmc_sdmmc.c ****   {
 278:../Libraries/XMCLib/src/xmc_sdmmc.c ****     status = (bool)(sdmmc->INT_STATUS_ERR & (uint16_t)((uint32_t)event >> 16U));
 654              	 .loc 2 278 0
 655 002c 7B68     	 ldr r3,[r7,#4]
 656 002e 5B8E     	 ldrh r3,[r3,#50]
 657 0030 9AB2     	 uxth r2,r3
 658 0032 3B68     	 ldr r3,[r7]
 659 0034 1B0C     	 lsrs r3,r3,#16
 660 0036 9BB2     	 uxth r3,r3
 661 0038 1340     	 ands r3,r3,r2
 662 003a 9BB2     	 uxth r3,r3
 663 003c 002B     	 cmp r3,#0
 664 003e 14BF     	 ite ne
 665 0040 0123     	 movne r3,#1
 666 0042 0023     	 moveq r3,#0
 667 0044 FB73     	 strb r3,[r7,#15]
 668              	.L19:
 279:../Libraries/XMCLib/src/xmc_sdmmc.c ****   }
 280:../Libraries/XMCLib/src/xmc_sdmmc.c ****   
 281:../Libraries/XMCLib/src/xmc_sdmmc.c ****   return status;
 669              	 .loc 2 281 0
 670 0046 FB7B     	 ldrb r3,[r7,#15]
 282:../Libraries/XMCLib/src/xmc_sdmmc.c **** }
 671              	 .loc 2 282 0
 672 0048 1846     	 mov r0,r3
 673 004a 1437     	 adds r7,r7,#20
 674              	.LCFI59:
 675              	 .cfi_def_cfa_offset 4
 676 004c BD46     	 mov sp,r7
 677              	.LCFI60:
 678              	 .cfi_def_cfa_register 13
 679              	 
 680 004e 5DF8047B 	 ldr r7,[sp],#4
 681              	.LCFI61:
 682              	 .cfi_restore 7
 683              	 .cfi_def_cfa_offset 0
 684 0052 7047     	 bx lr
 685              	 .cfi_endproc
 686              	.LFE202:
 688              	 .section .text.XMC_SDMMC_GetR2Response,"ax",%progbits
 689              	 .align 2
 690              	 .global XMC_SDMMC_GetR2Response
 691              	 .thumb
 692              	 .thumb_func
 694              	XMC_SDMMC_GetR2Response:
 695              	.LFB203:
 283:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 284:../Libraries/XMCLib/src/xmc_sdmmc.c **** /* Read R2 response (CID, CSD register) */
 285:../Libraries/XMCLib/src/xmc_sdmmc.c **** void XMC_SDMMC_GetR2Response(XMC_SDMMC_t *const sdmmc, XMC_SDMMC_RESPONSE_t *const response)
 286:../Libraries/XMCLib/src/xmc_sdmmc.c **** {
 696              	 .loc 2 286 0
 697              	 .cfi_startproc
 698              	 
 699              	 
 700              	 
 701 0000 80B4     	 push {r7}
 702              	.LCFI62:
 703              	 .cfi_def_cfa_offset 4
 704              	 .cfi_offset 7,-4
 705 0002 83B0     	 sub sp,sp,#12
 706              	.LCFI63:
 707              	 .cfi_def_cfa_offset 16
 708 0004 00AF     	 add r7,sp,#0
 709              	.LCFI64:
 710              	 .cfi_def_cfa_register 7
 711 0006 7860     	 str r0,[r7,#4]
 712 0008 3960     	 str r1,[r7]
 287:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_GetR2Response: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 288:../Libraries/XMCLib/src/xmc_sdmmc.c ****   
 289:../Libraries/XMCLib/src/xmc_sdmmc.c ****   response->response_0 = sdmmc->RESPONSE[0];
 713              	 .loc 2 289 0
 714 000a 7B68     	 ldr r3,[r7,#4]
 715 000c 1A69     	 ldr r2,[r3,#16]
 716 000e 3B68     	 ldr r3,[r7]
 717 0010 1A60     	 str r2,[r3]
 290:../Libraries/XMCLib/src/xmc_sdmmc.c ****   response->response_2 = sdmmc->RESPONSE[1];
 718              	 .loc 2 290 0
 719 0012 7B68     	 ldr r3,[r7,#4]
 720 0014 5A69     	 ldr r2,[r3,#20]
 721 0016 3B68     	 ldr r3,[r7]
 722 0018 5A60     	 str r2,[r3,#4]
 291:../Libraries/XMCLib/src/xmc_sdmmc.c ****   response->response_4 = sdmmc->RESPONSE[2];
 723              	 .loc 2 291 0
 724 001a 7B68     	 ldr r3,[r7,#4]
 725 001c 9A69     	 ldr r2,[r3,#24]
 726 001e 3B68     	 ldr r3,[r7]
 727 0020 9A60     	 str r2,[r3,#8]
 292:../Libraries/XMCLib/src/xmc_sdmmc.c ****   response->response_6 = sdmmc->RESPONSE[3];
 728              	 .loc 2 292 0
 729 0022 7B68     	 ldr r3,[r7,#4]
 730 0024 DA69     	 ldr r2,[r3,#28]
 731 0026 3B68     	 ldr r3,[r7]
 732 0028 DA60     	 str r2,[r3,#12]
 293:../Libraries/XMCLib/src/xmc_sdmmc.c **** }
 733              	 .loc 2 293 0
 734 002a 0C37     	 adds r7,r7,#12
 735              	.LCFI65:
 736              	 .cfi_def_cfa_offset 4
 737 002c BD46     	 mov sp,r7
 738              	.LCFI66:
 739              	 .cfi_def_cfa_register 13
 740              	 
 741 002e 5DF8047B 	 ldr r7,[sp],#4
 742              	.LCFI67:
 743              	 .cfi_restore 7
 744              	 .cfi_def_cfa_offset 0
 745 0032 7047     	 bx lr
 746              	 .cfi_endproc
 747              	.LFE203:
 749              	 .section .text.XMC_SDMMC_SendCommand,"ax",%progbits
 750              	 .align 2
 751              	 .global XMC_SDMMC_SendCommand
 752              	 .thumb
 753              	 .thumb_func
 755              	XMC_SDMMC_SendCommand:
 756              	.LFB204:
 294:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 295:../Libraries/XMCLib/src/xmc_sdmmc.c **** /* Send SDMMC command */
 296:../Libraries/XMCLib/src/xmc_sdmmc.c **** XMC_SDMMC_STATUS_t XMC_SDMMC_SendCommand(XMC_SDMMC_t *const sdmmc, const XMC_SDMMC_COMMAND_t *cmd, 
 297:../Libraries/XMCLib/src/xmc_sdmmc.c **** {
 757              	 .loc 2 297 0
 758              	 .cfi_startproc
 759              	 
 760              	 
 761              	 
 762 0000 80B4     	 push {r7}
 763              	.LCFI68:
 764              	 .cfi_def_cfa_offset 4
 765              	 .cfi_offset 7,-4
 766 0002 85B0     	 sub sp,sp,#20
 767              	.LCFI69:
 768              	 .cfi_def_cfa_offset 24
 769 0004 00AF     	 add r7,sp,#0
 770              	.LCFI70:
 771              	 .cfi_def_cfa_register 7
 772 0006 F860     	 str r0,[r7,#12]
 773 0008 B960     	 str r1,[r7,#8]
 774 000a 7A60     	 str r2,[r7,#4]
 298:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_SendCommand: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sdmmc));
 299:../Libraries/XMCLib/src/xmc_sdmmc.c ****   
 300:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->ARGUMENT1 = arg;
 775              	 .loc 2 300 0
 776 000c FB68     	 ldr r3,[r7,#12]
 777 000e 7A68     	 ldr r2,[r7,#4]
 778 0010 9A60     	 str r2,[r3,#8]
 301:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->COMMAND = (uint16_t)(*(uint16_t *)cmd);
 779              	 .loc 2 301 0
 780 0012 BB68     	 ldr r3,[r7,#8]
 781 0014 1A88     	 ldrh r2,[r3]
 782 0016 FB68     	 ldr r3,[r7,#12]
 783 0018 DA81     	 strh r2,[r3,#14]
 302:../Libraries/XMCLib/src/xmc_sdmmc.c ****   
 303:../Libraries/XMCLib/src/xmc_sdmmc.c ****   return XMC_SDMMC_STATUS_SUCCESS;
 784              	 .loc 2 303 0
 785 001a 0023     	 movs r3,#0
 304:../Libraries/XMCLib/src/xmc_sdmmc.c **** }
 786              	 .loc 2 304 0
 787 001c 1846     	 mov r0,r3
 788 001e 1437     	 adds r7,r7,#20
 789              	.LCFI71:
 790              	 .cfi_def_cfa_offset 4
 791 0020 BD46     	 mov sp,r7
 792              	.LCFI72:
 793              	 .cfi_def_cfa_register 13
 794              	 
 795 0022 5DF8047B 	 ldr r7,[sp],#4
 796              	.LCFI73:
 797              	 .cfi_restore 7
 798              	 .cfi_def_cfa_offset 0
 799 0026 7047     	 bx lr
 800              	 .cfi_endproc
 801              	.LFE204:
 803              	 .section .text.XMC_SDMMC_SetDataTransferMode,"ax",%progbits
 804              	 .align 2
 805              	 .global XMC_SDMMC_SetDataTransferMode
 806              	 .thumb
 807              	 .thumb_func
 809              	XMC_SDMMC_SetDataTransferMode:
 810              	.LFB205:
 305:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 306:../Libraries/XMCLib/src/xmc_sdmmc.c **** /* Set data transfer mode */
 307:../Libraries/XMCLib/src/xmc_sdmmc.c **** void XMC_SDMMC_SetDataTransferMode(XMC_SDMMC_t *const sdmmc, XMC_SDMMC_TRANSFER_MODE_t *const respo
 308:../Libraries/XMCLib/src/xmc_sdmmc.c **** {
 811              	 .loc 2 308 0
 812              	 .cfi_startproc
 813              	 
 814              	 
 815 0000 80B5     	 push {r7,lr}
 816              	.LCFI74:
 817              	 .cfi_def_cfa_offset 8
 818              	 .cfi_offset 7,-8
 819              	 .cfi_offset 14,-4
 820 0002 82B0     	 sub sp,sp,#8
 821              	.LCFI75:
 822              	 .cfi_def_cfa_offset 16
 823 0004 00AF     	 add r7,sp,#0
 824              	.LCFI76:
 825              	 .cfi_def_cfa_register 7
 826 0006 7860     	 str r0,[r7,#4]
 827 0008 3960     	 str r1,[r7]
 309:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_SetDataTransferMode: Invalid module pointer", XMC_SDMMC_CHECK_MODULE_PTR(sd
 310:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_ASSERT("XMC_SDMMC_SetDataTransferMode: Invalid transfer type", XMC_SDMMC_CHECK_TRANSFER_MODE(
 311:../Libraries/XMCLib/src/xmc_sdmmc.c ****   
 312:../Libraries/XMCLib/src/xmc_sdmmc.c ****   /* Data line time-out */
 313:../Libraries/XMCLib/src/xmc_sdmmc.c ****   XMC_SDMMC_SetDataLineTimeout(sdmmc, XMC_SDMMC_DAT_TIMEOUT_COUNTER_2_POW_27);
 828              	 .loc 2 313 0
 829 000a 7868     	 ldr r0,[r7,#4]
 830 000c 0E21     	 movs r1,#14
 831 000e FFF7FEFF 	 bl XMC_SDMMC_SetDataLineTimeout
 314:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 315:../Libraries/XMCLib/src/xmc_sdmmc.c ****   /* Block size */
 316:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->BLOCK_SIZE = (uint16_t)(response->block_size);
 832              	 .loc 2 316 0
 833 0012 3B68     	 ldr r3,[r7]
 834 0014 1B68     	 ldr r3,[r3]
 835 0016 9AB2     	 uxth r2,r3
 836 0018 7B68     	 ldr r3,[r7,#4]
 837 001a 9A80     	 strh r2,[r3,#4]
 317:../Libraries/XMCLib/src/xmc_sdmmc.c ****   
 318:../Libraries/XMCLib/src/xmc_sdmmc.c ****   /* Number of blocks */
 319:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->BLOCK_COUNT = (uint16_t)(response->num_blocks);
 838              	 .loc 2 319 0
 839 001c 3B68     	 ldr r3,[r7]
 840 001e 5B68     	 ldr r3,[r3,#4]
 841 0020 9AB2     	 uxth r2,r3
 842 0022 7B68     	 ldr r3,[r7,#4]
 843 0024 DA80     	 strh r2,[r3,#6]
 320:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 321:../Libraries/XMCLib/src/xmc_sdmmc.c ****   /* Type of data transfer: single, infinite, multiple or stop multiple */
 322:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->TRANSFER_MODE = (uint16_t)((sdmmc->TRANSFER_MODE & (uint16_t)~SDMMC_TRANSFER_MODE_MULTI_BL
 844              	 .loc 2 322 0
 845 0026 7B68     	 ldr r3,[r7,#4]
 846 0028 9B89     	 ldrh r3,[r3,#12]
 847 002a 9BB2     	 uxth r3,r3
 848 002c 9BB2     	 uxth r3,r3
 849 002e 23F02003 	 bic r3,r3,#32
 850 0032 9AB2     	 uxth r2,r3
 323:../Libraries/XMCLib/src/xmc_sdmmc.c ****                                     ((uint16_t)response->type));
 851              	 .loc 2 323 0
 852 0034 3B68     	 ldr r3,[r7]
 853 0036 1B7A     	 ldrb r3,[r3,#8]
 322:../Libraries/XMCLib/src/xmc_sdmmc.c ****                                     ((uint16_t)response->type));
 854              	 .loc 2 322 0
 855 0038 9BB2     	 uxth r3,r3
 856 003a 1343     	 orrs r3,r3,r2
 857 003c 9BB2     	 uxth r3,r3
 858 003e 9AB2     	 uxth r2,r3
 859 0040 7B68     	 ldr r3,[r7,#4]
 860 0042 9A81     	 strh r2,[r3,#12]
 324:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 325:../Libraries/XMCLib/src/xmc_sdmmc.c ****   /*
 326:../Libraries/XMCLib/src/xmc_sdmmc.c ****    * Clear block count enable bit; that's only valid for
 327:../Libraries/XMCLib/src/xmc_sdmmc.c ****    * a multi-block transfer
 328:../Libraries/XMCLib/src/xmc_sdmmc.c ****    */
 329:../Libraries/XMCLib/src/xmc_sdmmc.c ****   if (response->type == XMC_SDMMC_TRANSFER_MODE_TYPE_SINGLE)
 861              	 .loc 2 329 0
 862 0044 3B68     	 ldr r3,[r7]
 863 0046 1B7A     	 ldrb r3,[r3,#8]
 864 0048 002B     	 cmp r3,#0
 865 004a 07D1     	 bne .L25
 330:../Libraries/XMCLib/src/xmc_sdmmc.c ****   {
 331:../Libraries/XMCLib/src/xmc_sdmmc.c ****     sdmmc->TRANSFER_MODE &= (uint16_t)~SDMMC_TRANSFER_MODE_BLOCK_COUNT_EN_Msk;
 866              	 .loc 2 331 0
 867 004c 7B68     	 ldr r3,[r7,#4]
 868 004e 9B89     	 ldrh r3,[r3,#12]
 869 0050 9BB2     	 uxth r3,r3
 870 0052 23F00203 	 bic r3,r3,#2
 871 0056 9AB2     	 uxth r2,r3
 872 0058 7B68     	 ldr r3,[r7,#4]
 873 005a 9A81     	 strh r2,[r3,#12]
 874              	.L25:
 332:../Libraries/XMCLib/src/xmc_sdmmc.c ****   }
 333:../Libraries/XMCLib/src/xmc_sdmmc.c **** 
 334:../Libraries/XMCLib/src/xmc_sdmmc.c ****   /* Auto CMD configuration */
 335:../Libraries/XMCLib/src/xmc_sdmmc.c ****   sdmmc->TRANSFER_MODE = (uint16_t)((sdmmc->TRANSFER_MODE & (uint16_t)~SDMMC_TRANSFER_MODE_ACMD_EN_
 875              	 .loc 2 335 0
 876 005c 7B68     	 ldr r3,[r7,#4]
 877 005e 9B89     	 ldrh r3,[r3,#12]
 878 0060 9BB2     	 uxth r3,r3
 879 0062 9BB2     	 uxth r3,r3
 880 0064 23F00C03 	 bic r3,r3,#12
 881 0068 9AB2     	 uxth r2,r3
 336:../Libraries/XMCLib/src/xmc_sdmmc.c ****                                     ((uint16_t)response->auto_cmd << SDMMC_TRANSFER_MODE_ACMD_EN_Po
 882              	 .loc 2 336 0
 883 006a 3B68     	 ldr r3,[r7]
 884 006c 5B7A     	 ldrb r3,[r3,#9]
 885 006e 9B00     	 lsls r3,r3,#2
 335:../Libraries/XMCLib/src/xmc_sdmmc.c ****                                     ((uint16_t)response->auto_cmd << SDMMC_TRANSFER_MODE_ACMD_EN_Po
 886              	 .loc 2 335 0
 887 0070 9BB2     	 uxth r3,r3
 888 0072 1343     	 orrs r3,r3,r2
 889 0074 9BB2     	 uxth r3,r3
 890 0076 9AB2     	 uxth r2,r3
 891 0078 7B68     	 ldr r3,[r7,#4]
 892 007a 9A81     	 strh r2,[r3,#12]
 337:../Libraries/XMCLib/src/xmc_sdmmc.c **** }
 893              	 .loc 2 337 0
 894 007c 0837     	 adds r7,r7,#8
 895              	.LCFI77:
 896              	 .cfi_def_cfa_offset 8
 897 007e BD46     	 mov sp,r7
 898              	.LCFI78:
 899              	 .cfi_def_cfa_register 13
 900              	 
 901 0080 80BD     	 pop {r7,pc}
 902              	 .cfi_endproc
 903              	.LFE205:
 905 0082 00BF     	 .text
 906              	.Letext0:
 907              	 .file 3 "e:\\davev4\\dave-4.1.4\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 908              	 .file 4 "e:\\davev4\\dave-4.1.4\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 909              	 .file 5 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Libraries\\XMCLib\\inc/xmc4_scu.h"
 910              	 .file 6 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode/Libraries/CMSIS/Include/core_cm4.h"
 911              	 .file 7 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode/Libraries/CMSIS/Infineon/XMC4700_series/Include/system_XMC4700.h"
DEFINED SYMBOLS
                            *ABS*:00000000 xmc_sdmmc.c
    {standard input}:20     .text.XMC_SDMMC_SetDataLineTimeout:00000000 $t
    {standard input}:24     .text.XMC_SDMMC_SetDataLineTimeout:00000000 XMC_SDMMC_SetDataLineTimeout
    {standard input}:75     .text.XMC_SDMMC_GetPowerStatus:00000000 $t
    {standard input}:80     .text.XMC_SDMMC_GetPowerStatus:00000000 XMC_SDMMC_GetPowerStatus
    {standard input}:127    .text.XMC_SDMMC_Enable:00000000 $t
    {standard input}:132    .text.XMC_SDMMC_Enable:00000000 XMC_SDMMC_Enable
    {standard input}:168    .text.XMC_SDMMC_Enable:0000001c $d
    {standard input}:173    .text.XMC_SDMMC_Disable:00000000 $t
    {standard input}:178    .text.XMC_SDMMC_Disable:00000000 XMC_SDMMC_Disable
    {standard input}:214    .text.XMC_SDMMC_Disable:0000001c $d
    {standard input}:219    .text.XMC_SDMMC_Init:00000000 $t
    {standard input}:224    .text.XMC_SDMMC_Init:00000000 XMC_SDMMC_Init
    {standard input}:293    .text.XMC_SDMMC_EnableEventStatus:00000000 $t
    {standard input}:298    .text.XMC_SDMMC_EnableEventStatus:00000000 XMC_SDMMC_EnableEventStatus
    {standard input}:355    .text.XMC_SDMMC_DisableEventStatus:00000000 $t
    {standard input}:360    .text.XMC_SDMMC_DisableEventStatus:00000000 XMC_SDMMC_DisableEventStatus
    {standard input}:421    .text.XMC_SDMMC_EnableEvent:00000000 $t
    {standard input}:426    .text.XMC_SDMMC_EnableEvent:00000000 XMC_SDMMC_EnableEvent
    {standard input}:483    .text.XMC_SDMMC_DisableEvent:00000000 $t
    {standard input}:488    .text.XMC_SDMMC_DisableEvent:00000000 XMC_SDMMC_DisableEvent
    {standard input}:549    .text.XMC_SDMMC_ClearEvent:00000000 $t
    {standard input}:554    .text.XMC_SDMMC_ClearEvent:00000000 XMC_SDMMC_ClearEvent
    {standard input}:611    .text.XMC_SDMMC_GetEvent:00000000 $t
    {standard input}:616    .text.XMC_SDMMC_GetEvent:00000000 XMC_SDMMC_GetEvent
    {standard input}:689    .text.XMC_SDMMC_GetR2Response:00000000 $t
    {standard input}:694    .text.XMC_SDMMC_GetR2Response:00000000 XMC_SDMMC_GetR2Response
    {standard input}:750    .text.XMC_SDMMC_SendCommand:00000000 $t
    {standard input}:755    .text.XMC_SDMMC_SendCommand:00000000 XMC_SDMMC_SendCommand
    {standard input}:804    .text.XMC_SDMMC_SetDataTransferMode:00000000 $t
    {standard input}:809    .text.XMC_SDMMC_SetDataTransferMode:00000000 XMC_SDMMC_SetDataTransferMode
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
XMC_SCU_CLOCK_UngatePeripheralClock
XMC_SCU_RESET_DeassertPeripheralReset
XMC_SCU_RESET_AssertPeripheralReset
XMC_SCU_CLOCK_GatePeripheralClock
